<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  LZH007
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="LZH007" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:lockxmonk.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; LZH007</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="MAC%20OS.html">MAC OS</a></li>
        
            <li><a href="Effective%20OC2.0.html">Effective OC2.0</a></li>
        
            <li><a href="English%20Study.html">English Study</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html">统计学习方法</a></li>
        
            <li><a href="Python%E7%BB%83%E4%B9%A0.html">Python练习</a></li>
        
            <li><a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html">图像去雾技术</a></li>
        
            <li><a href="iOS.html">iOS</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14927355881897.html">
                
                  <h1>使用元类</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">metaclass</a>
</li>
</ul>


<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是<strong>运行时动态创建的</strong>。</p>

<p>比方说我们要定义一个<code>Hello</code>的class：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Hello(object):
    def hello(self, name=&#39;world&#39;):
        print(&#39;Hello, %s.&#39; % name)
h = Hello()
h.hello()
print (type(Hello))
print (type(h))
</code></pre>

<p><img src="media/14927355881897/14927620006235.jpg" alt=""/></p>

<p><font color=red><strong><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个class，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是<code>class Hello</code>。</strong></font></p>

<p>我们说class的定义是运行时动态创建的，而<strong>创建class的方法就是使用<code>type()</code>函数</strong>。</p>

<p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，<strong>我们可以通过<code>type()</code>函数创建出Hello类，而无需通过<code>class Hello(object)...</code>的定义</strong>：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
def fn(self, name=&#39;world&#39;):   # 先定义函数
    print(&#39;Hello, %s.&#39; % name)

Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn))  # 创建Hello class
h = Hello()
h.hello()
print(type(Hello))
print(type(h))

</code></pre>

<p><img src="media/14927355881897/14927623112362.jpg" alt=""/></p>

<p><strong>要创建一个class对象，type()函数依次传入3个参数：</strong></p>

<ol>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li>
<li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li>
</ol>

<p>通过<code>type()</code>函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p>

<blockquote>
<p>正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
</blockquote>

<h2 id="toc_0">metaclass</h2>

<p>除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用metaclass。<br/>
简单的解释就是：先定义metaclass，就可以创建类，最后创建实例。</p>

<p>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</p>

<p><strong>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</strong></p>

<p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：</p>

<p>定义<code>ListMetaclass</code>，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

# metaclass是创建类，所以必须从`type`类型派生：
class ListMetaclass(type):

    def __new__(cls, name, bases, attrs):
        attrs[&#39;add&#39;] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)


class MyList(list):
    __metaclass__ = ListMetaclass  # 指示使用ListMetaclass来定制类
</code></pre>

<p>当我们写下<code>__metaclass__ = ListMetaclass</code>语句时，魔术就生效了，它指示Python解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>

<p><code>__new__()</code><strong>方法接收到的参数依次是</strong>：</p>

<ol>
<li><p>当前准备创建的类的对象；</p></li>
<li><p>类的名字；</p></li>
<li><p>类继承的父类集合；</p></li>
<li><p>类的方法集合。</p></li>
</ol>

<p>我们测试输出为：</p>

<pre><code class="language-py">L = MyList()
L.add(1)
print L
</code></pre>

<p><img src="media/14927355881897/14927637008533.jpg" alt=""/></p>

<p>动态修改有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。</p>

<p>但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。</p>

<p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</p>

<p>要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p>

<p>具体方法参见<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820064557c69858840b4c48d2b8411bc2ea9099ba000">廖老师的教学网站</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14926766188460.html">
                
                  <h1>面向对象高级编程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">使用__slots__</a>
</li>
<li>
<a href="#toc_1">使用@property</a>
</li>
<li>
<a href="#toc_2">多重继承</a>
<ul>
<li>
<a href="#toc_3">Mixin</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">定制类</a>
<ul>
<li>
<a href="#toc_5">__str__</a>
</li>
<li>
<a href="#toc_6">__iter__</a>
</li>
<li>
<a href="#toc_7">__getitem__</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">__getattr__</a>
</li>
<li>
<a href="#toc_9">__call__</a>
</li>
</ul>


<p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。</p>

<p><strong><em>我们可以动态的给某一个实例绑定属性、方法。要绑定该类所有的实例的话，则可以将方法绑定到该类上。</em></strong></p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Student(object):
    &quot;&quot;&quot;docstring for Student&quot;&quot;&quot;
    pass
s = Student()
s.name = &#39;梁中豪&#39;  # 动态给实例绑定一个属性

from types import MethodType


def set_age(self, age):  # 定义一个函数作为实例方法
    self.age = age
s.set_age = MethodType(set_age, s, Student)  # 给实例绑定一个方法
s.set_age(25)

# 为了给所有实例都绑定方法，可以给class绑定方法：


def set_score(self, score):  # 定义一个函数作为实例方法
    self.score = score
Student.set_score = MethodType(set_score, None, Student)
s.set_score(100) #给class绑定方法后，所有实例均可调用
s2 = Student()
s2.set_score(90)
print s.name, s.age, s.score, s2.score
</code></pre>

<p><img src="media/14926766188460/14926773474695.jpg" alt=""/></p>

<h2 id="toc_0">使用__slots__</h2>

<p>如果我们想要限制class的属性怎么办？比如，只允许对Student实例添加<code>name和age</code>属性。那么可以使用一个特殊的<code>__slots__</code>变量。</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Student(object):
    &quot;&quot;&quot;docstring for Student&quot;&quot;&quot;
    __slots__ = (&#39;name&#39;,&#39;age&#39;)
    
s = Student()
s.name = &#39;梁中豪&#39;
s.age = 21
print s.name, s.age
s.score = 90
print s.score

</code></pre>

<p><img src="media/14926766188460/14926779162430.jpg" alt=""/></p>

<p><font color=red>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类起作用，对继承的子类是不起作用的. 除非在子类中也定义<code>__slots__</code>，这样，子类允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。<br/>
</font></p>

<h2 id="toc_1">使用@property</h2>

<p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改。</p>

<p>这显然不合逻辑。为了限制score的范围，可以通过一个<code>set_score()</code>方法来设置成绩，再通过一个<code>get_score()</code>来获取成绩，这样，在<code>set_score()</code>方法里，就可以检查参数：</p>

<pre><code class="language-py">class Student(object):

    def get_score(self):
        return self._score

    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value
s = Student()
s.set_score(50)
s.get_score()
s.set_score(999)
s.get_score()
</code></pre>

<p><img src="media/14926766188460/14927376402165.jpg" alt=""/></p>

<p>上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p>

<p>对于类的方法，装饰器一样起作用。Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>

<pre><code class="language-py">
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value

s = Student
s.score = 60
print s.score
</code></pre>

<p><code>@property</code>的实现比较复杂，我们先考察如何使用。把一个<code>getter</code>方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个<code>setter</code>方法变成属性赋值</p>

<p>如果只定义getter方法，不定义setter方法就是一个只读属性：</p>

<pre><code class="language-py">class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2014 - self._birth
s = Student()
s.birth = 23
print s.birth
</code></pre>

<h2 id="toc_2">多重继承</h2>

<p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。</p>

<p>一个类可以继承多个类，称为多重继承，如下所示：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Animal(object):
    &quot;&quot;&quot;docstring for Animal&quot;&quot;&quot;
    pass


class Mammal(Animal):
    &quot;&quot;&quot;docstring for Mammal&quot;&quot;&quot;
    print &#39;Mammal&#39;


class Bird(Animal):
    &quot;&quot;&quot;docstring for Bird&quot;&quot;&quot;
    print &#39;Bird&#39;


class Runable(object):
    &quot;&quot;&quot;docstring for Runable&quot;&quot;&quot;

    def run(self):
        print &#39;Running...&#39;


class Flyable(object):
    &quot;&quot;&quot;docstring for Flyable&quot;&quot;&quot;

    def fly(self):
        print &#39;Flying...&#39;


class Dog(Mammal, Runable):
    &quot;&quot;&quot;docstring for Dog&quot;&quot;&quot;
    pass


class Bat(Mammal, Flyable):
    &quot;&quot;&quot;docstring for Bat&quot;&quot;&quot;
    pass
</code></pre>

<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>

<h3 id="toc_3">Mixin</h3>

<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<code>Mixin</code>。</p>

<p>为了更好地看出继承关系，我们把Runnable和Flyable改为<code>RunnableMixin</code>和<code>FlyableMixin</code>。类似的，你还可以定义出肉食动物<code>CarnivorousMixin</code>和植食动物<code>HerbivoresMixin</code>，让某个动物同时拥有好几个<code>Mixin</code>：</p>

<pre><code class="language-py">class Dog(Mammal, RunnableMixin, CarnivorousMixin):
    pass
</code></pre>

<p>由于Python允许使用多重继承，因此，Mixin就是一种常见的设计。</p>

<p><strong>只允许单一继承的语言（如Java）不能使用Mixin的设计</strong>。</p>

<h2 id="toc_4">定制类</h2>

<p>看到类似<code>__slots__</code>这种形如<code>__xxx__</code>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>

<p>类似有很多特殊变量来帮助我们定制类：</p>

<h3 id="toc_5">__str__</h3>

<p>我们先定义一个<code>Student</code>类，打印一个实例：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;
    def __init__(self, name):
        super(Students, self).__init__()
        self.name = name
print Students(&#39;LZH&#39;)
</code></pre>

<p><img src="media/14926766188460/14927559673818.jpg" alt=""/><br/>
得到上图所示，我们可以定制所打印的内容。</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;
    def __init__(self, name):
        super(Students, self).__init__()
        self.name = name
    def __str__(self):
        return &#39;Students object (name:%s)&#39; %self.name
print Students(&#39;LZH&#39;)
</code></pre>

<p><img src="media/14926766188460/14927560929527.jpg" alt=""/><br/>
这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。<br/>
当然这只是负责定制<code>print</code>方法输出的内容。直接敲变量不用<code>print</code>，打印出来的实例还是不好看。</p>

<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>

<pre><code class="language-py">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return &#39;Student object (name=%s)&#39; % self.name
    __repr__ = __str__  #因为两者方法几乎一样，所以可以直接偷懒将前者赋值给repr
</code></pre>

<h3 id="toc_6">__iter__</h3>

<p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list或tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>next()</code>方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>

<p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Fib(object):
    &quot;&quot;&quot;docstring for Fib&quot;&quot;&quot;

    def __init__(self):
        self.a, self.b = 0, 1  # 初始化两个计数器a，b

    def __iter__(self):
        return self  # 实例本身就是迭代对象，故返回自己

    def next(self):
        self.a, self.b = self.b, self.a + self.b
        if self.a &gt; 100:
            raise StopIteration()
        return self.a

for n in Fib():
    print n
</code></pre>

<p><img src="media/14926766188460/14927569583236.jpg" alt=""/></p>

<h3 id="toc_7">__getitem__</h3>

<p>上述要表现得像list那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

class Fib(object):
    &quot;&quot;&quot;docstring for Fib&quot;&quot;&quot;

    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        print a

f = Fib()
f[0]
f[2]
f[4]

</code></pre>

<p><img src="media/14926766188460/14927581032895.jpg" alt=""/></p>

<p>不能简单的直接执行切片方法，Fib会报错。原因是<code>__getitem__()</code>传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Fib(object):
    &quot;&quot;&quot;docstring for Fib&quot;&quot;&quot;

    def __getitem__(self, n):
        if isinstance(n, int):
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            print a
        if isinstance(n, slice):
            start = n.start
            stop = n.stop
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            print L

f = Fib()
f[5]
f[1:5]
</code></pre>

<p><img src="media/14926766188460/14927591015675.jpg" alt=""/></p>

<h2 id="toc_8">__getattr__</h2>

<p>当定义好一个类后，若实例调用一个不存在的属性，则会报错，但是我们可以运用<code>__getattr__</code>动态返回一个属性。例如：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Student(object):

    def __init__(self):
        self.name = &#39;Michael&#39;

    def __getattr__(self, attr):
        if attr==&#39;score&#39;:
            return 99

s = Student()
print s.name
print s.score
print s.age
</code></pre>

<p><img src="media/14926766188460/14927598715799.jpg" alt=""/><br/>
只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在<code>__getattr__</code>中查找。</p>

<p>此外，注意到任意调用如<code>s.age</code>都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。</p>

<p><strong>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。例如动态的拼接api接口：</strong></p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Chain(object):

    def __init__(self, path=&#39;&#39;):
        self._path = path

    def __getattr__(self, path):
        return Chain(&#39;%s/%s&#39; % (self._path, path))

    def __str__(self):
        return self._path
print Chain().status.user.timeline.list
print Chain(&#39;LZH&#39;).status.user.timeline.list
</code></pre>

<p><img src="media/14926766188460/14927597036919.jpg" alt=""/></p>

<h2 id="toc_9">__call__</h2>

<p>任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。请看示例：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;
    def __init__(self, name):
        super(Students, self).__init__()
        self.name = name
    def __call__(self):
        print (&#39;My name is %s.&#39; % self.name)

s = Students(&#39;LZH&#39;)
s()
</code></pre>

<p><img src="media/14926766188460/14927611817291.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14926712777578.html">
                
                  <h1>类和实例</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">数据封装</a>
</li>
<li>
<a href="#toc_1">访问限制</a>
</li>
<li>
<a href="#toc_2">继承和多态</a>
</li>
<li>
<a href="#toc_3">获取对象信息</a>
<ul>
<li>
<a href="#toc_4">使用type()</a>
</li>
<li>
<a href="#toc_5">使用isinstance()</a>
</li>
<li>
<a href="#toc_6">使用dir()</a>
</li>
</ul>
</li>
</ul>


<p>在Python中，定义类是通过<code>class</code>关键字：</p>

<pre><code class="language-py">class Student(object):
    pass
</code></pre>

<p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，<strong>如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类</strong>。</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;

    def __init__(self, name, score):
        super(Students, self).__init__()
        self.name = name
        self.score = score
</code></pre>

<p>注意到<code>__init__</code>方法的第一个参数永远是self，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p>

<p>和普通的函数相比，在类中定义的函数只有一点不同，<font color=red>就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数和关键字参数。</font></p>

<h2 id="toc_0">数据封装</h2>

<p>面向对象编程的一个重要特点就是数据封装，创建实例需要给出<code>name</code>和<code>score</code>，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</p>

<p>例如下面增加一个成绩分类的方法：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;

    def __init__(self, name, score):
        super(Students, self).__init__()
        self.name = name
        self.score = score

    def print_score(self):
        print &#39;%s:%s&#39; % (self.name, self.score)

    def get_grade(self):
        if self.score &gt;= 90:
            print &#39;A&#39;
        elif self.score &gt;= 60:
            print &#39;B&#39;
        else:
            print &#39;C&#39;

bart = Students(&#39;Bart&#39;, 59)
lisa = Students(&#39;梁中豪&#39;, 100)
bart.print_score()
bart.get_grade()
lisa.print_score()
lisa.get_grade()
</code></pre>

<h2 id="toc_1">访问限制</h2>

<p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p>

<p>但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的<code>name</code>、<code>score</code>属性</p>

<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，<font color=red>在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，</font>所以，我们把Student类改一改：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;

    def __init__(self, name, score):
        super(Students, self).__init__()
        self.__name = name
        self.__score = score

    def print_score(self):
        print &#39;%s:%s&#39; % (self.__name, self.__score)

   
bart = Students(&#39;Bart&#39;, 59)
lisa = Students(&#39;梁中豪&#39;, 100)
bart.print_score()
lisa.__name
</code></pre>

<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.<code>__name</code>和实例变量<code>.__score</code>了：<br/>
<img src="media/14926712777578/14926727380387.jpg" alt=""/><br/>
如果又要允许外部代码修改score,可以给Student类增加set_score方法.这里跟java很像。不在过多叙述。</p>

<h2 id="toc_2">继承和多态</h2>

<p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>

<p>继承最大的好处是子类获得了父类的全部功能。由于<code>Animial</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为它的子类，什么事也没干，就自动拥有了<code>run()</code>方法，当然也可以对父类方法进行重写。</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class Animal(object):
    &quot;&quot;&quot;docstring for Animal&quot;&quot;&quot;

    def run(self):
        print &#39;Animal is running..&#39;


class Dog(Animal):
    pass


class Cat(Animal):
    &quot;&quot;&quot;docstring for Cat&quot;&quot;&quot;

    def run(self):
        print &#39;Cat is running..&#39;

dog = Dog()
dog.run()

cat = Cat()
cat.run()

</code></pre>

<p><img src="media/14926712777578/14926743181176.jpg" alt=""/></p>

<h2 id="toc_3">获取对象信息</h2>

<p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型？</p>

<h3 id="toc_4">使用type()</h3>

<p>基本类型都可以用<code>type()</code>判断：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

print type(123),type(&#39;str&#39;),type(None)
</code></pre>

<p><img src="media/14926712777578/14926750871663.jpg" alt=""/></p>

<p>Python把每种type类型都定义好了常量，放在types模块里，使用之前，需要先导入：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import types
print type(&#39;abc&#39;)==types.StringType
print type(u&#39;abc&#39;)==types.UnicodeType
print type([])==types.ListType
print type(str) == types.TypeType
</code></pre>

<p><img src="media/14926712777578/14926752976543.jpg" alt=""/><br/>
<strong>最后注意到有一种类型就叫TypeType，所有类型本身的类型就是TypeType.比如<code>int，str</code>等</strong></p>

<h3 id="toc_5">使用isinstance()</h3>

<p>我们使用<code>isinstance()</code>来判断class的类型，例如：</p>

<pre><code class="language-py">class Animals(object):
    &quot;&quot;&quot;docstring for Animals&quot;&quot;&quot;
    pass
class Cat(Animals):
    &quot;&quot;&quot;docstring for Cat&quot;&quot;&quot;
    pass
class Dog(Animals):
    &quot;&quot;&quot;docstring for Dog&quot;&quot;&quot;
    pass
a = Animals()
d = Dog()
h = Cat()
print isinstance(h, Cat),isinstance(d, Dog),isinstance(a, Animals)
</code></pre>

<p><img src="media/14926712777578/14926756201012.jpg" alt=""/></p>

<p>当然也可以用<code>isinstance()</code>来判断基本类型</p>

<h3 id="toc_6">使用dir()</h3>

<p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的<code>list</code>，比如，获得一个str对象的所有属性和方法：</p>

<pre><code class="language-py">&gt;&gt;&gt; dir(&#39;abc&#39;)
</code></pre>

<p><img src="media/14926712777578/14926758082813.jpg" alt=""/></p>

<p><strong>仅仅把属性和方法列出来是不够的，配合<code>getattr()、setattr()以及hasattr()</code>，我们可以直接操作一个对象的状态：</strong></p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

class Animals(object):
    &quot;&quot;&quot;docstring for Animals&quot;&quot;&quot;

    def __init__(self):
        self.x = 9

    def power(self):
        print self.x * self.x
obj = Animals()

print hasattr(obj, &#39;x&#39;)  # 有属性&#39;x&#39;吗？
print hasattr(obj, &#39;y&#39;)  # 有属性&#39;y&#39;吗？
print setattr(obj, &#39;y&#39;, 19)  # 设置一个属性&#39;y&#39;
print getattr(obj, &#39;y&#39;)  # 获取属性&#39;y&#39;
print obj.y
</code></pre>

<p><img src="media/14926712777578/14926764199501.jpg" alt=""/></p>

<p>也可以获得对象的方法：</p>

<pre><code class="language-py">fn = getattr(obj, &#39;power&#39;)
print fn,fn(),
</code></pre>

<p><img src="media/14926712777578/14926765852729.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14926690841704.html">
                
                  <h1>面向对象编程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>采用面向对象的程序设计思想来设计一个简单的学生成绩打印，我们首选思考的不是程序的执行流程，而是<code>Student</code>这种数据类型应该被视为一个对象，这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;

    def __init__(self, name, score):
        super(Students, self).__init__()
        self.name = name
        self.score = score

    def print_score(self):
        print &#39;%s:%s&#39; % (self.name, self.score)


bart = Students(&#39;Bart&#39;, 59)
lisa = Students(&#39;梁中豪&#39;, 100)
bart.print_score()
lisa.print_score()
</code></pre>

<p><img src="media/14926690841704/14926708025078.jpg" alt=""/></p>

<p><strong>面向对象三大特点：封装、继承、多态。</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14926579397626.html">
                
                  <h1>使用_future_</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Python的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。有些改动是不兼容旧版本的，也就是在当前版本运行正常的代码，到下一个版本运行就可能不正常了。</p>

<p>从Python 2.7到Python 3.x就有不兼容的一些改动，比如2.x里的字符串用<code>&#39;xxx&#39;</code>表示str，Unicode字符串用<code>u&#39;xxx&#39;</code>表示unicode，而在3.x中，所有字符串都被视为unicode，因此，写<code>u&#39;xxx&#39;和&#39;xxx&#39;</code>是完全一致的.还有在2.x中以<code>&#39;xxx&#39;</code>表示的str就必须写成<code>b&#39;xxx&#39;</code>，以此表示“二进制字符串”。</p>

<p><font color=red>Python提供了<code>__future__模块</code>，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。</font>举例说明如下：</p>

<p>为了适应Python 3.x的新的字符串的表示方法，在2.7版本的代码中，可以通过unicode_literals来使用Python 3.x的新的语法：</p>

<pre><code class="language-py"># still running on Python 2.7
# -*- coding: utf-8 -*-

from __future__ import unicode_literals

print &#39;\&#39;xxx\&#39; is unicode?&#39;, isinstance(&#39;xxx&#39;, unicode)
print &#39;u\&#39;xxx\&#39; is unicode?&#39;, isinstance(u&#39;xxx&#39;, unicode)
print &#39;\&#39;xxx\&#39; is str?&#39;, isinstance(&#39;xxx&#39;, str)
print &#39;b\&#39;xxx\&#39; is str?&#39;, isinstance(b&#39;xxx&#39;, str)
</code></pre>

<p><img src="media/14926579397626/14926584481460.jpg" alt=""/><br/>
注意到上面的代码仍然在Python 2.7下运行，但结果显示去掉前缀u的<code>&#39;a string&#39;</code>仍是一个unicode，而加上前缀b的<code>b&#39;a string&#39;</code>才变成了str</p>

<p>由于Python是由社区推动的开源并且免费的开发语言，不受商业公司控制，因此，<strong>Python的改进往往比较激进，不兼容的情况时有发生。Python为了确保你能顺利过渡到新版本，特别提供了__future__模块，让你在旧的版本中试验新版本的一些特性</strong>。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/20</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14925924499918.html">
                
                  <h1>使用第三方模块</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在Python中，安装第三方模块，是通过setuptools这个工具完成的。Python有两个封装了setuptools的包管理工具：<code>easy_install和pip</code>。<font color=red>目前官方推荐使用<code>pip</code>。</font></p>

<p>Mac和linux本身自带pip，不用安装，在win下需要安装。这里不再过多叙述。</p>

<p>这里试着安装一个第三方库：<strong>Python Imaging Library</strong>，这是Python下非常强大的处理图像的工具库。一般来说，第三方库都会在Python官方的<a href="http://pypi.python.org">http://pypi.python.org</a>网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Python Imaging Library的名称叫PIL，因此，安装Python Imaging Library的命令就是：</p>

<p><del>pip install PIL</del>（现在用pillow来代替PIL）</p>

<pre><code>sudo pip install Pillow
</code></pre>

<p>处理图片的方法为：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
from PIL import Image

im = Image.open(&#39;icon.png&#39;)
print im.format, im.size, im.mode

im.thumbnail((150,100))
im.save(&#39;thumb.jpg&#39;,&#39;JPEG&#39;)
</code></pre>

<p><img src="media/14925924499918/14926575371706.jpg" alt=""/><br/>
将原图<code>icon.png</code>:<br/>
<img src="media/14925924499918/icon.png" alt="icon"/></p>

<p>生成一个名为<code>thumb.jpg</code>的图片：<br/>
<img src="media/14925924499918/thumb.jpg" alt="thumb"/></p>

<blockquote>
<p>这两张图暂时没有看出明显的区别，需要深入研究。</p>
</blockquote>

<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p>

<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[&#39;&#39;, &#39;/Library/Python/2.7/site-packages/pip-8.1.1-py2.7.egg&#39;, 
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip&#39;,... ]
</code></pre>

<p>想要添加自己的搜索目录可以：</p>

<pre><code class="language-py">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append(&#39;/Users/michael/my_py_scripts&#39;)
</code></pre>

<p><font color=red>这种方法是在运行时修改，运行结束后失效。</font></p>

<p>第二种方法是设置环境变量<code>PYTHONPATH</code>这里不做详述。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/19</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_13.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_15.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>LZH007</h1>
                <div class="site-des">LZH的技术杂事小博客~</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="MAC%20OS.html"><strong>MAC OS</strong></a>
        
            <a href="Effective%20OC2.0.html"><strong>Effective OC2.0</strong></a>
        
            <a href="English%20Study.html"><strong>English Study</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html"><strong>统计学习方法</strong></a>
        
            <a href="Python%E7%BB%83%E4%B9%A0.html"><strong>Python练习</strong></a>
        
            <a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html"><strong>图像去雾技术</strong></a>
        
            <a href="iOS.html"><strong>iOS</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15049238737460.html">第四十一条 多用派发队列，少用同步锁</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15045739362959.html">第四十条 用块引用其所属对象时不要出现保留环</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15045090813380.html">第三十九条 用handler块降低代码分散程度</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15044922241087.html">第三十八条 为常用的块类型创建typedef</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15043212815193.html">第三十七条 理解“块”这一概念</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
