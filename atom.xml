<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2018-01-22T15:32:31+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[2017第八届蓝桥杯C/C++ B组省赛]]></title>
    <link href="https://lockxmonk.github.io/15196116405308.html"/>
    <updated>2018-02-26T10:20:40+08:00</updated>
    <id>https://lockxmonk.github.io/15196116405308.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">第一题 购物单</a>
</li>
<li>
<a href="#toc_1">第二题 等差素数列</a>
</li>
<li>
<a href="#toc_2">第三题 承压计算</a>
</li>
<li>
<a href="#toc_3">第四题  方格分割</a>
</li>
<li>
<a href="#toc_4">第六题 最大公共子串</a>
</li>
<li>
<a href="#toc_5">第七题 日期问题</a>
</li>
<li>
<a href="#toc_6">输入</a>
</li>
<li>
<a href="#toc_7">输出</a>
</li>
<li>
<a href="#toc_8">样例输入</a>
</li>
<li>
<a href="#toc_9">样例输出</a>
</li>
<li>
<a href="#toc_10">第八题 包子凑数</a>
</li>
<li>
<a href="#toc_11">第九题 分巧克力</a>
</li>
<li>
<a href="#toc_12">第十题 k倍区间</a>
</li>
<li>
<a href="#toc_13">输入</a>
</li>
<li>
<a href="#toc_14">输出</a>
</li>
</ul>


<h2 id="toc_0">第一题 购物单</h2>

<p>小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。</p>

<p>这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。<br/>
小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。<br/>
现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。</p>

<p>取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。<br/>
你的任务是计算出，小明最少需要取多少现金。</p>

<p>以下是让人头疼的购物单，为了保护隐私，物品名称被隐藏了</p>

<pre><code>--------------------
****     180.90       88折
****      10.25       65折
****      56.14        9折
****     104.65        9折
****     100.30       88折
****     297.15       半价
****      26.75       65折
****     130.62       半价
****     240.28       58折
****     270.62        8折
****     115.87       88折
****     247.34       95折
****      73.21        9折
****     101.00       半价
****      79.54       半价
****     278.44        7折
****     199.26       半价
****      12.97        9折
****     166.30       78折
****     125.50       58折
****      84.98        9折
****     113.35       68折
****     166.57       半价
****      42.56        9折
****      81.90       95折
****     131.78        8折
****     255.89       78折
****     109.17        9折
****     146.69       68折
****     139.33       65折
****     141.16       78折
****     154.74        8折
****      59.42        8折
****      85.44       68折
****     293.70       88折
****     261.79       65折
****      11.30       88折
****     268.27       58折
****     128.29       88折
****     251.03        8折
****     208.39       75折
****     128.88       75折
****      62.06        9折
****     225.87       75折
****      12.89       75折
****      34.28       75折
****      62.16       58折
****     129.12       半价
****     218.37       半价
****     289.69       8折
--------------------
</code></pre>

<p>需要说明的是，88折指的是按标价的88%计算，而8折是按80%计算，余者类推。<br/>
特别地，半价是按50%计算。</p>

<p>请提交小明要从取款机上提取的金额，单位是元。<br/>
答案是一个整数，类似4300的样子，结尾必然是00，不要填写任何多余的内容。</p>

<p>特别提醒：不许携带计算器入场，也不能打开手机。</p>

<p><strong>解答：</strong> 就是基本的运算。</p>

<pre><code class="language-c++">#include&lt;stdio.h&gt;
main()
{
    float a;
    a = 180.90*0.88+10.25*0.65+56.14*0.9+104.65*0.9+100.3*0.88+297.15*0.5+26.75*0.65+130.62*0.5 
    +240.28*0.58+270.62*0.8+115.87*0.88+247.34*0.95+73.21*0.9+101*0.5+79.54*0.5+278.44*0.7+199.26*0.5 
    +12.97*0.9+166.30*0.78+125.50*0.58+84.98*0.9+113.35*0.68+166.57*0.5+42.56*0.9+81.90*0.95 
    +131.78*0.8+255.89*0.78+109.17*0.9+146.69*0.68+139.33*0.65+141.16*0.78+154.74*0.8+59.42*0.8 
    +85.44*0.68+293.70*0.88+261.79*0.65+11.30*0.88+268.27*0.58+128.29*0.88+251.03*0.8+208.39*0.75 
    +128.88*0.75+62.06*0.9+225.87*0.75+12.89*0.75+34.28*0.75+62.16*0.58+129.12*0.5+218.37*0.5+289.69*0.8; 
    printf(&quot;%f&quot;,a);
} 
</code></pre>

<p><strong>算出来结果为5136.859375 取钱应为5200</strong></p>

<h2 id="toc_1">第二题 等差素数列</h2>

<p>2,3,5,7,11,13,....是素数序列。</p>

<p>类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。<br/>
上边的数列公差为30，长度为6。</p>

<p>2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。<br/>
这是数论领域一项惊人的成果！</p>

<p>有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：</p>

<p>长度为10的等差素数列，其公差最小值是多少？</p>

<p>注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。</p>

<p><strong>先用素数筛筛出素数，然后暴力</strong></p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;memory.h&gt;
#include &lt;iostream&gt;
using namespace std;
int p[100010];
int prim[100010];
int len=0;
void isp()
{
    //构造素数数列
    memset(p,0,sizeof(p));
    p[0]=1;p[1]=1;p[2]=0;
    for(int i=0;i&lt;10000;i++)
    {
        if(p[i])
            continue;
        for(int j=i;j*i&lt;10000;j++)
        {
            p[i*j]=1;
        }
        prim[len++]=i;
    }
    
}
int main()
{
    isp();
    for(int i=0;i&lt;len;i++)
    {
        int ss=prim[i];  //记录当前素数
        for(int c=1;c&lt;1000;c++)     //c为公差
        {
            int j;
            for(j=1;j&lt;10;j++)
            {
                if(p[ss+c*j])
                    break;
            }
            if(j&gt;=10)
            {
                cout&lt;&lt;c&lt;&lt;&#39; &#39;&lt;&lt;ss&lt;&lt;endl;
                return 0;
            }
        }
    }
}
</code></pre>

<p><strong>答案为210.</strong></p>

<h2 id="toc_2">第三题 承压计算</h2>

<p>X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。</p>

<p>每块金属原料的外形、尺寸完全一致，但重量不同。<br/>
金属材料被严格地堆放成金字塔形。</p>

<pre><code>                             7 
                            5 8 
                           7 8 8 
                          9 2 7 2 
                         8 1 4 9 1 
                        8 1 8 8 4 1 
                       7 9 6 1 4 5 4 
                      5 6 5 5 6 9 5 6 
                     5 5 4 7 9 3 5 5 1 
                    7 5 7 9 7 4 7 3 3 1 
                   4 6 4 5 5 8 8 3 2 4 3 
                  1 1 3 3 1 6 6 5 5 4 4 2 
                 9 9 9 2 1 9 1 9 2 9 5 7 9 
                4 3 3 7 7 9 3 6 1 3 8 8 3 7 
               3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 
              8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 
             8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 
            2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 
           7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 
          9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 
         5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 
        6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 
       2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 
      7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 
     1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 
    2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 
   7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 
  7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 
 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 
X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X 
</code></pre>

<p>其中的数字代表金属块的重量（计量单位较大）。<br/>
最下一层的X代表30台极高精度的电子秤。</p>

<p>假设每块原料的重量都十分精确地平均落在下方的两个金属块上，<br/>
最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。<br/>
电子秤的计量单位很小，所以显示的数字很大。</p>

<p>工作人员发现，其中读数最小的电子秤的示数为：2086458231</p>

<p>请你推算出：读数最大的电子秤的示数为多少？</p>

<p>注意：需要提交的是一个整数，不要填写任何多余的内容。</p>

<p><strong>只要把第i行的第j个平均分给第i+1行的第j个和第i+1行的第j+1个</strong></p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
using namespace std;
double num[35][35];
int main()
{
    for(int i=1;i&lt;=29;i++)
        for(int j=1;j&lt;=i;j++)
            cin&gt;&gt;num[i][j];
    for(int i=1;i&lt;=29;i++){
        for(int j=1;j&lt;=i;j++)
        {
            num[i+1][j]+=num[i][j]/2;
            num[i+1][j+1]+=num[i][j]/2;
        }
    }
    double maxn=-1;
    double minn=INT_MAX;
    for(int i=1;i&lt;=30;i++)
    {
        if(maxn&lt;num[30][i]) maxn=num[30][i];
        if(minn&gt;num[30][i]) minn=num[30][i];
    }
    printf(&quot;%lf&quot;,maxn*2086458231/minn);  //进行单位的的换算
}
</code></pre>

<h2 id="toc_3">第四题  方格分割</h2>

<p>6x6的方格，沿着格子的边线剪开成两部分。<br/>
要求这两部分的形状完全相同。</p>

<p>如图：p1.png, p2.png, p3.png 就是可行的分割法。</p>

<p>试计算：<br/>
包括这3种分法在内，一共有多少种不同的分割方法。<br/>
注意：旋转对称的属于同一种分割法。</p>

<p>请提交该整数，不要填写任何多余的内容或说明文字。<br/>
<img src="media/15196116405308/15196154889838.jpg" alt=""/><br/>
<strong>应该把边当成走廊，因为剪出的是中心对称，所以必定经过（3，3）<br/>
所以可以从（3，3）开始出发两个人以中心对称的方式出发，当走到边界的时候两个人走的路线就是剪开的线路<br/>
因为是中心对称，这样出来的答案应该除以4</strong></p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
using namespace std;
int visited[10][10];
int ans=0;
int dir[4][2]={0,1,1,0,0,-1,-1,0};
void dfs(int x,int y)
{
    if(x==0||y==0||x==6||y==6)
    {
        ans++;
        return ;
    }
    for(int i=0;i&lt;4;i++)
    {
        int nx=x+dir[i][0];
        int ny=y+dir[i][1];
        if(visited[nx][ny])
            continue;
        visited[nx][ny]=1;
        visited[6-nx][6-ny]=1;
        dfs(nx,ny);
        visited[nx][ny]=0;      //上次路线假设情况求取后 ，将路线标记置为0
        visited[6-nx][6-ny]=0;  //同上对称图形也将路线标记置为0
    }
}
int main()
{
    memset(visited,0,sizeof(visited));
    visited[3][3]=1;
    dfs(3,3);
    printf(&quot;%d %d\n&quot;,ans,ans/4);
}
</code></pre>

<h2 id="toc_4">第六题 最大公共子串</h2>

<p>最大公共子串长度问题就是：<br/>
求两个串的所有子串中能够匹配上的最大长度是多少。</p>

<p>比如：&quot;abcdkkk&quot; 和 &quot;baabcdadabc&quot;，<br/>
可以找到的最长的公共子串是&quot;abcd&quot;,所以最大公共子串长度为4。</p>

<p>下面的程序是采用矩阵法进行求解的，这对串的规模不大的情况还是比较有效的解法。</p>

<p>请分析该解法的思路，并补全划线部分缺失的代码。</p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define N 256
int f(const char* s1, const char* s2)
{
    int a[N][N];
    int len1 = strlen(s1);
    int len2 = strlen(s2);
    int i,j;

    memset(a,0,sizeof(int)*N*N);
    int max = 0;
    for(i=1; i&lt;=len1; i++){
        for(j=1; j&lt;=len2; j++){
            if(s1[i-1]==s2[j-1]) {
                a[i][j] = __________________________;  //填空
                if(a[i][j] &gt; max) max = a[i][j];
            }
        }
    }

    return max;
}

int main()
{
    printf(&quot;%d\n&quot;, f(&quot;abcdkkk&quot;, &quot;baabcdadabc&quot;));
    return 0;
}
</code></pre>

<p>基础dp，答案：a[i-1][j-1]+1</p>

<h2 id="toc_5">第七题 日期问题</h2>

<p>小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。  </p>

<p>比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。  </p>

<p>给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</p>

<h2 id="toc_6">输入</h2>

<p>一个日期，格式是&quot;AA/BB/CC&quot;。  (0 &lt;= A, B, C &lt;= 9)  </p>

<h2 id="toc_7">输出</h2>

<p>输出若干个不相同的日期，每个日期一行，格式是&quot;yyyy-MM-dd&quot;。多个日期按从早到晚排列。  </p>

<h2 id="toc_8">样例输入</h2>

<p>02/03/04  </p>

<h2 id="toc_9">样例输出</h2>

<p>2002-03-04<br/><br/>
2004-02-03<br/><br/>
2004-03-02  </p>

<p>资源约定：<br/>
峰值内存消耗（含虚拟机） &lt; 256M<br/>
CPU消耗  &lt; 1000ms</p>

<p>注意：<br/>
main函数需要返回0;<br/>
只使用ANSI C/ANSI C++ 标准;<br/>
不要调用依赖于编译环境或操作系统的特殊函数。<br/>
所有依赖的函数必须明确地在源文件中 #include <xxx><br/>
不能通过工程设置而省略常用头文件。</p>

<p>提交程序时，注意选择所期望的语言类型和编译器类型。</p>

<p>只有年/月/日的，月/日/年的，日/月/年三种情况</p>

<pre><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
int time[150][15][35];
bool pd(int n,int y,int r)
{
    int rn=0;
    if(n%400==0||(n%100!=0&amp;&amp;n%4==0))
        rn=1;
    if(n==1||n==3||n==5||n==7||n==8||n==10||n==12)
        if(r&gt;31) return 0;
    if(n==4||n==6||n==9||n==11)
        if(r&gt;30) return 0;
    if(n==2)
        if(r&gt;28+rn) return 0;
    return 1;
}

int main()
{
    int a,b,c;
    //memset(time,0,sizeof(time));
    scanf(&quot;%d/%d/%d&quot;,&amp;a,&amp;b,&amp;c);
    if(a&gt;=60&amp;&amp;b&lt;=12&amp;&amp;c&lt;=31)
        time[a-60][b][c]=1;
    if(a&lt;60&amp;&amp;b&lt;=12&amp;&amp;c&lt;=31)
        time[a+40][b][c]=1;
    
    if(c&gt;=60&amp;&amp;a&lt;=12&amp;&amp;b&lt;=31)
        time[c-60][a][b]=1;
    if(c&lt;60&amp;&amp;a&lt;=12&amp;&amp;c&lt;=31)
        time[c+40][a][b]=1;
    
    if(c&gt;=60&amp;&amp;b&lt;=12&amp;&amp;a&lt;=31)
        time[c-60][b][a]=1;
    if(c&lt;60&amp;&amp;b&lt;=12&amp;&amp;a&lt;=31)
        time[c+40][b][a]=1;
    for(int i=0;i&lt;=100;i++)
        for(int j=1;j&lt;=12;j++)
            for(int k=1;k&lt;=31;k++)
                if(time[i][j][k]==1)
                {
                    if(pd(i,j,k))
                    {
                        
                        printf(&quot;%d-&quot;,i+1960);
                        if(j&lt;9)
                            printf(&quot;0%d-&quot;,j);
                        else
                            printf(&quot;%d-&quot;,j);
                        if(k&lt;9)
                            printf(&quot;0%d\n&quot;,k);
                        else
                            printf(&quot;%d\n&quot;,k);
                    }
                }
}

</code></pre>

<h2 id="toc_10">第八题 包子凑数</h2>

<p>小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。</p>

<p>每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。</p>

<p>当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。</p>

<p>小明想知道一共有多少种数目是包子大叔凑不出来的。</p>

<p><strong>这题可以使用欧几里得拓展算法：<br/>
对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然<br/>
存在整数对 x，y ，使得 gcd（a，b）=ax+by。</strong></p>

<p>简单的说就是当所有的输入的最大公约数都为1时，为有限个，否则为无限个。</p>

<pre><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

bool judge(int x,int y)
{
    int t;
    while(y&gt;0)
    {
        t=x%y;
        x=y;
        y=t;
    }
    if(x==1)
        return true;
    return false;
}

int a[110],n;
bool dp[10010];
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0; i&lt;n; i++)
        scanf(&quot;%d&quot;,&amp;a[i]);
    int  flag=0;
    for(int i=0;i&lt;n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            if(judge(a[i],a[j]))
            {
                flag=1;
                break;
            }
        }
        if(flag==1)
            break;
    }
    if(flag!=1)
    {
        printf(&quot;INF\n&quot;);
        return 0;
    }
    dp[0]=1;
    for(int i=0; i&lt;n; i++)
    {
        for(int j=0; j+a[i]&lt;10000; j++)
            if(dp[j])
                dp[j+a[i]]=1;
    }
    int ans=0;
    for(int i=0; i&lt;10000; i++)
    {
        if(dp[i]!=1)
            ans++;
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}

</code></pre>

<h2 id="toc_11">第九题 分巧克力</h2>

<p>儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。<br/>
小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足：<br/>
    1. 形状是正方形，边长是整数<br/><br/>
    2. 大小相同  </p>

<p>例如一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。</p>

<p>当然小朋友们都希望得到的巧克力尽可能大，你能帮小Hi计算出最大的边长是多少么？</p>

<p>输入<br/>
第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)<br/><br/>
以下N行每行包含两个整数Hi和Wi。(1 &lt;= Hi, Wi &lt;= 100000) <br/>
输入保证每位小朋友至少能获得一块1x1的巧克力。   </p>

<p>输出<br/>
输出切出的正方形巧克力最大可能的边长。</p>

<p>样例输入：<br/>
2 10<br/><br/>
6 5<br/><br/>
5 6  </p>

<p>样例输出：<br/>
2</p>

<p>资源约定：<br/>
峰值内存消耗（含虚拟机） &lt; 256M<br/>
CPU消耗  &lt; 1000ms</p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#define N 100005
using namespace std;
int n,k;
struct cho
{
    int h;
    int w;
};
cho c[N];
bool judge(int len)
{
    int sum=0;
    for(int i=0;i&lt;len;i++)
    {
        sum+=(c[i].h/len)*(c[i].w/len);
        if(sum&gt;=k)
            return 1;
    }
    return 0;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
    int low=1;
    int high=100000;
    int mid;
    for(int i=0; i&lt;n; i++)
        scanf(&quot;%d%d&quot;,&amp;c[i].h,&amp;c[i].w);
    while(low&lt;high-1)
    {
        mid=(low+high)/2;
        if(!judge(mid))
            high=mid;
        else
            low=mid;
    }
    printf(&quot;%d\n&quot;,mid-1);
    return 0;
}

</code></pre>

<h2 id="toc_12">第十题 k倍区间</h2>

<p>给定一个长度为N的数列，A1, A2, ... AN，如果其中一段连续的子序列Ai, Ai+1, ... Aj(i &lt;= j)之和是K的倍数，我们就称这个区间[i, j]是K倍区间。  </p>

<p>你能求出数列中总共有多少个K倍区间吗？  </p>

<h2 id="toc_13">输入</h2>

<p>第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)<br/><br/>
以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100000)  </p>

<h2 id="toc_14">输出</h2>

<p>输出一个整数，代表K倍区间的数目。  </p>

<p>例如，<br/>
输入：<br/>
5 2<br/>
1<br/><br/>
2<br/><br/>
3<br/><br/>
4<br/><br/>
5  </p>

<p>程序应该输出：<br/>
6</p>

<p>资源约定：<br/>
峰值内存消耗（含虚拟机） &lt; 256M<br/>
CPU消耗  &lt; 2000ms</p>

<p><strong>可通过滑动窗口的方法来解，提前对数据进行处理可缩短执行时间</strong></p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
using namespace std;
int a[100010];
long long dp[100010];
int main()
{
    int n,k,i,j;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
    dp[0]=0;
    for(i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
        dp[i]=dp[i-1]+a[i];     //累加之前的数字
    }
    int ans=0;
    for(i=1;i&lt;=n;i++)
    {
        for(j=0;j&lt;=n-i;j++)
        {
            if((dp[j+i]-dp[j])%k==0)    //通过调整i，j来循环判断，这里i表示区间的长度，j为向右滑动步数。
                ans++;
        }
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Word in Dictionary through Deleting]]></title>
    <link href="https://lockxmonk.github.io/15166061069994.html"/>
    <updated>2018-01-22T15:28:26+08:00</updated>
    <id>https://lockxmonk.github.io/15166061069994.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15166061069994/15166062200635.jpg" alt=""/></p>

<p><strong>比较字符的大小时，若字符串a的首字符大于b的首字符则a比较大，不对后续字符进行判断。</strong></p>

<pre><code class="language-c++">class Solution {
public:
    string findLongestWord(string s, vector&lt;string&gt;&amp; d) {
            string ans;
            for (int i = 0; i &lt; d.size(); i++) {
                int pi = 0, pj = 0;
                for (; pi &lt; s.size() &amp;&amp; pj &lt; d[i].size(); pi++) {
                    pj += s[pi] == d[i][pj];
                }
                if (pj == d[i].size() &amp;&amp; (ans.size() &lt; d[i].size() || (ans.size() == d[i].size() &amp;&amp; ans &gt; d[i])))
                    ans = d[i];
            }
            return ans;
        }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Word in Dictionary]]></title>
    <link href="https://lockxmonk.github.io/15165851014842.html"/>
    <updated>2018-01-22T09:38:21+08:00</updated>
    <id>https://lockxmonk.github.io/15165851014842.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15165851014842/15165851083732.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string longestWord(vector&lt;string&gt;&amp; words) {
        sort(words.begin(), words.end());  //对字符串排好序，按照字符的ascll编码，匹配字典的排序
        unordered_set&lt;string&gt; set;
        string res = &quot;&quot;;
        for (int i = 0 ; i&lt;words.size(); i++) {
            if (words[i].size()==1||set.count(words[i].substr(0,words[i].size()-1))) {
                res = words[i].size()&gt;res.size() ? words[i]:res;
                set.insert(words[i]);
            }
        }

        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maximum Length of Repeated Subarray]]></title>
    <link href="https://lockxmonk.github.io/15164332920131.html"/>
    <updated>2018-01-20T15:28:12+08:00</updated>
    <id>https://lockxmonk.github.io/15164332920131.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15164332920131/15164336142430.jpg" alt=""/></p>

<p>运用了动态规划，从A的尾部，来遍历B。</p>

<pre><code class="language-c++">class Solution {
public:
    int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {
        int m = A.size(), n = B.size();
        if (!m||!n) {
            return 0;
        }
        vector&lt;int&gt; dp(n+1); //要比B的长度多一位，在下面j=为n-1时需要获取dp[j+1]的值
        int res = 0;
        for (int i = m-1; i&gt;=0; i--) {
            for (int j = 0; j&lt;n; j++) {
                dp[j] = A[i]==B[j] ? dp[j+1]+1 : 0;
                res = max(res, dp[j]);
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Largest Number At Least Twice of Others]]></title>
    <link href="https://lockxmonk.github.io/15164320874129.html"/>
    <updated>2018-01-20T15:08:07+08:00</updated>
    <id>https://lockxmonk.github.io/15164320874129.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15164320874129/15164320973707.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int dominantIndex(vector&lt;int&gt;&amp; nums) {
        int max = 0, tmp = 0,index = 0;
        for (int i = 0; i&lt;nums.size(); i++) {
            if(nums[i]&gt;=max) {
                tmp = max;
                max = nums[i];
                index = i;
            }else if (nums[i]&gt;tmp){
                tmp = nums[i];
            }
            if (i==nums.size()-1 &amp;&amp; tmp*2&lt;=max) return index;
        }
        return -1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reverse Linked List]]></title>
    <link href="https://lockxmonk.github.io/15163372118775.html"/>
    <updated>2018-01-19T12:46:51+08:00</updated>
    <id>https://lockxmonk.github.io/15163372118775.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15163372118775/15163372241677.jpg" alt=""/></p>

<p>迭代法:</p>

<pre><code class="language-c++">class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = NULL;
        while (head) {
            ListNode* next = head -&gt; next;
            head -&gt; next = pre;
            pre = head;
            head = next;
        } 
        return pre;
    }
};
</code></pre>

<p>递归法：</p>

<pre><code class="language-objc">class Solution {
public:   
    ListNode* reverseList(ListNode* head) {
        if (!head || !(head -&gt; next)) return head;
        ListNode* node = reverseList(head -&gt; next);
        head -&gt; next -&gt; next = head;
        head -&gt; next = NULL;
        return node; 
    }
}; 
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Missing Positive]]></title>
    <link href="https://lockxmonk.github.io/15162636130743.html"/>
    <updated>2018-01-18T16:20:13+08:00</updated>
    <id>https://lockxmonk.github.io/15162636130743.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162636130743/15162636149442.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; map;
        int min = INT_MAX, max = 0, res = 1;
        for (int i = 0; i&lt;nums.size(); i++) {
            if (nums[i]&lt;=min&amp;&amp;nums[i]&gt;=0) {
                min = nums[i];
            }else if (nums[i]&lt;0) min = 0;
            if (nums[i]&gt;=max) max = nums[i];
            map[nums[i]]++;
        }
        for (int j=min; j&lt;=max; j++) {
            if (j==0) continue;
            if (min&gt;=2) {
                return 1;
            }
            if (map[j]==0) {
                res = j;
                break;
            }
            if (j==max) {
                res = max+1;
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find the Duplicate Number]]></title>
    <link href="https://lockxmonk.github.io/15162583169716.html"/>
    <updated>2018-01-18T14:51:56+08:00</updated>
    <id>https://lockxmonk.github.io/15162583169716.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162583169716/15162583183298.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; map;
        int res = 0;
        for (int i = 0; i&lt;nums.size(); i++) {
            if (map[nums[i]]==0) {
                map[nums[i]]++;
            }else{
                res = nums[i];
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set Mismatch]]></title>
    <link href="https://lockxmonk.github.io/15162440984880.html"/>
    <updated>2018-01-18T10:54:58+08:00</updated>
    <id>https://lockxmonk.github.io/15162440984880.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162440984880/15162441100081.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        vector&lt;int&gt; res;
        vector&lt;int&gt; a(len+1);   //因为数组从0开始，所以除去0，在后面加上1位

        for (int i = 0; i&lt;len; i++) {
            if (a[nums[i]]==0) {
                a[nums[i]]+=1;
            }else{
                res.push_back(nums[i]);
            }
        }

        for (int j = 1; j&lt;=len; j++) {
            if (a[j]==0) {
                res.push_back(j);
            }
        }

        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find Anagram Mappings]]></title>
    <link href="https://lockxmonk.github.io/15162401864030.html"/>
    <updated>2018-01-18T09:49:46+08:00</updated>
    <id>https://lockxmonk.github.io/15162401864030.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162401864030/15162401885331.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; anagramMappings(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {
        unordered_map&lt;int, int&gt; map;
        vector&lt;int&gt; res;
        for (int i = 0; i&lt;B.size(); i++) {
            map[B[i]]=i;
        }
        for (int j = 0; j&lt;A.size(); j++) {
            res.push_back(map[A[j]]);
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Length of Last Word]]></title>
    <link href="https://lockxmonk.github.io/15162389890253.html"/>
    <updated>2018-01-18T09:29:49+08:00</updated>
    <id>https://lockxmonk.github.io/15162389890253.html</id>
    <content type="html"><![CDATA[
<pre><code>![](media/15162389890253/15162389958774.jpg)
</code></pre>

<pre><code class="language-c++">class Solution {
public:
    int lengthOfLastWord(string s) {
        int len = s.size();
        int cout = 0;
        for (int i=len-1; i&gt;=0; i--) {
            if(cout&gt;0&amp;&amp;s[i]==&#39; &#39;) break;

            if (s[i]==&#39; &#39;) {
                continue;
            }else{
                cout++;
            }

        }
        return cout;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find matching parenthesis]]></title>
    <link href="https://lockxmonk.github.io/15155525710565.html"/>
    <updated>2018-01-10T10:49:31+08:00</updated>
    <id>https://lockxmonk.github.io/15155525710565.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15155525710565/15155525754064.jpg" alt=""/><br/>
<img src="media/15155525710565/15155525919147.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

int findParenMatch(NSString *s, int n) {
    int res = -1;
    NSString *tmp = [s substringWithRange:NSMakeRange(n, 1)];
    if ([tmp isEqualToString:@&quot;(&quot;]) {
        int logF = 0;
        for (int i = n+1; i&lt;s.length; i++) {
            NSString *tmpStrF = [s substringWithRange:NSMakeRange(i, 1)];
            if ([tmpStrF isEqualToString:@&quot;(&quot;]) logF++;
            if ([tmpStrF isEqualToString:@&quot;)&quot;]) {
                logF--;
                if (logF&lt;0) {
                    res = i;
                    break;
                }
            }
        }
    }else if ([tmp isEqualToString:@&quot;)&quot;]){
        int logB = 0;
        for (int i = n-1; i&gt;=0; i--) {
            NSString *tmpStrB = [s substringWithRange:NSMakeRange(i, 1)];
            if ([tmpStrB isEqualToString:@&quot;)&quot;]) logB++;
            if ([tmpStrB isEqualToString:@&quot;(&quot;]) {
                logB--;
                if (logB&lt;0) {
                    res = i;
                    break;
                }
            }
        }
    }
    return res;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVO自己的理解]]></title>
    <link href="https://lockxmonk.github.io/15153763176511.html"/>
    <updated>2018-01-08T09:51:57+08:00</updated>
    <id>https://lockxmonk.github.io/15153763176511.html</id>
    <content type="html"><![CDATA[
<ol>
<li>KVO利用runtime，生成了一个对象的子类，并生成子类对象替换原来对象的isa指针，重写了set方法。</li>
<li>KVO是基于KVC的，可以明显的发现在改变容器的时候，通过KVC改变改变容器中的值或者使用set方法时，会触发KVO通知函数，而简单的使用addObject：方法时却没有触发，这是因为KVO只响应set方法。<font color=red>可以说kvc是kvo的入口</font></li>
<li>直接使用KVO在项目中不是很好用，代码结构比较松散，需要自己封装或使用其它三方框架。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Where my anagrams at?]]></title>
    <link href="https://lockxmonk.github.io/15152183997863.html"/>
    <updated>2018-01-06T13:59:59+08:00</updated>
    <id>https://lockxmonk.github.io/15152183997863.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15152183997863/15152184280248.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *anagrams(NSString *s, NSArray *a) {
    NSMapTable *map = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableStrongMemory];
    for (int i = 0; i&lt;[s length]; i++) {
        NSString *str = [s substringWithRange:NSMakeRange(i, 1)];
        if ([map objectForKey:str]) {
            [map setObject:@([[map objectForKey:str] intValue]+1) forKey:str];
        }else{
            [map setObject:@(1) forKey:str];
        }
    }
    NSMutableArray *res = a.mutableCopy;
    for (NSString *ele in a) {
        if(ele.length!=s.length){
            [res removeObject:ele];
            continue;
        }
        NSMapTable *tmp = [map copy];
        for (int j=0; j&lt;[ele length]; j++) {
            NSString *tmpStr = [ele substringWithRange:NSMakeRange(j, 1)];
            if ([tmp objectForKey:tmpStr]) {
                int log =[[tmp objectForKey:tmpStr] intValue]-1;
                if (log&lt;0){
                    [res removeObject:ele];
                    break;
                }
                [tmp setObject:@(log) forKey:tmpStr];
            }else{
                [res removeObject:ele];
                break;
            }
        }
    }
    return res;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perimeter of squares in a rectangle]]></title>
    <link href="https://lockxmonk.github.io/15152039082618.html"/>
    <updated>2018-01-06T09:58:28+08:00</updated>
    <id>https://lockxmonk.github.io/15152039082618.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15152039082618/15152039109281.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

unsigned long long perimeter(int n) {
    NSMutableArray *numQu = @[@0,@1].mutableCopy;
    unsigned long long n0 = 0,n1=1;
    for (int i = 2; i&lt;=n+1; i++) {
        unsigned long long sum = n0+n1;
        n0 = n1;
        n1 = sum;
        [numQu addObject:@(sum)];
    }
    unsigned long long tol = 0;
    for (NSNumber* ele in numQu) {
        tol+=[ele unsignedLongLongValue];
    }
    return tol*4;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking遇到的问题]]></title>
    <link href="https://lockxmonk.github.io/15151211562254.html"/>
    <updated>2018-01-05T10:59:16+08:00</updated>
    <id>https://lockxmonk.github.io/15151211562254.html</id>
    <content type="html"><![CDATA[
<p>由于<code>AFNetworking</code>运用了官方<code>NSURLSession</code>所以其中有一些坑</p>

<h2 id="toc_0">1.苹果运用NSJSONSerialization解析，出现数字类型精度问题</h2>

<p>当服务器给我传回来一个<code>3.0</code>的数字类型时，在安卓端是没有问题的，但是在iOS这里会出现<code>2.99999</code>这样的问题。</p>

<p><font color=red><strong>出现这个问题的原因是：苹果在json解析时，默认为双精度的double类型。</strong></font></p>

<pre><code>我们相处的解决方案有两种：
1. 跟后台协商将数字型的值改为`字符型`
2. 使用第三方的json解析。
</code></pre>

<p>最后我们使用的是第一种方法，因为第二种势必要修改了AFNetwork的源码，开发与维护成本相比较来说要大。</p>

<h2 id="toc_1">2.json解析失败</h2>

<p>由于AF默认的解析方式为<code>0</code>（返回的对象是不可变的，<code>NSDictionary</code>或<code>NSArray</code>）：<br/>
<img src="media/15151211562254/15151222443779.jpg" alt=""/></p>

<p>我们来看一下都有什么选项：<br/>
<img src="media/15151211562254/15151222806031.jpg" alt=""/></p>

<p>所以当我们服务器返回的json数据是<strong>碎片化</strong>的（最外层既不是<code>NSArray</code>也不是<code>NSDictionary</code>），那么解析的时候就会出错了。</p>

<p>解决方法是：</p>

<p><img src="media/15151211562254/15151327758647.jpg" alt=""/><br/>
在0后添加<code>|</code>字符，增加这种情况，允许碎片化数据。</p>

<h2 id="toc_2">3. 请求后response的状态码范围问题</h2>

<p>正常项目中正常请求成功会返回200，但是服务器若是给你返回了500（我不知道后台为啥会返回这个码），问题就出现了：</p>

<p>这是由于下面的原因：<br/>
<img src="media/15151211562254/15151343155944.jpg" alt=""/><br/>
会发现上图中可接受状态码的范围是200-300；</p>

<p>具体解决方法就不说了。。。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1's, 0's and wildcards]]></title>
    <link href="https://lockxmonk.github.io/15145180239158.html"/>
    <updated>2017-12-29T11:27:03+08:00</updated>
    <id>https://lockxmonk.github.io/15145180239158.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15145180239158/15145180364703.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *changeTo(NSMutableArray*log, NSMutableArray*res){
    if (log.count&gt;0) {
        NSRange loc = {[[log lastObject] integerValue],1};
        NSMutableArray *cop = res.mutableCopy;
        for (NSString *tmp in res) {
            [cop addObject:[tmp stringByReplacingCharactersInRange:loc withString:@&quot;0&quot;]];
            [cop addObject:[tmp stringByReplacingCharactersInRange:loc withString:@&quot;1&quot;]];
            [cop removeObject:tmp];
        }
        [log removeLastObject];
        return changeTo(log, cop);
    }else{
        return res;
    }
}

NSArray *possibilities(NSString *s) {
    NSMutableArray *log = @[].mutableCopy;
    NSMutableArray *res = @[].mutableCopy;
    for (int i = 0; i&lt;s.length; i++) {
        if ([s characterAtIndex:i]==&#39;?&#39;) {
            [log addObject:@(i)];
        }
    }
    [res addObject:s];

    NSArray *tol = changeTo(log , res);
    
    return tol;
}
</code></pre>

<p>简化版：</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *possibilities(NSString *s) {
  // NSLog(@&quot;User `possibilities` accidentally invoked!\n&quot;);
  if ([s rangeOfString: @&quot;?&quot;].length == 0) return @[s];
  NSString *r = [s stringByReplacingOccurrencesOfString: @&quot;?&quot; withString: @&quot;0&quot; options: 0 range: [s rangeOfString: @&quot;?&quot;]], *t = [s stringByReplacingOccurrencesOfString: @&quot;?&quot; withString: @&quot;1&quot; options: 0 range: [s rangeOfString: @&quot;?&quot;]];
  return [possibilities(r) arrayByAddingObjectsFromArray: possibilities(t)];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Pig Latin]]></title>
    <link href="https://lockxmonk.github.io/15143494387976.html"/>
    <updated>2017-12-27T12:37:18+08:00</updated>
    <id>https://lockxmonk.github.io/15143494387976.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15143494387976/15143494406501.jpg" alt=""/></p>

<p>一开始的复杂版:</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSString *pigIt(NSString *s) {
    NSMutableArray *str = [s componentsSeparatedByString:@&quot; &quot;].mutableCopy;
    NSMutableString *res = @&quot;&quot;.mutableCopy;
    for (NSString *tmp in str) {
        unichar c = [tmp characterAtIndex:0];
        if ((c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)) {
            NSMutableString *change = tmp.mutableCopy;
            [change appendFormat:@&quot;%c&quot;,c];
            if ([tmp isEqualToString:[str lastObject]]) {
                [change appendString:@&quot;ay&quot;];
            }else{
                [change appendString:@&quot;ay &quot;];
            }
            [res appendString:[change substringFromIndex:1]];
        }else{
            [res appendFormat:@&quot;%c&quot;,c];
        }
    }
    return res;
}
</code></pre>

<p>简化版</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSString *pigIt(NSString *s) {
  NSMutableArray *result = [s componentsSeparatedByString: @&quot; &quot;];
  for (size_t i = 0; i &lt; [result count]; i++) result[i] = [[[result[i] substringFromIndex: 1] stringByAppendingString: [result[i] substringToIndex: 1]] stringByAppendingString: @&quot;ay&quot;];
  return [result componentsJoinedByString: @&quot; &quot;];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sum without highest and lowest number]]></title>
    <link href="https://lockxmonk.github.io/15143439533653.html"/>
    <updated>2017-12-27T11:05:53+08:00</updated>
    <id>https://lockxmonk.github.io/15143439533653.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15143439533653/15143439550035.jpg" alt=""/></p>

<pre><code class="language-objc">int sum(int* numbers, int numbersCount)
{
    if(numbersCount&lt;=1) return 0;
    int min = INT_MAX;
    int max = INT_MIN;
    int sum = 0;
    for (int i = 0; i&lt;numbersCount; i++)
    {
        if(numbers[i]&gt;max) max = numbers[i];
        if(numbers[i]&lt;min) min = numbers[i];
        sum+= numbers[i];
    }
    return sum-min-max;
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find the missing term in an Arithmetic Progression]]></title>
    <link href="https://lockxmonk.github.io/15142765984953.html"/>
    <updated>2017-12-26T16:23:18+08:00</updated>
    <id>https://lockxmonk.github.io/15142765984953.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15142765984953/15142766000094.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSNumber *findMissing(NSArray *list) {
    int len = [list count];
    int n = len+1;
    int d1 = [list[1] intValue]-[list[0] intValue];
    int d2 = [list[len-1] intValue]-[list[len-2] intValue];
    int d = 0;
    if (d1&lt;0) {
        d = d1&gt;d2?d1:d2;
    }else{
        d = d1&lt;d2?d1:d2;
    }
    if (n == 3) {
        return @(([[list firstObject] intValue]+[[list lastObject] intValue])/2);
    }
    int num = [[list firstObject] intValue];
    for (int i = 0;i&lt;len;i++) {
        if ([list[i] intValue]!=num) {
            return @(num);
        }
        num+=d;
    }
    
    return @(0);
}
</code></pre>

]]></content>
  </entry>
  
</feed>
