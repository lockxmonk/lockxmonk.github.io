<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2017-05-06T10:24:52+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[常用内建模块]]></title>
    <link href="https://lockxmonk.github.io/14945736764798.html"/>
    <updated>2017-05-12T15:21:16+08:00</updated>
    <id>https://lockxmonk.github.io/14945736764798.html</id>
    <content type="html"><![CDATA[
<p>Python中有很多內建模块可以直接使用，无需额外安装。</p>

<h2 id="toc_0">collection</h2>

<p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p>

<h3 id="toc_1">namedtuple</h3>

<p>我们知道<code>tuple</code>可以表示不变集合，例如，一个点的二维坐标就可以表示成：</p>

<pre><code>p = (1,2)
</code></pre>

<p>但是，看到<code>(1, 2)</code>，很难看出这个<code>tuple</code>是用来表示一个坐标的。</p>

<p>定义一个<code>class</code>又小题大做了，这时，<code>namedtuple</code>就派上了用场：</p>

<pre><code class="language-py">from collections import namedtuple
Point = namedtuple(&#39;Point&#39;,[&#39;x&#39;,&#39;y&#39;])
p = Point(1,2)
print p.x , p.y
</code></pre>

<p><img src="media/14945736764798/14945744048083.jpg" alt=""/><br/>
<code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p>

<p>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。</p>

<p>可以验证创建的<code>Point</code>对象是<code>tuple</code>的一种子类：</p>

<pre><code class="language-py">print p.x , p.y ,isinstance(p, tuple),isinstance(p, Point)
</code></pre>

<p><img src="media/14945736764798/14945746594923.jpg" alt=""/></p>

<p>类似的，如果要用坐标和半径表示一个圆，也可以用<code>namedtuple</code>定义：</p>

<pre><code class="language-py"># namedtuple(&#39;名称&#39;, [属性list]):
Circle = namedtuple(&#39;Circle&#39;, [&#39;x&#39;, &#39;y&#39;, &#39;r&#39;])
</code></pre>

<h3 id="toc_2">deque</h3>

<p>使用<code>list</code>存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为<code>list</code>是线性存储，数据量大的时候，插入和删除效率很低。</p>

<p><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：</p>

<pre><code class="language-py">from collections import deque
q = deque([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])
q.append(&#39;x&#39;)
q.appendleft(&#39;y&#39;)
print q
</code></pre>

<p><img src="media/14945736764798/14945755049453.jpg" alt=""/></p>

<p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>

<h3 id="toc_3">defaultdict</h3>

<p>使用<code>dict</code>时，如果引用的Key不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

from collections import defaultdict
dd = defaultdict(lambda: &#39;N/A&#39;)
dd[&#39;key1&#39;] = &#39;abc&#39;
print dd[&#39;key1&#39;], dd[&#39;key2&#39;]    #key1存在，key2不存在

</code></pre>

<p><img src="media/14945736764798/14945759067274.jpg" alt=""/><br/>
注意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。</p>

<p>除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>

<h3 id="toc_4">OrderedDict</h3>

<p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定<code>Key</code>的顺序。</p>

<p>如果要保持Key的顺序，可以用<code>OrderedDict</code>：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

from collections import OrderedDict
d = dict([(&#39;a&#39;,1),(&#39;b&#39;,2),(&#39;c&#39;,3)])
print d    # dict的Key是无序的
od = OrderedDict([(&#39;a&#39;,1),(&#39;b&#39;,2),(&#39;c&#39;,3)])
print od   #这个是有序的

</code></pre>

<p><img src="media/14945736764798/14945761816386.jpg" alt=""/></p>

<p><font color=red>注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序：</font></p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

from collections import OrderedDict
od = OrderedDict()
od[&#39;z&#39;] = 1
od[&#39;y&#39;] = 2
od[&#39;x&#39;] = 3

print od
</code></pre>

<p><img src="media/14945736764798/14945763021698.jpg" alt=""/></p>

<p><code>OrderedDict</code>可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

from collections import OrderedDict

class LastUpdatedOrderedDict(OrderedDict):

    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity

    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey &gt;= self._capacity:
            last = self.popitem(last=False)
            print &#39;remove:&#39;, last
        if containsKey:
            del self[key]
            print &#39;set:&#39;, (key, value)
        else:
            print &#39;add:&#39;, (key, value)
        OrderedDict.__setitem__(self, key, value)
od = LastUpdatedOrderedDict(3)
od[&#39;z&#39;] = 1
od[&#39;w&#39;] = 2
od[&#39;a&#39;] = 3
od[&#39;q&#39;] = 4
print od  
</code></pre>

<p><img src="media/14945736764798/14945770697335.jpg" alt=""/></p>

<h3 id="toc_5">Counter</h3>

<p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
from collections import Counter

c = Counter()
for ch in &#39;Programming&#39;:
    c[ch] = c[ch] + 1

print c

</code></pre>

<p><img src="media/14945736764798/14945772600780.jpg" alt=""/></p>

<h1 id="toc_6">小结</h1>

<p><code>collections</code>模块提供了一些有用的集合类，可以根据需要选用。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CNN卷积神经网络]]></title>
    <link href="https://lockxmonk.github.io/14940530686573.html"/>
    <updated>2017-05-06T14:44:28+08:00</updated>
    <id>https://lockxmonk.github.io/14940530686573.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">简介</h2>

<p>卷积神经网络是近年发展起来，并引起广泛重视的一种高效识别方法。20世纪60年代，Hubel和Wiesel在研究猫脑皮层中用于局部敏感和方向选择的神经元时发现其独特的网络结构可以有效地降低反馈神经网络的复杂性，继而提出了卷积神经网络（Convolutional Neural Networks-简称CNN）。现在，CNN已经成为众多科学领域的研究热点之一，特别是在模式分类领域，<mark>由于该网络避免了对图像的复杂前期预处理，可以直接输入原始图像，因而得到了更为广泛的应用</mark>。</p>

<p>一般地，CNN的基本结构包括两层：</p>

<ol>
<li><p>其一为<strong>特征提取层</strong>：每个神经元的输入与前一层的局部接受域相连，并提取该局部的特征。一旦该局部特征被提取后，它与其它特征间的位置关系也随之确定下来；</p></li>
<li><p>其二是<strong>特征映射层</strong>：网络的每个计算层由多个特征映射组成，每个特征映射是一个平面，平面上所有神经元的权值相等。特征映射结构采用影响函数核小的sigmoid函数作为卷积网络的激活函数，使得特征映射具有位移不变性。此外，由于一个映射面上的神经元共享权值，因而减少了网络自由参数的个数。卷积神经网络中的每一个卷积层都紧跟着一个用来求局部平均与二次提取的计算层，这种特有的两次特征提取结构减小了特征分辨率。</p></li>
</ol>

<p>CNN主要<strong>用来识别位移、缩放及其他形式扭曲不变性的二维图形</strong>。由于CNN的特征检测层通过训练数据进行学习，所以在使用CNN时，避免了显示的特征抽取，而隐式地从训练数据中进行学习；</p>

<p>再者由于同一特征映射面上的神经元权值相同，所以网络可以并行学习，这也是卷积网络相对于神经元彼此相连网络的一大优势。<font color=red>卷积神经网络以其局部权值共享的特殊结构在语音识别和图像处理方面有着独特的优越性，</font><strong>其布局更接近于实际的生物神经网络，权值共享降低了网络的复杂性，特别是多维输入向量的图像可以直接输入网络这一特点避免了特征提取和分类过程中数据重建的复杂度</strong>。</p>

<h2 id="toc_1">卷积神经网络</h2>

<p>在图像处理中，往往把图像表示为像素的向量，比如一个1000×1000的图像，可以表示为一个1000000的向量。在上一节中提到的神经网络中，如果隐含层数目与输入层一样，即也是1000000时，那么输入层到隐含层的参数数据为：\(1000000×1000000=10^{12}\)，这样就太多了，基本没法训练。所以图像处理要想练成神经网络大法，必先减少参数加快速度。就跟辟邪剑谱似的，普通人练得很挫，一旦自宫后内力变强剑法变快，就变的很牛了。</p>

<h3 id="toc_2">局部感知</h3>

<p>卷积神经网络有<mark>两种神器</mark>可以降低参数数目，<mark>第一种神器叫做局部感知野</mark>。一般认为人对外界的认知是从局部到全局的，而图像的空间联系也是局部的像素联系较为紧密，而距离较远的像素相关性则较弱。<strong>因而，每个神经元其实没有必要对全局图像进行感知，只需要对局部进行感知</strong>，然后在更高层将局部的信息综合起来就得到了全局的信息。<strong>网络部分连通的思想，也是受启发于生物学里面的视觉系统结构。视觉皮层的神经元就是局部接受信息的（即这些神经元只响应某些特定区域的刺激）。</strong>如下图所示：左图为全连接，右图为局部连接。</p>

<p><img src="media/14940530686573/14940535875953.jpg" alt=""/></p>

<p>在上右图中，假如每个神经元只和10×10个像素值相连，那么权值数据为1000000×100个参数，减少为原来的千分之一。而那10×10个像素值对应的10×10个参数，其实就相当于卷积操作。</p>

<h3 id="toc_3">参数共享</h3>

<p>但其实这样的话参数仍然过多，那么就启动第二级神器，<mark>即权值共享</mark>。在上面的局部连接中，每个神经元都对应100个参数，一共1000000个神经元，如果这1000000个神经元的100个参数都是相等的，那么参数数目就变为100了。</p>

<p>怎么理解权值共享呢？我们可以这100个参数（也就是卷积操作）看成是提取特征的方式，该方式与位置无关。<font color=red>这其中隐含的原理则是：图像的一部分的统计特性与其他部分是一样的。这也意味着我们在这一部分学习的特征也能用在另一部分上，所以对于这个图像上的所有位置，我们都能使用同样的学习特征</font>。</p>

<p>更直观一些，当从一个大尺寸图像中随机选取一小块，比如说 8×8 作为样本，并且从这个小块样本中学习到了一些特征，这时我们可以把从这个 8×8 样本中学习到的特征作为探测器，应用到这个图像的任意地方中去。特别是，我们可以用从 8×8 样本中所学习到的特征跟原本的大尺寸图像作卷积，从而对这个大尺寸图像上的任一位置获得一个不同特征的激活值。</p>

<p>如下图所示，展示了一个33的卷积核在55的图像上做卷积的过程。每个卷积都是一种特征提取方式，就像一个筛子，将图像中符合条件（激活值越大越符合条件）的部分筛选出来</p>

<p><img src="media/14940530686573/14940539862222.gif" alt=""/></p>

<h3 id="toc_4">多卷积核</h3>

<p>上面所述只有100个参数时，表明只有1个100*100的卷积核，显然，特征提取是不充分的，我们可以添加多个卷积核，比如32个卷积核，可以学习32种特征。在有多个卷积核时，如下图所示：<br/>
<img src="media/14940530686573/14940546422731.jpg" alt=""/></p>

<p>上图右，不同颜色表明不同的卷积核。每个卷积核都会将图像生成为另一幅图像。比如两个卷积核就可以将生成两幅图像，这两幅图像可以看做是一张图像的不同的通道。如下图所示，下图有个小错误，即将w1改为w0，w2改为w1即可。下文中仍以w1和w2称呼它们</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[正则表达式]]></title>
    <link href="https://lockxmonk.github.io/14939712159345.html"/>
    <updated>2017-05-05T16:00:15+08:00</updated>
    <id>https://lockxmonk.github.io/14939712159345.html</id>
    <content type="html"><![CDATA[
<p>字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取<code>@</code>前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。</p>

<p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>

<p>所以我们判断一个字符串是否是合法的Email的方法是：</p>

<ol>
<li><p>创建一个匹配Email的正则表达式；</p></li>
<li><p>用该正则表达式去匹配用户的输入来判断是否合法。</p></li>
</ol>

<p>因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。</p>

<p>在正则表达式中，如果直接给出字符，就是精确匹配。用<code>\d</code>可以匹配一个数字，<code>\w</code>可以匹配一个字母或数字，所以：</p>

<ul>
<li><p><code>&#39;00\d&#39;</code>可以匹配<code>&#39;007&#39;</code>，但无法匹配<code>&#39;00A&#39;</code>；</p></li>
<li><p><code>&#39;\d\d\d&#39;</code>可以匹配<code>&#39;010&#39;</code>；</p></li>
<li><p><code>&#39;\w\w\d&#39;</code>可以匹配<code>&#39;py3&#39;</code>；</p></li>
</ul>

<p><code>.</code><strong>可以匹配任意字符</strong>，所以：</p>

<ul>
<li><code>&#39;py.&#39;</code>可以匹配<code>&#39;pyc&#39;</code>、<code>&#39;pyo&#39;</code>、<code>&#39;py!&#39;</code>等等。</li>
</ul>

<p>要匹配变长的字符，在正则表达式中，用<code>*</code>表示任意个字符（包括0个），用<code>+</code>表示至少一个字符，用<code>?</code>表示0个或1个字符，用<code>{n}</code>表示n个字符，用<code>{n,m}</code>表示n-m个字符：</p>

<p>来看一个复杂的例子：<code>\d{3}\s+\d{3,8}</code>。</p>

<p>我们来从左到右解读一下：</p>

<ol>
<li><p><code>\d{3}</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；</p></li>
<li><p><code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>&#39; &#39;，&#39; &#39;</code>等；</p></li>
<li><p><code>\d{3,8}</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。</p></li>
</ol>

<p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p>

<p>如果要匹配<code>&#39;010-12345&#39;</code>这样的号码呢？由于<code>&#39;-&#39;</code>是特殊字符，在正则表达式中，要用<code>&#39;\&#39;</code>转义，所以，上面的正则是<code>\d{3}\-\d{3,8}</code>。</p>

<p>但是，仍然无法匹配<code>&#39;010 - 12345&#39;</code>，因为带有空格。所以我们需要更复杂的匹配方式。</p>

<h2 id="toc_0">进阶</h2>

<p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：</p>

<ul>
<li><p><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</p></li>
<li><p><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>&#39;a100&#39;，&#39;0_Z&#39;，&#39;Py3000&#39;</code>等等；</p></li>
<li><p><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</p></li>
<li><p><code>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</p></li>
</ul>

<p><code>A|B</code>可以匹配A或B，所以<code>(P|p)ython</code>可以匹配<code>&#39;Python&#39;</code>或者<code>&#39;python&#39;</code>。</p>

<p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p>

<p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p>

<p>你可能注意到了，<code>py</code>也可以匹配&#39;python&#39;，但是加上<code>^py$</code>就变成了整行匹配，就只能匹配<code>&#39;py&#39;</code>了。</p>

<h2 id="toc_1">re模块</h2>

<p>有了准备知识，我们就可以在Python中使用正则表达式了。Python提供<code>re</code>模块，包含所有正则表达式的功能。由于Python的字符串本身也用<code>\</code>转义，所以要特别注意：</p>

<pre><code class="language-py">s = &#39;ABC\\-001&#39; # Python的字符串
# 对应的正则表达式字符串变成：
# &#39;ABC\-001&#39;
</code></pre>

<p>因此我们强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了：</p>

<pre><code class="language-py">s = r&#39;ABC\-001&#39; # Python的字符串
# 对应的正则表达式字符串不变：
# &#39;ABC\-001&#39;
</code></pre>

<p>先看看如何判断正则表达式是否匹配：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*
import re

print re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;010-12345&#39;)
print re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;010 12345&#39;)

</code></pre>

<p><code>match()</code>方法判断是否匹配，如果匹配成功，返回一个<code>Match</code>对象，否则返回<code>None</code>。<br/>
<img src="media/14939712159345/14939732218646.jpg" alt=""/></p>

<p>常见的判断方法就是：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*
import re

Spattern = r&#39;^\d{3}\-\d{3,8}$&#39;  #用户定义的正则表达式
test = &#39;010-12345&#39;  #用户输入的字符串
test2 = &#39;012 12345&#39;
if re.match(Spattern , test):
    print &#39;OK&#39;
else:
    print &#39;failed&#39;

if re.match(Spattern , test2):
    print &#39;OK&#39;
else:
    print &#39;failed&#39;
</code></pre>

<p><img src="media/14939712159345/14939734520573.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图像去雾相关基础]]></title>
    <link href="https://lockxmonk.github.io/14938936328646.html"/>
    <updated>2017-05-04T18:27:12+08:00</updated>
    <id>https://lockxmonk.github.io/14938936328646.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0">暗原色</h2>

<p>暗原色先验理论指出，在无雾图像的 非天空区域里，若把图像分为多个子块，则在每个子块中都会 有某些像素点的一个颜色通道的亮度接近于 0</p>

<p><img src="media/14938936328646/14938938844517.jpg" alt=""/><br/>
<img src="media/14938936328646/14938939404387.jpg" alt=""/><br/>
<img src="media/14938936328646/14938939611430.jpg" alt=""/></p>

<h2 id="toc_1">HSV</h2>

<p>HSL 和 HSV（也叫做 HSB）是对RGB 色彩空间中点的两种有关系的表示，它们尝试描述比 RGB 更准确的感知颜色联系，并仍保持在计算上简单。<code>HSL 表示hue（色相）、saturation（饱和度）、lightness（亮度）</code>，<strong>HSV 表示</strong> <code>hue、 saturation、value(色调) 而 HSB 表示hue、saturation、brightness（明度）</code>。</p>

<p>HSL 和 HSV 二者都把颜色描述在圆柱体内的点，这个圆柱的中心轴取值为<strong>自底部的黑色到顶部的白色而在它们中间是的灰色</strong>，绕这个轴的<strong>角度</strong>对应于“色相”，<strong>到这个轴的距离</strong>对应于“饱和度”，而<strong>沿着这个轴的距离</strong>对应于“亮度”，“色调”或“明度”。</p>

<p>HSV（色相，饱和度，明度）在概念上可以被认为是颜色的倒圆锥体（黑点在下顶点，白色在上底面圆心）</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[分布式进程]]></title>
    <link href="https://lockxmonk.github.io/14938608177246.html"/>
    <updated>2017-05-04T09:20:17+08:00</updated>
    <id>https://lockxmonk.github.io/14938608177246.html</id>
    <content type="html"><![CDATA[
<p>在Thread和Process中，应当优选Process，<font color=red><strong>因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</strong></font></p>

<p><strong>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。</strong><font color=red>一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</font></p>

<p>举个例子：如果我们<strong>已经有一个通过<code>Queue</code>通信的多进程程序在同一台机器上运行</strong>，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p>

<p>原有的<code>Queue</code>可以继续使用，<font color=red>但是，通过<code>managers</code>模块把<code>Queue</code>通过网络暴露出去，就可以让其他机器的进程访问<code>Queue</code>了。</font></p>

<p>我们先看服务进程，服务进程负责启动<code>Queue</code>，把<code>Queue</code>注册到网络上，然后往<code>Queue</code>里面写入任务：</p>

<pre><code class="language-py">#taskmanager.py
#-*- coding: utf-8 -*-

import random,time,Queue
from multiprocessing.managers import BaseManager

#发送任务的队列
task_queue = Queue.Queue()
#接受结果的队列
result_queue = Queue.Queue()

#从BaseManager继承的QueueManager:
class QueueManager(BaseManager):
    pass

#把两个Queue都注册到网络上, callable参数关联了Queue对象:
QueueManager.register(&#39;get_task_queue&#39;,callable=lambda:task_queue)
QueueManager.register(&#39;get_result_queue&#39;,callable=lambda:result_queue)

#绑定端口5000，设置验证码‘abc’：
manager = QueueManager(address=(&#39;&#39;,5000),authkey=&#39;abc&#39;)
#启动Queue
manager.start()
# 获得通过网络访问的Queue对象:
task = manager.get_task_queue()
result = manager.get_result_queue()
#放几个任务进去
for i in range(10):
    n = random.randint(0, 10000)
    print(&#39;Put task %d...&#39; %n)
    task.put(n)

#从result队列读取结果
print(&#39;Try get results...&#39;)
for i in range(10):
    r = result.get(timeout=10)
    print(&#39;Result:%s&#39;%r)
#关闭
manager.shutdown()
</code></pre>

<p>请注意，当我们在一台机器上写多进程程序时，创建的<code>Queue</code>可以直接拿来用，但是，在分布式多进程环境下，添加任务到<code>Queue</code>不可以直接对原始的<code>task_queue</code>进行操作，那样就绕过了<code>QueueManager</code>的封装，必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加。</p>

<p>然后，在另一台机器上启动任务进程（本机上启动也可以）：</p>

<pre><code class="language-py">#taskworker.py
#-*- coding: utf-8 -*-

import time
import sys
import Queue
from multiprocessing.managers import BaseManager

# 创建类似的QueueManager:


class QueueManager(BaseManager):
    pass

# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:
QueueManager.register(&#39;get_task_queue&#39;)
QueueManager.register(&#39;get_result_queue&#39;)

# 连接到服务器，也就是运行taskmanager.py的机器:
server_addr = &#39;127.0.0.1&#39;
print(&#39;Connect to server %s...&#39; % server_addr)

# 端口和验证码注意保持与taskmanager.py设置的完全一致:
m = QueueManager(address=(server_addr, 5000), authkey=&#39;abc&#39;)
# 从网络连接:
m.connect()
# 获取Queue的对象:
task = m.get_task_queue()
result = m.get_result_queue()
# 从task队列取任务,并把结果写入result队列:
for i in range(10):
    try:
        n = task.get(timeout=1)
        print(&#39;run task %d * %d...&#39; % (n, n))
        r = &#39;%d * %d = %d&#39; % (n, n, n * n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty:
        print(&#39;task queue is empty.&#39;)
# 处理结束:
print(&#39;worker exit.&#39;)
</code></pre>

<p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p>

<p>现在，可以试试分布式进程的工作效果了。先启动<code>taskmanager.py</code>服务进程：</p>

<p>启动后：<br/>
<img src="media/14938608177246/14938633989382.jpg" alt=""/><br/>
等待result队列中的值。（目前为空)</p>

<p><code>taskmanager</code>进程发送完任务后，开始等待<code>result</code>队列的结果。现在启动<code>taskworker.py</code>进程：</p>

<p><img src="media/14938608177246/14938634594880.jpg" alt=""/></p>

<p><code>taskworker</code>进程结束，在<code>taskmanager</code>进程中会继续打印出结果：</p>

<p><img src="media/14938608177246/14938634810692.jpg" alt=""/></p>

<p>这个简单的<code>Manager/Worker</code>模型有什么用？<font color=red><strong>其实这就是一个简单但真正的分布式计算</strong></font>，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算<code>n*n</code>的代码换成发送邮件，就实现了邮件队列的异步发送。</p>

<p>Queue对象存储在哪？注意到<code>taskworker.py</code>中根本没有创建<code>Queue</code>的代码，所以，Queue对象存储在<code>taskmanager.py</code>进程中：</p>

<p><img src="media/14938608177246/14938635737718.jpg" alt=""/></p>

<p>而<code>Queue</code>之所以能通过网络访问，就是通过<code>QueueManager</code>实现的。由于<code>QueueManager</code>管理的不止一个<code>Queue</code>，所以，要给每个<code>Queue</code>的网络调用接口起个名字，比如<code>get_task_queue</code>。</p>

<p><code>authkey</code>有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果<code>taskworker.py</code>的<code>authkey</code>和<code>taskmanager.py</code>的<code>authkey</code>不一致，肯定连接不上。</p>

<h2 id="toc_0">小结</h2>

<p>Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。</p>

<p><font color=red>注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</font></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[进程与线程]]></title>
    <link href="https://lockxmonk.github.io/14938589289379.html"/>
    <updated>2017-05-04T08:48:48+08:00</updated>
    <id>https://lockxmonk.github.io/14938589289379.html</id>
    <content type="html"><![CDATA[
<p>我们已经熟悉多线程与多进程。他们各有优点与缺点，这里我们简单的说明一下：</p>

<p>首先，要实现多任务，<font color=red>通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</font></p>

<p><strong>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</strong></p>

<p><strong>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</strong></p>

<p>多进程模式最大的优点就是<strong>稳定性高</strong>，因为一个子进程崩溃了，不会影响主进程和其他子进程。（<strong>当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低</strong>）著名的Apache最早就是采用多进程模式。</p>

<p>多进程模式的<font color=red>缺点是创建进程的代价大</font>，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>

<p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，<font color=red>多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。</font>在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>

<p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p>

<h2 id="toc_0">线程切换</h2>

<p>无论是多进程还是多线程，只要数量一多，<strong>效率肯定上不去</strong>，为什么呢？</p>

<p>因为多任务的执行，需要线程或进程的切换，<strong>操作系统在切换时会先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。</strong>这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p>

<p><strong>所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</strong></p>

<h2 id="toc_1">计算密集型和IO密集型</h2>

<p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为<font color=red><strong>计算密集型和IO密集型。</strong></font></p>

<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。<font color=red><strong>这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</strong></font></p>

<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。<strong>Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</strong></p>

<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。<font color=red><strong>对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</strong></font></p>

<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。<strong>对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</strong></p>

<h2 id="toc_2">异步IO</h2>

<p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，<strong>单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</strong></p>

<blockquote>
<p><strong>使用了异步IO，在发起IO请求到实际使用数据这段时间 内，程序还可以继续做其他事情。</strong></p>
</blockquote>

<p>现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，<strong>Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。</strong>在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p>

<p><font color=red><strong>对应到Python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面学习如何编写协程。</strong></font></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThreadLocal]]></title>
    <link href="https://lockxmonk.github.io/14937814533169.html"/>
    <updated>2017-05-03T11:17:33+08:00</updated>
    <id>https://lockxmonk.github.io/14937814533169.html</id>
    <content type="html"><![CDATA[
<p>在多线程环境下，每个线程都有自己的数据。<strong>一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</strong></p>

<p>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦：</p>

<pre><code class="language-py">def process_student(name):
    std = Student(name)
    # std是局部变量，但是每个函数都要用它，因此必须传进去：
    do_task_1(std)
    do_task_2(std)

def do_task_1(std):
    do_subtask_1(std)
    do_subtask_2(std)

def do_task_2(std):
    do_subtask_2(std)
    do_subtask_2(std)
</code></pre>

<p>每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的<code>Student</code>对象，不能共享。</p>

<p>如果用一个全局<code>dict</code>存放所有的<code>Student</code>对象，然后以<code>thread</code>自身作为<code>key</code>获得线程对应的<code>Student</code>对象如何？</p>

<pre><code class="language-py">global_dict = {}

def std_thread(name):
    std = Student(name)
    # 把std放到全局变量global_dict中：
    global_dict[threading.current_thread()] = std
    do_task_1()
    do_task_2()

def do_task_1():
    # 不传入std，而是根据当前线程查找：
    std = global_dict[threading.current_thread()]
    ...

def do_task_2():
    # 任何函数都可以查找出当前线程的std变量：
    std = global_dict[threading.current_thread()]
    ...
</code></pre>

<p>这种方式理论上是可行的，它最大的优点是消除了<code>std</code>对象在每层函数中的传递问题，但是，每个函数获取<code>std</code>的代码有点丑。</p>

<p>有没有更简单的方式？</p>

<p><code>ThreadLocal</code>应运而生，不用查找<code>dict</code>，<code>ThreadLocal</code>帮你自动做这件事：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import threading

# 创建全局ThreadLocal对象
local_school = threading.local()


def process_student():
    print &#39;Hello,%s(in %s)&#39; % (local_school.student, threading.current_thread().name)


def process_thread(name):
    # 绑定ThreadLocal的stutent：
    local_school.student = name
    process_student()

t1 = threading.Thread(target=process_thread, args=(&#39;Alice&#39;,), name=&#39;Thread-A&#39;)
t2 = threading.Thread(target=process_thread, args=(&#39;Bobs&#39;,), name=&#39;Thread-B&#39;)
t1.start()
t2.start()
t1.join()
t2.join()
</code></pre>

<p><img src="media/14937814533169/14937825491356.jpg" alt=""/></p>

<p>全局变量<code>local_school</code>就是一个<code>ThreadLocal</code>对象，每个<code>Thread</code>对它都可以读写<code>student</code>属性，但互不影响。你可以把<code>local_school</code>看成全局变量，但每个属性如<code>local_school.student</code>都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，<code>ThreadLocal</code>内部会处理。</p>

<p>可以理解为全局变量<code>local_school</code>是一个dict，不但可以用<code>local_school.student</code>，还可以绑定其他变量，如<code>local_school.teacher</code>等等。</p>

<p><font color=red><strong><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</strong><br/>
</font></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程]]></title>
    <link href="https://lockxmonk.github.io/14936919183368.html"/>
    <updated>2017-05-02T10:25:18+08:00</updated>
    <id>https://lockxmonk.github.io/14936919183368.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">Lock</a>
</li>
<li>
<a href="#toc_1">小结</a>
</li>
</ul>


<p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p>

<p>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。</p>

<p>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p>

<p>Python的标准库提供了两个模块：<code>thread</code>和<code>threading</code>，<code>thread</code>是低级模块，<code>threading</code>是高级模块，对<code>thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>

<p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import time,threading

#新线程执行的代码
def loop():
    print &#39;thread %s is running...&#39; % threading.current_thread().name
    n = 0
    while n&lt;5:
        n = n+1
        print &#39;thread %s &gt;&gt;&gt; %s&#39; %(threading.current_thread().name,n)
        time.sleep(1)
    print &#39;thread %s ended.&#39; %threading.current_thread().name

print &#39;thread %s is running...&#39; % threading.current_thread().name
t= threading.Thread(target=loop,name=&#39;LoopThread&#39;)
t.start()
t.join()
print &#39;thread %s ended.&#39; % threading.current_thread().name
</code></pre>

<p><img src="media/14936919183368/14936948712548.jpg" alt=""/></p>

<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1，Thread-2……</code></p>

<h2 id="toc_0">Lock</h2>

<p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，<strong>而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</strong></p>

<p>来看看多个线程同时操作一个变量怎么把内容给改乱了：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import time,threading

# 假定这是你的银行存款:
balance = 0

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print balance
</code></pre>

<p><img src="media/14936919183368/14936957737021.jpg" alt=""/><br/>
结果为<code>14</code>而不是<code>0</code></p>

<p>我们定义了一个共享变量<code>balance</code>，初始值为0，并且启动两个线程，先存后取，理论上结果应该为0，但是，由于线程的调度是由操作系统决定的，当<code>t1、t2</code>交替执行时，只要循环次数足够多，<code>balance</code>的结果就不一定是0了。</p>

<p>我们为了得到准确的结果，在某个线程正在修改<code>balance</code>时就要为该线程上一把锁，直到锁释放，其它线程继续执行。创建一个锁就是通过<code>threading.Lock()</code>来实现：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import time,threading

# 假定这是你的银行存款:
balance = 0
lock=threading.Lock()

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        #先获取锁
        lock.acquire()
        try:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()
        
t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print balance
</code></pre>

<p><img src="media/14936919183368/14937055756329.jpg" alt=""/></p>

<p>当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p>

<p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p>

<h2 id="toc_1">小结</h2>

<p>多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。</p>

<p><strong>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦</strong></p>

<p><font color=red>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。<br/>
</font></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[进程和线程]]></title>
    <link href="https://lockxmonk.github.io/14936863062791.html"/>
    <updated>2017-05-02T08:51:46+08:00</updated>
    <id>https://lockxmonk.github.io/14936863062791.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">多进程</a>
</li>
<li>
<a href="#toc_1">multiprocessing</a>
</li>
<li>
<a href="#toc_2">Pool</a>
</li>
<li>
<a href="#toc_3">进程间通信</a>
<ul>
<li>
<a href="#toc_4">小结</a>
</li>
</ul>
</li>
</ul>


<p>我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办</p>

<p>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</p>

<p><strong>还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</strong></p>

<p>当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</p>

<p>总结一下就是，多任务的实现有3种方式：</p>

<ul>
<li>多进程模式；</li>
<li>多线程模式；</li>
<li>多进程+多线程模式。</li>
</ul>

<blockquote>
<p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
</blockquote>

<h2 id="toc_0">多进程</h2>

<p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code><font color=red>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回</font>。</p>

<p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p>

<p>Python的<code>os</code>模块封装了常见的系统调用，其中就包括<code>fork</code>，可以在Python程序中轻松创建子进程：</p>

<pre><code class="language-py">import os

print &#39;Process (%s) start&#39; %os.getpid()

pid = os.fork()
if pid == 0:
    print &#39;I am child process (%s) and my parent is %s.&#39; %(os.getpid(),os.getppid())
else:
    print &#39;I (%s) just created a child process (%s)&#39; %(os.getpid(),pid)
</code></pre>

<p><img src="media/14936863062791/14936874189758.jpg" alt=""/></p>

<p>第一次返回父进程，第二次返回子进程。所以分别打印出了不同的结果。</p>

<p>有了<code>fork</code>调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p>

<h2 id="toc_1">multiprocessing</h2>

<p>如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没有<code>fork</code>调用，难道在Windows上无法用Python编写多进程的程序？</p>

<p>由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。<code>multiprocessing</code>模块就是跨平台版本的多进程模块。</p>

<p><code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
from multiprocessing import Process

import os

# 子进程要执行的代码


def run_proc(name):
    print &#39;Run child process %s(%s)&#39; % (name, os.getpid())

if __name__ == &#39;__main__&#39;:
    print &#39;Parent process %s.&#39; % os.getpid()
p = Process(target=run_proc, args=(&#39;test&#39;,))
print &#39;Process will start.&#39;
p.start()
p.join()
print &#39;Process end&#39;
</code></pre>

<p><img src="media/14936863062791/14936889041171.jpg" alt=""/></p>

<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p>

<p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>

<h2 id="toc_2">Pool</h2>

<p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>

<pre><code class="language-py">from multiprocessing import Pool
import os
import time
import random


def long_time_task(name):
    print &#39;Run task %s(%s)...&#39; % (name, os.getpid())
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print &#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start))

if __name__ == &#39;__main__&#39;:
    print &#39;Parent process %s.&#39; % os.getpid()
    p = Pool()
    for i in range(9):
        p.apply_async(long_time_task, args=(i,))
    print &#39;Waiting for all subprocesses done...&#39;
    p.close()
    p.join()
    print &#39;All subprocess done&#39;
</code></pre>

<p><img src="media/14936863062791/14936904615182.jpg" alt=""/></p>

<p>代码解读：</p>

<p>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p>

<p>请注意输出的结果，task 0~7是立刻执行的，而task 8要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是8，因此，最多同时执行8个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：<code>p = Pool(9)</code></p>

<p>就可以同时跑9个进程。</p>

<p>由于Pool的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p>

<h2 id="toc_3">进程间通信</h2>

<p><code>Process</code>之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p>

<p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

from multiprocessing import Process,Queue
import os,time,random

#写数据进程执行的代码
def write(q):
    for value in [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;]:
        print &#39;Put %s to quene...&#39; % value
        q.put(value)
        time.sleep(random.random())
#读数据进程执行的代码
def read(q):
    while True:
        value = q.get(True)
        print &#39;Get %s from quene.&#39; %value

if __name__==&#39;__main__&#39;:
    #父进程创建Quene,并传给各个子进程：
    q = Queue()
    pw = Process(target=write,args=(q,))
    pr = Process(target=read,args=(q,))
    #启动子进程pw，写入：
    pw.start()
    #启动子进程pr，读取：
    pr.start()
    #等待pw结束：
    pw.join()
    #pr进程里是死循环，无法等待其结束，只能强行终止：
    pr.terminate()

</code></pre>

<p><img src="media/14936863062791/14936917220576.jpg" alt=""/></p>

<p>在Unix/Linux下，<code>multiprocessing</code>模块封装了<code>fork()</code>调用，使我们不需要关注<code>fork()</code>的细节。由于Windows没有fork调用，因此，<code>multiprocessing</code>需要“模拟”出fork的效果，父进程所有Python对象都必须通过<code>pickle</code>序列化再传到子进程去，所有，如果<code>multiprocessing</code>在Windows下调用失败了，要先考虑是不是pickle失败了。</p>

<h3 id="toc_4">小结</h3>

<p>在Unix/Linux下，可以使用<code>fork()</code>调用实现多进程。</p>

<p>要实现跨平台的多进程，可以使用<code>multiprocessing</code>模块。</p>

<p>进程间通信是通过<code>Queue、Pipes</code>等实现的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[序列化]]></title>
    <link href="https://lockxmonk.github.io/14933396433742.html"/>
    <updated>2017-04-28T08:34:03+08:00</updated>
    <id>https://lockxmonk.github.io/14933396433742.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">JSON</a>
</li>
<li>
<a href="#toc_1">JSON进阶</a>
</li>
<li>
<a href="#toc_2">小结</a>
</li>
</ul>


<p><strong>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</strong></p>

<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>

<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>

<p>Python提供两个模块来实现序列化：<code>cPickle</code>和<code>pickle</code>。这两个模块功能是一样的，区别在于<code>cPickle</code>是C语言写的，速度快，<code>pickle</code>是纯Python写的，速度慢，跟<code>cStringIO和StringIO</code>一个道理。用的时候，先尝试导入<code>cPickle</code>，如果失败，再导入<code>pickle</code>：</p>

<pre><code class="language-py">try:
    import cPickle as pickle
except ImportError:
    import pickle
</code></pre>

<p>我们尝试把一个对象序列化并写入文件：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

d = dict(name=&#39;LZH&#39;,age=20,score=88)
print pickle.dumps(d)
</code></pre>

<p><img src="media/14933396433742/14933403797179.jpg" alt=""/></p>

<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>str</code>，然后，就可以把这个<code>str</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

d = dict(name=&#39;梁中豪&#39;,age=20,score=88)
f = open(&#39;test.txt&#39;,&#39;wb&#39;)  
pickle.dump(d,f)
f.close

</code></pre>

<p><img src="media/14933396433742/14933405542811.jpg" alt=""/></p>

<p>我们可以读取文件中这些内容，并且将他们反序列化来显示原来的内容：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

#d = dict(name=&#39;梁中豪&#39;,age=20,score=88)
f = open(&#39;test.txt&#39;,&#39;rb&#39;)  
print pickle.load(f)
f.close

</code></pre>

<p>可以先把内容读到一个<code>str</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象</p>

<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>

<p>下面我们用JSON来进行网络间的数据传递。</p>

<h2 id="toc_0">JSON</h2>

<p>如果我们要在不同的编程语言之间传递对象，<strong>就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串</strong>，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>

<p><strong><code>JSON</code>表示的对象就是标准的<code>JavaScript</code>语言的对象，<code>JSON</code>和Python内置的数据类型对应如下：</strong></p>

<table>
<thead>
<tr>
<th>Json类型</th>
<th>Python类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>{}</td>
<td>dict</td>
</tr>
<tr>
<td>[]</td>
<td>list</td>
</tr>
<tr>
<td>string</td>
<td>str或u&#39;unicode&#39;</td>
</tr>
<tr>
<td>12345.56</td>
<td>int或float</td>
</tr>
<tr>
<td>true/false</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody>
</table>

<p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</p>

<pre><code class="language-py">import json
d = dict(name=&#39;Lichao&#39;, age=20, score=88)
print json.dumps(d)

</code></pre>

<p><img src="media/14933396433742/14933496188910.jpg" alt=""/></p>

<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的JSON。类似的，<code>dump()</code>方法可以直接把JSON写入一个<code>file-like Object</code>。</p>

<p>要把JSON反序列化为Python对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把JSON的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>

<pre><code class="language-py">import json
json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Lichao&quot;}&#39;
print json.loads(json_str)
</code></pre>

<p><img src="media/14933396433742/14933497889867.jpg" alt=""/></p>

<p>有一点需要注意，就是反序列化得到的所有字符串对象默认都是<code>unicode</code>而不是<code>str</code>。由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的<code>str或unicode</code>与JSON的字符串之间转换。</p>

<h2 id="toc_1">JSON进阶</h2>

<p>Python的<code>dict</code>对象可以直接序列化为JSON的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p>

<pre><code class="language-py">import json


class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;LiChao&#39;, 20, 88)
print(json.dumps(s))
</code></pre>

<p><img src="media/14933396433742/14933605238135.jpg" alt=""/><br/>
向上述那样调用，会报错，因为<code>Student</code>对象不是一个可序列化为JSON的对象。</p>

<p>我们仔细看看<code>dumps()</code>方法的参数列表，可以发现，除了第一个必须的<code>obj</code>参数外，<code>dumps()</code>方法还提供了一大堆的可选参数。</p>

<p>这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把<code>Student</code>类实例序列化为JSON，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个JSON的<code>{}</code>对象。</p>

<p>可选参数<code>default</code>就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p>

<pre><code class="language-py">import json

def student2dict(std):
    return {
    &#39;name&#39;:std.name,
    &#39;age&#39;:std.age,
    &#39;score&#39;:std.score
    }

class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;LiChao&#39;, 20, 88)
print(json.dumps(s,default=student2dict))
</code></pre>

<p><img src="media/14933396433742/14933609788679.jpg" alt=""/></p>

<p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为<code>JSON</code>。</p>

<p><strong>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为<code>JSON</code>。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</strong></p>

<pre><code class="language-py">print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>

<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p>

<p>同样的道理，如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个dict对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p>

<pre><code class="language-py">import json

def dict2students(d):
    return Student(d[&#39;name&#39;],d[&#39;age&#39;],d[&#39;score&#39;])

class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;
print(json.loads(json_str,object_hook=dict2students))
</code></pre>

<p><img src="media/14933396433742/14933619206509.jpg" alt=""/></p>

<p>打印出的是反序列化的<code>Student</code>实例对象。</p>

<h2 id="toc_2">小结</h2>

<p>Python语言特定的序列化模块是<code>pickle</code>，但如果要把序列化搞得更通用、更符合Web标准，就可以使用<code>json</code>模块。</p>

<p><code>json</code>模块的<code>dumps()和loads()</code>函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[操作文件和目录]]></title>
    <link href="https://lockxmonk.github.io/14932778418691.html"/>
    <updated>2017-04-27T15:24:01+08:00</updated>
    <id>https://lockxmonk.github.io/14932778418691.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">环境变量</a>
</li>
<li>
<a href="#toc_1">操作文件和目录</a>
</li>
<li>
<a href="#toc_2">小结</a>
</li>
<li>
<a href="#toc_3">练习：</a>
</li>
</ul>


<p>如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如<code>dir</code>、<code>cp</code>等命令</p>

<p>Python内置的<code>os</code>模块也可以直接调用操作系统提供的接口函数。</p>

<p>打开Python交互式命令行，我们来看看如何使用<code>os</code>模块的基本功能：</p>

<p><img src="media/14932778418691/14932780434722.jpg" alt=""/></p>

<p>注意<code>uname()</code>函数在Windows上不提供，也就是说，os模块的某些函数是跟操作系统相关的。</p>

<h2 id="toc_0">环境变量</h2>

<p>在操作系统中定义的环境变量，全部保存在<code>os.environ</code>这个<code>dict</code>中，可以直接查看：<br/>
<img src="media/14932778418691/14932785335515.jpg" alt=""/></p>

<p>要获取某个环境变量的值，可以调用<code>os.getenv()</code>函数：</p>

<p><img src="media/14932778418691/14932786096064.jpg" alt=""/></p>

<h2 id="toc_1">操作文件和目录</h2>

<p>操作文件和目录的函数一部分放在os模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print os.path.abspath(&#39;.&#39;)
print os.path.join(&#39;/Users/liangzhonghao/Desktop/&#39;,&#39;test&#39;)

#os.mkdir(&#39;/Users/liangzhonghao/Desktop/python&#39;)
os.rmdir(&#39;/Users/liangzhonghao/Desktop/python&#39;)
</code></pre>

<p><img src="media/14932778418691/14932791801381.jpg" alt=""/></p>

<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print os.path.splitext(&#39;/Users/liangzhonghao/Desktop/text.txt&#39;)
</code></pre>

<p><img src="media/14932778418691/14932792804815.jpg" alt=""/></p>

<p><strong>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</strong></p>

<p><code>os</code>模块有很多功能，例如重命名文件，删除文件。但是他没有复制文件的功能。因为复制文件并非是由操作系统提供的系统调用。</p>

<p>幸运的是<code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p>

<p><strong>最后看看如何利用Python的特性来过滤文件</strong>。比如我们要列出当前目录下的所有目录，只需要一行代码：</p>

<pre><code class="language-py">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]
</code></pre>

<p><img src="media/14932778418691/14932797710625.jpg" alt=""/></p>

<p>要列出所有的.py文件，也只需一行代码：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#39;.py&#39;]
</code></pre>

<p><img src="media/14932778418691/14932798281538.jpg" alt=""/></p>

<h2 id="toc_2">小结</h2>

<p>Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在<code>os.path</code>模块中</p>

<h2 id="toc_3">练习：</h2>

<p>编写一个<code>search(s)</code>的函数，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出完整路径：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os

def search(s ,dir=os.path.abspath(&#39;.&#39;)):
    for x in os.listdir(dir):
        path = os.path.join(dir,x)
        if s in x:
            print path
        elif os.path.isdir(path):
            search(s,path)

search(&#39;pr&#39;)

</code></pre>

<p><img src="media/14932778418691/14932810251430.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I/O编程]]></title>
    <link href="https://lockxmonk.github.io/14932734930436.html"/>
    <updated>2017-04-27T14:11:33+08:00</updated>
    <id>https://lockxmonk.github.io/14932734930436.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">文件读写</a>
<ul>
<li>
<a href="#toc_1">读文件</a>
</li>
<li>
<a href="#toc_2">file-like Object</a>
</li>
<li>
<a href="#toc_3">二进制文件</a>
</li>
<li>
<a href="#toc_4">写文件</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">小结</a>
</li>
</ul>


<h2 id="toc_0">文件读写</h2>

<h3 id="toc_1">读文件</h3>

<p>要以读文件的模式来打开一个文件对象，使用Python内置的<code>open（）</code>函数，传入文件名和标识符：</p>

<pre><code class="language-py">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)
</code></pre>

<p>标示符&#39;r&#39;表示读，这样，我们就成功地打开了一个文件。</p>

<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：<br/>
<img src="media/14932734930436/14932737513488.jpg" alt=""/></p>

<p>如果文件打开成功，接下来，调用<code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，用一个<code>str</code>对象表示：<br/>
<img src="media/14932734930436/14932741526772.jpg" alt=""/></p>

<p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现。这种方法太麻烦。我们这里使用python所提供的方法：</p>

<p>Python引入了with语句来自动帮我们调用<code>close()</code>方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;r&#39;) as f:
    print f.read()
</code></pre>

<p><img src="media/14932734930436/14932743740546.jpg" alt=""/></p>

<p>这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p>

<p>调用<code>read()</code>会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取<code>size</code>个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p>

<p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;r&#39;) as f:
    for line in f.readlines():
        print(line.strip())  #把末尾的&#39;\n&#39;删掉
</code></pre>

<p><img src="media/14932734930436/14932746986776.jpg" alt=""/></p>

<h3 id="toc_2">file-like Object</h3>

<p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。</p>

<p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p>

<h3 id="toc_3">二进制文件</h3>

<p>前面讲的默认都是读取文本文件，并且是ASCII编码的文本文件。要读取二进制文件，比如图片、视频等等，用<code>rb</code>模式打开文件即可：<br/>
<img src="media/14932734930436/14932760233490.jpg" alt=""/></p>

<h3 id="toc_4">写文件</h3>

<p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p>

<pre><code class="language-py">&gt;&gt;&gt; f = open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;, &#39;w&#39;)
&gt;&gt;&gt; f.write(&#39;Hello, world!Again！&#39;)
&gt;&gt;&gt; f.close()
</code></pre>

<p>这里推荐直接调用with方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;w&#39;) as f:
    f.write(&#39;Hello, world!Again!&#39;)
</code></pre>

<p><img src="media/14932734930436/14932763793296.jpg" alt=""/></p>

<p><font color=red><strong>要注意的是一旦写入文件，原来文件中的内容会被删除！</strong></font></p>

<h2 id="toc_5">小结</h2>

<p>在Python中，文件读写是通过<code>open()</code>函数打开的文件对象完成的。使用<code>with</code>语句操作文件IO是个好习惯。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文档测试]]></title>
    <link href="https://lockxmonk.github.io/14932622908500.html"/>
    <updated>2017-04-27T11:04:50+08:00</updated>
    <id>https://lockxmonk.github.io/14932622908500.html</id>
    <content type="html"><![CDATA[
<p><strong>在python中我们可以执行那些在注释中的代码，来进行测试。</strong></p>

<p>当我们编写注释时，如果写上这样的注释：</p>

<pre><code class="language-py">def abs(n):
    &#39;&#39;&#39;
    Function to get absolute value of number.

    Example:

    &gt;&gt;&gt; abs(1)
    1
    &gt;&gt;&gt; abs(-1)
    1
    &gt;&gt;&gt; abs(0)
    0
    &#39;&#39;&#39;
    return n if n &gt;= 0 else (-n)
</code></pre>

<p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p>

<p><strong>并且，Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</strong></p>

<p><font color=red>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用...表示中间一大段烦人的输出。</font></p>

<p>让我们用doctest来测试上次编写的<code>Dict</code>类：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Dict(dict):
    
    &quot;&quot;&quot;
    Simple dict but also support access as x.y style

    &gt;&gt;&gt; d1 = Dict()
    &gt;&gt;&gt; d1[&#39;x&#39;] = 100
    &gt;&gt;&gt; d1.x
    100
    &gt;&gt;&gt; d1.y = 200
    &gt;&gt;&gt; d1[&#39;y&#39;]
    200
    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#39;3&#39;)
    &gt;&gt;&gt; d2.c
    &#39;3&#39;
    &gt;&gt;&gt; d2[&#39;empty&#39;]
    Traceback (most recent call last):
        ...
    KeyError: &#39;empty&#39;
    &gt;&gt;&gt; d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: &#39;Dict&#39; object has no attribute &#39;empty&#39;
    
    &quot;&quot;&quot;
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)
    def __getattr__(self,key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)
        else:
            pass
        finally:
            pass
    def __setattr__(self,key,value):
        self[key] = value
if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod()
</code></pre>

<p>如果什么输出都没有，说明我们编写的<code>doctest</code>运行都是正确的。<br/>
<img src="media/14932622908500/14932639594028.jpg" alt=""/><br/>
如果我们把</p>

<pre><code class="language-py">&gt;&gt;&gt; d2.c
    &#39;4&#39; #3改成4
</code></pre>

<p>运行后就会显示：</p>

<p><img src="media/14932622908500/14932640459265.jpg" alt=""/></p>

<p><strong>注意到最后两行代码。当模块正常导入时，doctest不会被执行。只有在命令行运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图像去雾相关论文总结]]></title>
    <link href="https://lockxmonk.github.io/14932573311953.html"/>
    <updated>2017-04-27T09:42:11+08:00</updated>
    <id>https://lockxmonk.github.io/14932573311953.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">1.特征学习的单幅图像去雾算法 2016年</a>
</li>
</ul>
</li>
<li>
<a href="#toc_1">2.尺度自适应暗通道先验去雾方法</a>


<h2 id="toc_0">1.特征学习的单幅图像去雾算法 2016年</h2>

<p><strong>目的：</strong>为提高图像去雾的普适性，提出一种特征学习的单幅图像去雾方法。</p>

<p><strong>方法：</strong>通过稀疏自动编码机对有雾图像进行<strong>多尺度的纹理结构特征提取</strong>，同时抽取各种与雾相关的颜色特征。然后采用多层神经网络进行样本训练，得到雾天条件下纹理结构特征及颜色特征与场景深度间的映射关系，并估算出有雾图像的场景深度图。最后结合大气散射模型，根据场景深度图复原无雾图像。</p>

<p><strong>结论：对实验结果的定性及定量分 析表明，本文算法能有效获取有雾图像的场景深度，复原出视觉效果理想的无雾图像，且具有很好的场景普适性。</strong></p>

<p><strong>理解</strong>：<font color=red>本文认为图像去雾的问题可进一步转化为场景深度d的求解问题。</font>本文通过自动编码机获取到图片中物体的纹理特征，然后用多尺度的方法分别提取<strong>颜色特征、暗原色特征、颜色衰减特征、纹理结构</strong>特征。<strong>四者结合对场景深度进行估计</strong>。</p>

<p><strong>可以改进的</strong>：</p>

<ol>
<li><p>算法实时性不够强，效率比较低，可以考虑缩小图片尺寸，降低数据量，从而运用到视频去雾。</p></li>
<li><p>对雾气分布不均匀的图像，效果不理想，需要结合不同的气象模型来建立更为鲁棒的物理模型。</p></li>
</ol>

<h1 id="toc_1">2.尺度自适应暗通道先验去雾方法</h1>

<p><strong>目的：</strong><br/>
针对暗通道先验去雾方法的尺度选择问题 提出了一种尺度自适应方法， 根据图像的颜色和边 缘特征将暗通道求解的尺度自适应地调整到一个合适的范围。</p>

<p><strong>方法：</strong></p>

<ol>
<li><p>由颜色特征求解初始尺度：<font color=red>对于图像的不同区域采用不同的尺度求解暗通道: 在亮度较低或饱和度较高的区域，采用较小尺度; 在亮度较高且饱和度较低的区域，采用较大尺度;在景深突变处，采用较小尺度;在平滑区域，采用较大尺度。</font></p></li>
<li><p>由边缘特征对尺度进行修正:由于“光晕”现象发生在景深突变处，如果在边缘附近采用较小的尺度，可使透射率的求解窗口\(Ω_r(x)\)尽量不跨越景深边界，从而减小“光晕”现象; 在非边缘处采用较大的尺度，可以增大 \(J_{dark}(x)→0\)的概率，使复原图像的背景更平滑，噪声和失真更小。 由边缘特征对初始尺度\(r_0(x)\)进行修正.</p></li>
</ol>

<p><strong>结论：</strong><br/>
整个去雾过程参数自动配置，无需人工干预，兼顾不同尺度复原图像的优点，复原图像色彩自然，对比度提升显著，并有效抑制了“光晕”现象。对多种雾化场景图像的处理结果表明: <strong>文中方法对场景的适应性强， 在任何情况下的处理结果均能达到 DG 方法的最优结果，甚至更好。</strong></p>

<p><strong>理解：</strong><br/>
该论文主要是针对HE的去雾方法，对暗通道尺寸进行自适应确定，减少了人工干预的复杂度。</p>

<p><strong>可以改进：</strong><br/>
<font color=red>该算法在运行时间上可以改进，也可以利用机器学习的方法来提取图片特征，避免Canny算子的局限性造成的边缘提取误差。<br/>
可以与上篇论文进行结合来提高上文尺度特征提取的效率。</font></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文档测试]]></title>
    <link href="https://lockxmonk.github.io/14928484245894.html"/>
    <updated>2017-04-22T16:07:04+08:00</updated>
    <id>https://lockxmonk.github.io/14928484245894.html</id>
    <content type="html"><![CDATA[
<p>如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。比如<a href="https://docs.python.org/2/library/re.html">re</a>模块就带了很多示例代码：</p>

<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search(&#39;(?&lt;=abc)def&#39;, &#39;abcdef&#39;)
&gt;&gt;&gt; m.group(0)
&#39;def&#39;
</code></pre>

<p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p>

<p>这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？</p>

<p>答案是肯定的。</p>

<p>当我们编写注释时，如果写上这样的注释：</p>

<pre><code class="language-py">
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单元测试]]></title>
    <link href="https://lockxmonk.github.io/14928429198094.html"/>
    <updated>2017-04-22T14:35:19+08:00</updated>
    <id>https://lockxmonk.github.io/14928429198094.html</id>
    <content type="html"><![CDATA[
<p>我们来编写一个<code>Dict</code>类，这个类的行为和<code>dict</code>一致，但是可以通过属性来访问，用起来就像下面这样：</p>

<pre><code>&gt;&gt;&gt; d = Dict(a=1, b=2)
&gt;&gt;&gt; d[&#39;a&#39;]
1
&gt;&gt;&gt; d.a
1
</code></pre>

<p>mydict.py代码为：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Dict(dict):

    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r &quot; &#39;Dict&#39; object has no atr &#39;%s&#39; &quot; % key)
        else:
            pass
        finally:
            pass

    def __setattr__(self, key, value):
        self[key] = value

</code></pre>

<p>为了编写单元测试，我们需要引入Python自带的<code>unittest</code>模块，编写<code>mydict_test.py</code>如下：</p>

<pre><code class="language-py">import unittest

from mydict import Dict


class TestDict(unittest.TestCase):

    def test_init(self):
        d = Dict(a=1, b=&#39;test&#39;)
        self.assertEquals(d.a, 1)
        self.assertEquals(d.b, &#39;test&#39;)
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d[&#39;key&#39;] = &#39;value&#39;
        self.assertEquals(d.key, &#39;value&#39;)

    def test_attr(self):
        d = Dict()
        d.key = &#39;value&#39;
        self.assertTrue(&#39;key&#39; in d)
        self.assertEquals(d[&#39;key&#39;], &#39;value&#39;)

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d[&#39;empty&#39;]

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError)
            value = d.empty

</code></pre>

<p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。</p>

<p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p>

<p>对每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是<code>assertEquals()：</code></p>

<pre><code class="language-py">self.assertEquals(abs(-1), 1) # 断言函数返回的结果与1相等
</code></pre>

<p>另一种重要的断言就是期待抛出指定类型的<code>Error</code>，比如通过<code>d[&#39;empty&#39;]</code>访问不存在的key时，断言会抛出<code>KeyError</code>：</p>

<pre><code class="language-py">with self.assertRaises(KeyError):
    value = d[&#39;empty&#39;]
</code></pre>

<p>而通过<code>d.empty</code>访问不存在的<code>key</code>时，我们期待抛出<code>AttributeError</code>：</p>

<pre><code class="language-py">with self.assertRaises(AttributeError):
    value = d.empty
</code></pre>

<h2 id="toc_0">运行单元测试</h2>

<p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在<code>mydict_test.py</code>的最后加上两行代码：</p>

<pre><code class="language-py">if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>

<p>这样就可以把<code>mydict_test.py</code>当做正常的python脚本运行：</p>

<p><img src="media/14928429198094/14928450280463.jpg" alt=""/></p>

<p>另一种更常见的方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试:<br/>
<img src="media/14928429198094/14928451217135.jpg" alt=""/></p>

<p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p>

<h2 id="toc_1">setUp与tearDown</h2>

<p>可以在单元测试中编写两个特殊的<code>setUp()</code>和<code>tearDown()</code>方法。这两个方法会分别在每<strong>调用一个测试方法的前后分别被执行</strong>。</p>

<p><code>setUp()和tearDown()</code>方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在<code>setUp()</code>方法中连接数据库，在<code>tearDown()</code>方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：</p>

<pre><code class="language-py">import unittest

from mydict import Dict

class TestDict(unittest.TestCase):

    def setUp(self):    
        print &#39;setUp...&#39;

    def tearDown(self):
        print &#39;tearDown...&#39;
    
    def test_init(self):    
        d = Dict(a=1, b=&#39;test&#39;)
        self.assertEquals(d.a, 1)   
        self.assertEquals(d.b, &#39;test&#39;)
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d[&#39;key&#39;] = &#39;value&#39;
        self.assertEquals(d.key, &#39;value&#39;)

    def test_attr(self):
        d = Dict()
        d.key = &#39;value&#39;
        self.assertTrue(&#39;key&#39; in d)
        self.assertEquals(d[&#39;key&#39;], &#39;value&#39;)

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d[&#39;empty&#39;]

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError):
            value = d.empty

if __name__ == &#39;__main__&#39;:
     unittest.main()
</code></pre>

<p><img src="media/14928429198094/14928470586520.jpg" alt=""/></p>

<h2 id="toc_2">总结</h2>

<ol>
<li><p>单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p></li>
<li><p>单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。</p></li>
<li><p>单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。</p></li>
<li><p>单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调试]]></title>
    <link href="https://lockxmonk.github.io/14928307466218.html"/>
    <updated>2017-04-22T11:12:26+08:00</updated>
    <id>https://lockxmonk.github.io/14928307466218.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">断言</a>
</li>
<li>
<a href="#toc_1">logging</a>
</li>
<li>
<a href="#toc_2">pdb</a>
</li>
<li>
<a href="#toc_3">pdb.set_trace()</a>
</li>
<li>
<a href="#toc_4">IDE</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">总结</a>


<p>程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。</p>

<p>第一种方法简单直接粗暴有效，就是用<code>print</code>把可能有问题的变量打印出来看看.（这种方法不详细说明了，基本每个写代码的人都比较熟悉这种方法）</p>

<h2 id="toc_0">断言</h2>

<p>凡是用<code>print</code>来辅助查看的地方，都可以用断言<code>（assert）</code>来替代：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
def foo(s):
    n=int(s)
    assert n!=0,&#39;n is zero&#39;
    return 10/n
def main():
    foo(&#39;0&#39;)
main()
</code></pre>

<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，后面的代码就会出错。</p>

<p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p>

<p><img src="media/14928307466218/14928311015673.jpg" alt=""/><br/>
启动Python解释器时可以用<code>-O</code>参数来关闭<code>assert</code></p>

<pre><code>$ python -O err.py
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division or modulo by zero
</code></pre>

<p>关闭后，你可以把所有的<code>assert</code>语句当成<code>pass</code>来看。</p>

<h2 id="toc_1">logging</h2>

<p>把<code>print</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import logging

s = &#39;0&#39;
n = int(s)
logging.info(&#39;n = %d&#39; % n)
print 10 / n
</code></pre>

<p><code>logging.info()</code>就可以输出一段文本。运行，发现除了<code>ZeroDivisionError</code>，没有任何信息。<br/>
<img src="media/14928307466218/14928313656997.jpg" alt=""/></p>

<p>加上：</p>

<pre><code class="language-py">import logging
logging.basicConfig(level=logging.INFO)
</code></pre>

<p>之后显示：<br/>
<img src="media/14928307466218/14928314465553.jpg" alt=""/><br/>
这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug，info，warning，error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug和info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>

<p><code>logging</code>的另一个好处是通过简单的配置，<strong>一条语句可以同时输出到不同的地方，比如console和文件</strong>。</p>

<h2 id="toc_2">pdb</h2>

<p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
s = &#39;0&#39;
n = int(s)
print 10 / n
</code></pre>

<p>然后启动：<br/>
<img src="media/14928307466218/14928416845706.jpg" alt=""/></p>

<p>输入命令<code>l</code>来查看代码,输入命令<code>n</code>可以单步执行代码,任何时候都可以输入命令<code>p</code> 变量名来查看变量,输入命令<code>q</code>结束调试，退出程序.</p>

<h2 id="toc_3">pdb.set_trace()</h2>

<p>这个方法也是用<code>pdb</code>，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import pdb

s = &#39;0&#39;
n = int(s)
pdb.set_trace()  # 运行到这里会自动暂停
print 10 / n

</code></pre>

<p><img src="media/14928307466218/14928418957951.jpg" alt=""/><br/>
运行代码，程序会自动在<code>pdb.set_trace()</code>暂停并进入pdb调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行</p>

<p>这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。</p>

<h2 id="toc_4">IDE</h2>

<p>如果想要有好的设置断点、单步执行体验，就需要一个支持调试功能的IDE。目前比较好的<strong>Python IDE有PyCharm</strong>：<br/>
<a href="https://www.jetbrains.com/pycharm">https://www.jetbrains.com/pycharm</a></p>

<p>写程序最痛苦的事情莫过于调试，程序往往会以你意想不到的流程来运行，你期待执行的语句其实根本没有执行，这时候，就需要调试了。</p>

<h1 id="toc_5">总结</h1>

<p><strong>虽然用IDE调试起来比较方便，但是最后你会发现，<code>logging</code>才是终极武器。</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[错误、调试和测试]]></title>
    <link href="https://lockxmonk.github.io/14928231077736.html"/>
    <updated>2017-04-22T09:05:07+08:00</updated>
    <id>https://lockxmonk.github.io/14928231077736.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">错误处理</a>
<ul>
<li>
<a href="#toc_1">try</a>
</li>
<li>
<a href="#toc_2">调用堆栈</a>
</li>
<li>
<a href="#toc_3">记录错误</a>
</li>
<li>
<a href="#toc_4">抛出错误</a>
</li>
</ul>
</li>
</ul>


<p>Python内置了一套异常处理机制，来帮助我们进行错误处理。</p>

<p>此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的<strong><em>pdb</em></strong>可以让我们以单步方式执行代码。</p>

<p>最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。</p>

<h2 id="toc_0">错误处理</h2>

<p>在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数<code>open()</code>，成功时返回文件描述符（就是一个整数），出错时返回<code>-1</code>。</p>

<p>用错误码来表示是否出错十分不便，因为函数本身应该返回的正常结果和错误码混在一起，造成调用者必须用大量的代码来判断是否出错。</p>

<p>所以高级语言通常都内置了一套<code>try...except...finally...</code>的错误处理机制，Python也不例外。</p>

<h3 id="toc_1">try</h3>

<p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    print &#39;try...&#39;
    r = 10 / 0
    print &#39;result:&#39;, r
except ZeroDivisionError, e:
    print &#39;except:&#39;, e
finally:
    print &#39;finally...&#39;
print &#39;END&#39;
</code></pre>

<p><img src="media/14928231077736/14928238871411.jpg" alt=""/><br/>
从输出可以看到，当错误发生时，后续语句<code>print &#39;result:&#39;, r</code>不会被执行，<code>except</code>由于捕获到<code>ZeroDivisionError</code>，因此被执行。最后，<code>finally</code>语句被执行。然后，程序继续按照流程往下走。</p>

<p>你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的<code>except</code>语句块处理。没错，可以有多个<code>except</code>来捕获不同类型的错误：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    print &#39;try...&#39;
    r = 10 / int(0)
    print &#39;result:&#39;, r
except ValueError as e:
    print &#39;ValueError:&#39;,e
except ZeroDivisionError as e:
    print &#39;ZeroDivisionError:&#39;, e
else:
    print &#39;no error&#39;
finally:
    print &#39;finally...&#39;
print &#39;END&#39;
</code></pre>

<p><img src="media/14928231077736/14928249482640.jpg" alt=""/></p>

<p>Python的错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</p>

<pre><code class="language-py">try:
    foo()
except StandardError, e:
    print &#39;StandardError&#39;
except ValueError, e:
    print &#39;ValueError&#39;
</code></pre>

<p>第二个<code>except</code>永远也捕获不到<code>ValueError</code>，因为<code>ValueError是StandardError</code>的子类，如果有，也被第一个<code>except</code>给捕获了。</p>

<p>Python所有的错误都是从<code>BaseException</code>类派生的，常见的错误类型和继承关系看这里：</p>

<p><img src="media/14928231077736/14928254735561.jpg" alt=""/></p>

<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()调用bar()，bar()调用foo()，结果foo()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理：</p>

<pre><code class="language-py">def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar(&#39;0&#39;)
    except StandardError, e:
        print &#39;Error!&#39;
    finally:
        print &#39;finally...&#39;

print main()

</code></pre>

<p><img src="media/14928231077736/14928272805670.jpg" alt=""/></p>

<p>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写<code>try...except...finally</code>的麻烦。</p>

<h3 id="toc_2">调用堆栈</h3>

<p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    bar(&#39;0&#39;)

main()
</code></pre>

<p><img src="media/14928231077736/14928281628836.jpg" alt=""/><br/>
出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链。</p>

<p>从上往下依次查看错误。</p>

<h3 id="toc_3">记录错误</h3>

<p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p>

<p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar(&#39;0&#39;)
    except StandardError as e:
        logging.exception(e)
    else:
        pass
    finally:
        pass
main()
print &#39;END&#39;
</code></pre>

<p><strong>同样是出错，但程序打印完错误信息后会继续执行，并正常退出</strong>：<br/>
<img src="media/14928231077736/14928284148150.jpg" alt=""/><br/>
最后打印出了“END”</p>

<p>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</p>

<h3 id="toc_4">抛出错误</h3>

<p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p>

<p>如果要抛出错误，首先根据需要，可以定义一个错误的<code>class</code>，选择好继承关系，然后，用<code>raise</code>语句抛出一个错误的实例</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class FooError(StandardError):
    pass

def foo(s):
    n = int(s)
    if n == 0:
        raise FooError(&#39;invaild value: %s&#39; % s)
    return 10/0
foo(0)
</code></pre>

<p><img src="media/14928231077736/14928288600479.jpg" alt=""/></p>

<p><strong>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。</strong></p>

<p>最后，我们来看另一种错误处理的方式：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
def foo(s):
    n = int(s)
    return 10 / n

def bar(s):
    try:
        return foo(s) * 2
    except StandardError, e:
        print &#39;Error!&#39;
        raise

def main():
    bar(&#39;0&#39;)

main()
</code></pre>

<p><img src="media/14928231077736/14928306395157.jpg" alt=""/></p>

<p>在bar()函数中，我们明明已经捕获了错误，但是，打印一个<code>Error</code>!后，又把错误通过<code>raise</code>语句抛出去了，这不有病么？</p>

<p>其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p>

<p>raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型：</p>

<pre><code class="language-py">try:
    10 / 0
except ZeroDivisionError:
    raise ValueError(&#39;input error!&#39;)
</code></pre>

<p>只要是合理的转换逻辑就可以，但是，决不应该把一个<code>IOError</code>转换成毫不相干的<code>ValueError</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用元类]]></title>
    <link href="https://lockxmonk.github.io/14927355881897.html"/>
    <updated>2017-04-21T08:46:28+08:00</updated>
    <id>https://lockxmonk.github.io/14927355881897.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">metaclass</a>
</li>
</ul>


<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是<strong>运行时动态创建的</strong>。</p>

<p>比方说我们要定义一个<code>Hello</code>的class：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Hello(object):
    def hello(self, name=&#39;world&#39;):
        print(&#39;Hello, %s.&#39; % name)
h = Hello()
h.hello()
print (type(Hello))
print (type(h))
</code></pre>

<p><img src="media/14927355881897/14927620006235.jpg" alt=""/></p>

<p><font color=red><strong><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个class，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是<code>class Hello</code>。</strong></font></p>

<p>我们说class的定义是运行时动态创建的，而<strong>创建class的方法就是使用<code>type()</code>函数</strong>。</p>

<p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，<strong>我们可以通过<code>type()</code>函数创建出Hello类，而无需通过<code>class Hello(object)...</code>的定义</strong>：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
def fn(self, name=&#39;world&#39;):   # 先定义函数
    print(&#39;Hello, %s.&#39; % name)

Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn))  # 创建Hello class
h = Hello()
h.hello()
print(type(Hello))
print(type(h))

</code></pre>

<p><img src="media/14927355881897/14927623112362.jpg" alt=""/></p>

<p><strong>要创建一个class对象，type()函数依次传入3个参数：</strong></p>

<ol>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li>
<li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li>
</ol>

<p>通过<code>type()</code>函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p>

<blockquote>
<p>正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
</blockquote>

<h2 id="toc_0">metaclass</h2>

<p>除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用metaclass。<br/>
简单的解释就是：先定义metaclass，就可以创建类，最后创建实例。</p>

<p>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</p>

<p><strong>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</strong></p>

<p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：</p>

<p>定义<code>ListMetaclass</code>，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

# metaclass是创建类，所以必须从`type`类型派生：
class ListMetaclass(type):

    def __new__(cls, name, bases, attrs):
        attrs[&#39;add&#39;] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)


class MyList(list):
    __metaclass__ = ListMetaclass  # 指示使用ListMetaclass来定制类
</code></pre>

<p>当我们写下<code>__metaclass__ = ListMetaclass</code>语句时，魔术就生效了，它指示Python解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>

<p><code>__new__()</code><strong>方法接收到的参数依次是</strong>：</p>

<ol>
<li><p>当前准备创建的类的对象；</p></li>
<li><p>类的名字；</p></li>
<li><p>类继承的父类集合；</p></li>
<li><p>类的方法集合。</p></li>
</ol>

<p>我们测试输出为：</p>

<pre><code class="language-py">L = MyList()
L.add(1)
print L
</code></pre>

<p><img src="media/14927355881897/14927637008533.jpg" alt=""/></p>

<p>动态修改有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。</p>

<p>但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。</p>

<p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</p>

<p>要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p>

<p>具体方法参见<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820064557c69858840b4c48d2b8411bc2ea9099ba000">廖老师的教学网站</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向对象高级编程]]></title>
    <link href="https://lockxmonk.github.io/14926766188460.html"/>
    <updated>2017-04-20T16:23:38+08:00</updated>
    <id>https://lockxmonk.github.io/14926766188460.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">使用__slots__</a>
</li>
<li>
<a href="#toc_1">使用@property</a>
</li>
<li>
<a href="#toc_2">多重继承</a>
<ul>
<li>
<a href="#toc_3">Mixin</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">定制类</a>
<ul>
<li>
<a href="#toc_5">__str__</a>
</li>
<li>
<a href="#toc_6">__iter__</a>
</li>
<li>
<a href="#toc_7">__getitem__</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">__getattr__</a>
</li>
<li>
<a href="#toc_9">__call__</a>
</li>
</ul>


<p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。</p>

<p><strong><em>我们可以动态的给某一个实例绑定属性、方法。要绑定该类所有的实例的话，则可以将方法绑定到该类上。</em></strong></p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Student(object):
    &quot;&quot;&quot;docstring for Student&quot;&quot;&quot;
    pass
s = Student()
s.name = &#39;梁中豪&#39;  # 动态给实例绑定一个属性

from types import MethodType


def set_age(self, age):  # 定义一个函数作为实例方法
    self.age = age
s.set_age = MethodType(set_age, s, Student)  # 给实例绑定一个方法
s.set_age(25)

# 为了给所有实例都绑定方法，可以给class绑定方法：


def set_score(self, score):  # 定义一个函数作为实例方法
    self.score = score
Student.set_score = MethodType(set_score, None, Student)
s.set_score(100) #给class绑定方法后，所有实例均可调用
s2 = Student()
s2.set_score(90)
print s.name, s.age, s.score, s2.score
</code></pre>

<p><img src="media/14926766188460/14926773474695.jpg" alt=""/></p>

<h2 id="toc_0">使用__slots__</h2>

<p>如果我们想要限制class的属性怎么办？比如，只允许对Student实例添加<code>name和age</code>属性。那么可以使用一个特殊的<code>__slots__</code>变量。</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Student(object):
    &quot;&quot;&quot;docstring for Student&quot;&quot;&quot;
    __slots__ = (&#39;name&#39;,&#39;age&#39;)
    
s = Student()
s.name = &#39;梁中豪&#39;
s.age = 21
print s.name, s.age
s.score = 90
print s.score

</code></pre>

<p><img src="media/14926766188460/14926779162430.jpg" alt=""/></p>

<p><font color=red>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类起作用，对继承的子类是不起作用的. 除非在子类中也定义<code>__slots__</code>，这样，子类允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。<br/>
</font></p>

<h2 id="toc_1">使用@property</h2>

<p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改。</p>

<p>这显然不合逻辑。为了限制score的范围，可以通过一个<code>set_score()</code>方法来设置成绩，再通过一个<code>get_score()</code>来获取成绩，这样，在<code>set_score()</code>方法里，就可以检查参数：</p>

<pre><code class="language-py">class Student(object):

    def get_score(self):
        return self._score

    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value
s = Student()
s.set_score(50)
s.get_score()
s.set_score(999)
s.get_score()
</code></pre>

<p><img src="media/14926766188460/14927376402165.jpg" alt=""/></p>

<p>上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p>

<p>对于类的方法，装饰器一样起作用。Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>

<pre><code class="language-py">
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value

s = Student
s.score = 60
print s.score
</code></pre>

<p><code>@property</code>的实现比较复杂，我们先考察如何使用。把一个<code>getter</code>方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个<code>setter</code>方法变成属性赋值</p>

<p>如果只定义getter方法，不定义setter方法就是一个只读属性：</p>

<pre><code class="language-py">class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2014 - self._birth
s = Student()
s.birth = 23
print s.birth
</code></pre>

<h2 id="toc_2">多重继承</h2>

<p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。</p>

<p>一个类可以继承多个类，称为多重继承，如下所示：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Animal(object):
    &quot;&quot;&quot;docstring for Animal&quot;&quot;&quot;
    pass


class Mammal(Animal):
    &quot;&quot;&quot;docstring for Mammal&quot;&quot;&quot;
    print &#39;Mammal&#39;


class Bird(Animal):
    &quot;&quot;&quot;docstring for Bird&quot;&quot;&quot;
    print &#39;Bird&#39;


class Runable(object):
    &quot;&quot;&quot;docstring for Runable&quot;&quot;&quot;

    def run(self):
        print &#39;Running...&#39;


class Flyable(object):
    &quot;&quot;&quot;docstring for Flyable&quot;&quot;&quot;

    def fly(self):
        print &#39;Flying...&#39;


class Dog(Mammal, Runable):
    &quot;&quot;&quot;docstring for Dog&quot;&quot;&quot;
    pass


class Bat(Mammal, Flyable):
    &quot;&quot;&quot;docstring for Bat&quot;&quot;&quot;
    pass
</code></pre>

<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>

<h3 id="toc_3">Mixin</h3>

<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<code>Mixin</code>。</p>

<p>为了更好地看出继承关系，我们把Runnable和Flyable改为<code>RunnableMixin</code>和<code>FlyableMixin</code>。类似的，你还可以定义出肉食动物<code>CarnivorousMixin</code>和植食动物<code>HerbivoresMixin</code>，让某个动物同时拥有好几个<code>Mixin</code>：</p>

<pre><code class="language-py">class Dog(Mammal, RunnableMixin, CarnivorousMixin):
    pass
</code></pre>

<p>由于Python允许使用多重继承，因此，Mixin就是一种常见的设计。</p>

<p><strong>只允许单一继承的语言（如Java）不能使用Mixin的设计</strong>。</p>

<h2 id="toc_4">定制类</h2>

<p>看到类似<code>__slots__</code>这种形如<code>__xxx__</code>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>

<p>类似有很多特殊变量来帮助我们定制类：</p>

<h3 id="toc_5">__str__</h3>

<p>我们先定义一个<code>Student</code>类，打印一个实例：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;
    def __init__(self, name):
        super(Students, self).__init__()
        self.name = name
print Students(&#39;LZH&#39;)
</code></pre>

<p><img src="media/14926766188460/14927559673818.jpg" alt=""/><br/>
得到上图所示，我们可以定制所打印的内容。</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;
    def __init__(self, name):
        super(Students, self).__init__()
        self.name = name
    def __str__(self):
        return &#39;Students object (name:%s)&#39; %self.name
print Students(&#39;LZH&#39;)
</code></pre>

<p><img src="media/14926766188460/14927560929527.jpg" alt=""/><br/>
这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。<br/>
当然这只是负责定制<code>print</code>方法输出的内容。直接敲变量不用<code>print</code>，打印出来的实例还是不好看。</p>

<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>

<pre><code class="language-py">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return &#39;Student object (name=%s)&#39; % self.name
    __repr__ = __str__  #因为两者方法几乎一样，所以可以直接偷懒将前者赋值给repr
</code></pre>

<h3 id="toc_6">__iter__</h3>

<p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list或tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>next()</code>方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>

<p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Fib(object):
    &quot;&quot;&quot;docstring for Fib&quot;&quot;&quot;

    def __init__(self):
        self.a, self.b = 0, 1  # 初始化两个计数器a，b

    def __iter__(self):
        return self  # 实例本身就是迭代对象，故返回自己

    def next(self):
        self.a, self.b = self.b, self.a + self.b
        if self.a &gt; 100:
            raise StopIteration()
        return self.a

for n in Fib():
    print n
</code></pre>

<p><img src="media/14926766188460/14927569583236.jpg" alt=""/></p>

<h3 id="toc_7">__getitem__</h3>

<p>上述要表现得像list那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

class Fib(object):
    &quot;&quot;&quot;docstring for Fib&quot;&quot;&quot;

    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        print a

f = Fib()
f[0]
f[2]
f[4]

</code></pre>

<p><img src="media/14926766188460/14927581032895.jpg" alt=""/></p>

<p>不能简单的直接执行切片方法，Fib会报错。原因是<code>__getitem__()</code>传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Fib(object):
    &quot;&quot;&quot;docstring for Fib&quot;&quot;&quot;

    def __getitem__(self, n):
        if isinstance(n, int):
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            print a
        if isinstance(n, slice):
            start = n.start
            stop = n.stop
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            print L

f = Fib()
f[5]
f[1:5]
</code></pre>

<p><img src="media/14926766188460/14927591015675.jpg" alt=""/></p>

<h2 id="toc_8">__getattr__</h2>

<p>当定义好一个类后，若实例调用一个不存在的属性，则会报错，但是我们可以运用<code>__getattr__</code>动态返回一个属性。例如：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Student(object):

    def __init__(self):
        self.name = &#39;Michael&#39;

    def __getattr__(self, attr):
        if attr==&#39;score&#39;:
            return 99

s = Student()
print s.name
print s.score
print s.age
</code></pre>

<p><img src="media/14926766188460/14927598715799.jpg" alt=""/><br/>
只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在<code>__getattr__</code>中查找。</p>

<p>此外，注意到任意调用如<code>s.age</code>都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。</p>

<p><strong>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。例如动态的拼接api接口：</strong></p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Chain(object):

    def __init__(self, path=&#39;&#39;):
        self._path = path

    def __getattr__(self, path):
        return Chain(&#39;%s/%s&#39; % (self._path, path))

    def __str__(self):
        return self._path
print Chain().status.user.timeline.list
print Chain(&#39;LZH&#39;).status.user.timeline.list
</code></pre>

<p><img src="media/14926766188460/14927597036919.jpg" alt=""/></p>

<h2 id="toc_9">__call__</h2>

<p>任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。请看示例：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;
    def __init__(self, name):
        super(Students, self).__init__()
        self.name = name
    def __call__(self):
        print (&#39;My name is %s.&#39; % self.name)

s = Students(&#39;LZH&#39;)
s()
</code></pre>

<p><img src="media/14926766188460/14927611817291.jpg" alt=""/></p>

]]></content>
  </entry>
  
</feed>
