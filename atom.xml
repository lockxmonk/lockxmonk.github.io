<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2018-01-06T09:59:12+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Where my anagrams at?]]></title>
    <link href="https://lockxmonk.github.io/15152183997863.html"/>
    <updated>2018-01-06T13:59:59+08:00</updated>
    <id>https://lockxmonk.github.io/15152183997863.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15152183997863/15152184280248.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *anagrams(NSString *s, NSArray *a) {
    NSMapTable *map = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableStrongMemory];
    for (int i = 0; i&lt;[s length]; i++) {
        NSString *str = [s substringWithRange:NSMakeRange(i, 1)];
        if ([map objectForKey:str]) {
            [map setObject:@([[map objectForKey:str] intValue]+1) forKey:str];
        }else{
            [map setObject:@(1) forKey:str];
        }
    }
    NSMutableArray *res = a.mutableCopy;
    for (NSString *ele in a) {
        if(ele.length!=s.length){
            [res removeObject:ele];
            continue;
        }
        NSMapTable *tmp = [map copy];
        for (int j=0; j&lt;[ele length]; j++) {
            NSString *tmpStr = [ele substringWithRange:NSMakeRange(j, 1)];
            if ([tmp objectForKey:tmpStr]) {
                int log =[[tmp objectForKey:tmpStr] intValue]-1;
                if (log&lt;0){
                    [res removeObject:ele];
                    break;
                }
                [tmp setObject:@(log) forKey:tmpStr];
            }else{
                [res removeObject:ele];
                break;
            }
        }
    }
    return res;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perimeter of squares in a rectangle]]></title>
    <link href="https://lockxmonk.github.io/15152039082618.html"/>
    <updated>2018-01-06T09:58:28+08:00</updated>
    <id>https://lockxmonk.github.io/15152039082618.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15152039082618/15152039109281.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

unsigned long long perimeter(int n) {
    NSMutableArray *numQu = @[@0,@1].mutableCopy;
    unsigned long long n0 = 0,n1=1;
    for (int i = 2; i&lt;=n+1; i++) {
        unsigned long long sum = n0+n1;
        n0 = n1;
        n1 = sum;
        [numQu addObject:@(sum)];
    }
    unsigned long long tol = 0;
    for (NSNumber* ele in numQu) {
        tol+=[ele unsignedLongLongValue];
    }
    return tol*4;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking遇到的问题]]></title>
    <link href="https://lockxmonk.github.io/15151211562254.html"/>
    <updated>2018-01-05T10:59:16+08:00</updated>
    <id>https://lockxmonk.github.io/15151211562254.html</id>
    <content type="html"><![CDATA[
<p>由于<code>AFNetworking</code>运用了官方<code>NSURLSession</code>所以其中有一些坑</p>

<h2 id="toc_0">1.苹果运用NSJSONSerialization解析，出现数字类型精度问题</h2>

<p>当服务器给我传回来一个<code>3.0</code>的数字类型时，在安卓端是没有问题的，但是在iOS这里会出现<code>2.99999</code>这样的问题。</p>

<p><font color=red><strong>出现这个问题的原因是：苹果在json解析时，默认为双精度的double类型。</strong></font></p>

<pre><code>我们相处的解决方案有两种：
1. 跟后台协商将数字型的值改为`字符型`
2. 使用第三方的json解析。
</code></pre>

<p>最后我们使用的是第一种方法，因为第二种势必要修改了AFNetwork的源码，开发与维护成本相比较来说要大。</p>

<h2 id="toc_1">2.json解析失败</h2>

<p>由于AF默认的解析方式为<code>0</code>（返回的对象是不可变的，<code>NSDictionary</code>或<code>NSArray</code>）：<br/>
<img src="media/15151211562254/15151222443779.jpg" alt=""/></p>

<p>我们来看一下都有什么选项：<br/>
<img src="media/15151211562254/15151222806031.jpg" alt=""/></p>

<p>所以当我们服务器返回的json数据是<strong>碎片化</strong>的（最外层既不是<code>NSArray</code>也不是<code>NSDictionary</code>），那么解析的时候就会出错了。</p>

<p>解决方法是：</p>

<p><img src="media/15151211562254/15151327758647.jpg" alt=""/><br/>
在0后添加<code>|</code>字符，增加这种情况，允许碎片化数据。</p>

<h2 id="toc_2">3. 请求后response的状态码范围问题</h2>

<p>正常项目中正常请求成功会返回200，但是服务器若是给你返回了500（我不知道后台为啥会返回这个码），问题就出现了：</p>

<p>这是由于下面的原因：<br/>
<img src="media/15151211562254/15151343155944.jpg" alt=""/><br/>
会发现上图中可接受状态码的范围是200-300；</p>

<p>具体解决方法就不说了。。。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1's, 0's and wildcards]]></title>
    <link href="https://lockxmonk.github.io/15145180239158.html"/>
    <updated>2017-12-29T11:27:03+08:00</updated>
    <id>https://lockxmonk.github.io/15145180239158.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15145180239158/15145180364703.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *changeTo(NSMutableArray*log, NSMutableArray*res){
    if (log.count&gt;0) {
        NSRange loc = {[[log lastObject] integerValue],1};
        NSMutableArray *cop = res.mutableCopy;
        for (NSString *tmp in res) {
            [cop addObject:[tmp stringByReplacingCharactersInRange:loc withString:@&quot;0&quot;]];
            [cop addObject:[tmp stringByReplacingCharactersInRange:loc withString:@&quot;1&quot;]];
            [cop removeObject:tmp];
        }
        [log removeLastObject];
        return changeTo(log, cop);
    }else{
        return res;
    }
}

NSArray *possibilities(NSString *s) {
    NSMutableArray *log = @[].mutableCopy;
    NSMutableArray *res = @[].mutableCopy;
    for (int i = 0; i&lt;s.length; i++) {
        if ([s characterAtIndex:i]==&#39;?&#39;) {
            [log addObject:@(i)];
        }
    }
    [res addObject:s];

    NSArray *tol = changeTo(log , res);
    
    return tol;
}
</code></pre>

<p>简化版：</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *possibilities(NSString *s) {
  // NSLog(@&quot;User `possibilities` accidentally invoked!\n&quot;);
  if ([s rangeOfString: @&quot;?&quot;].length == 0) return @[s];
  NSString *r = [s stringByReplacingOccurrencesOfString: @&quot;?&quot; withString: @&quot;0&quot; options: 0 range: [s rangeOfString: @&quot;?&quot;]], *t = [s stringByReplacingOccurrencesOfString: @&quot;?&quot; withString: @&quot;1&quot; options: 0 range: [s rangeOfString: @&quot;?&quot;]];
  return [possibilities(r) arrayByAddingObjectsFromArray: possibilities(t)];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Pig Latin]]></title>
    <link href="https://lockxmonk.github.io/15143494387976.html"/>
    <updated>2017-12-27T12:37:18+08:00</updated>
    <id>https://lockxmonk.github.io/15143494387976.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15143494387976/15143494406501.jpg" alt=""/></p>

<p>一开始的复杂版:</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSString *pigIt(NSString *s) {
    NSMutableArray *str = [s componentsSeparatedByString:@&quot; &quot;].mutableCopy;
    NSMutableString *res = @&quot;&quot;.mutableCopy;
    for (NSString *tmp in str) {
        unichar c = [tmp characterAtIndex:0];
        if ((c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)) {
            NSMutableString *change = tmp.mutableCopy;
            [change appendFormat:@&quot;%c&quot;,c];
            if ([tmp isEqualToString:[str lastObject]]) {
                [change appendString:@&quot;ay&quot;];
            }else{
                [change appendString:@&quot;ay &quot;];
            }
            [res appendString:[change substringFromIndex:1]];
        }else{
            [res appendFormat:@&quot;%c&quot;,c];
        }
    }
    return res;
}
</code></pre>

<p>简化版</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSString *pigIt(NSString *s) {
  NSMutableArray *result = [s componentsSeparatedByString: @&quot; &quot;];
  for (size_t i = 0; i &lt; [result count]; i++) result[i] = [[[result[i] substringFromIndex: 1] stringByAppendingString: [result[i] substringToIndex: 1]] stringByAppendingString: @&quot;ay&quot;];
  return [result componentsJoinedByString: @&quot; &quot;];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sum without highest and lowest number]]></title>
    <link href="https://lockxmonk.github.io/15143439533653.html"/>
    <updated>2017-12-27T11:05:53+08:00</updated>
    <id>https://lockxmonk.github.io/15143439533653.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15143439533653/15143439550035.jpg" alt=""/></p>

<pre><code class="language-objc">int sum(int* numbers, int numbersCount)
{
    if(numbersCount&lt;=1) return 0;
    int min = INT_MAX;
    int max = INT_MIN;
    int sum = 0;
    for (int i = 0; i&lt;numbersCount; i++)
    {
        if(numbers[i]&gt;max) max = numbers[i];
        if(numbers[i]&lt;min) min = numbers[i];
        sum+= numbers[i];
    }
    return sum-min-max;
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find the missing term in an Arithmetic Progression]]></title>
    <link href="https://lockxmonk.github.io/15142765984953.html"/>
    <updated>2017-12-26T16:23:18+08:00</updated>
    <id>https://lockxmonk.github.io/15142765984953.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15142765984953/15142766000094.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSNumber *findMissing(NSArray *list) {
    int len = [list count];
    int n = len+1;
    int d1 = [list[1] intValue]-[list[0] intValue];
    int d2 = [list[len-1] intValue]-[list[len-2] intValue];
    int d = 0;
    if (d1&lt;0) {
        d = d1&gt;d2?d1:d2;
    }else{
        d = d1&lt;d2?d1:d2;
    }
    if (n == 3) {
        return @(([[list firstObject] intValue]+[[list lastObject] intValue])/2);
    }
    int num = [[list firstObject] intValue];
    for (int i = 0;i&lt;len;i++) {
        if ([list[i] intValue]!=num) {
            return @(num);
        }
        num+=d;
    }
    
    return @(0);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Valid Parentheses]]></title>
    <link href="https://lockxmonk.github.io/15141803762335.html"/>
    <updated>2017-12-25T13:39:36+08:00</updated>
    <id>https://lockxmonk.github.io/15141803762335.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15141803762335/15141803778513.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

bool validParentheses(NSString *s) {
    // TODO: Return a boolean value indicating whether the
    // order of parentheses in the given string is valid
    if (s.length==0) {
        return 0;
    }
    int sum = 0;
    NSMutableArray *res = @[].mutableCopy;
    for (int i = 0; i&lt;s.length; i++) {
        if ([s characterAtIndex:i]==(unichar)&#39;(&#39;) {
            [res addObject:@(&#39;(&#39;)];
            sum++;
        }
        if ([s characterAtIndex:i]==(unichar)&#39;)&#39;) {
            if ([[res lastObject] isEqual:@(&#39;(&#39;)]) {
                [res removeObjectAtIndex:res.count-1];
            }else{
                [res addObject:@(&#39;)&#39;)];
            }
            sum--;
        }
    }
    if (sum!=0||[res count]!=0) {
        return 0;
    }
    return 1;
}
</code></pre>

<p>简化版：</p>

<pre><code class="language-objc">
#import &lt;Foundation/Foundation.h&gt;

bool validParentheses(NSString *s) {
  int brackets = 0;
  for (int i = 0; i &lt; [s length]; i++) {
    if ([s characterAtIndex: i] == &#39;(&#39;) brackets++;
    else if ([s characterAtIndex: i] == &#39;)&#39;) if (--brackets &lt; 0) return false;
  }
  return !brackets;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Follow that Spy]]></title>
    <link href="https://lockxmonk.github.io/15140206056964.html"/>
    <updated>2017-12-23T17:16:45+08:00</updated>
    <id>https://lockxmonk.github.io/15140206056964.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15140206056964/15140206079284.jpg" alt=""/></p>

<p>自己的麻烦些的代码：用了<code>NSMapTable</code></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;
NSString *findRoutes(NSArray *routes){
    if ([routes count]==1) {
        return [NSString stringWithFormat:@&quot;%@, %@&quot;,routes[0][0],routes[0][1]];
    }
    NSMapTable *map = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableWeakMemory];
    NSMapTable *tol = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableWeakMemory];
    for (NSArray *tmp in routes) {
        [map setObject:tmp[1] forKey:tmp[0]];
        for (NSString* tmpTol in tmp) {
            if ([tol objectForKey:tmpTol]) {
                [tol setObject:@&quot;1&quot; forKey:tmpTol];
            }else{
                [tol setObject:@&quot;0&quot; forKey:tmpTol];
            }
        }
    }
    NSString *str = @&quot;&quot;;
    NSString *end = @&quot;&quot;;
    NSEnumerator *enumerator = [tol keyEnumerator];
    for (NSString *tmp in enumerator) {
        if ([[tol objectForKey:tmp] isEqualToString:@&quot;0&quot;]) {
            if (![map objectForKey:tmp]) {
                end = tmp;
                continue;
            }
            str = tmp;
        }
    }
    NSString *res = @&quot;&quot;;
    res = [res stringByAppendingFormat:@&quot;%@, &quot;, str];
    while ([map objectForKey:str]) {
       res =  [res stringByAppendingFormat:@&quot;%@, &quot;, [map objectForKey:str]];
       str = [map objectForKey:str];
        if ([[map objectForKey:str] isEqualToString:end]) {
            res = [res stringByAppendingString:end];
            break;
        }
    }
    return res;
}
</code></pre>

<p>别人的简短代码：</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;
NSString *findRoutes(NSArray *routes){

    NSMutableArray * routesM = [routes mutableCopy];
    NSMutableArray * answer = [@[routes[0][0]] mutableCopy];
    do{
        for(int i = (int)routesM.count - 1; i &gt;= 0; i--){
            if([[answer lastObject] isEqualToString:routesM[i][0]]){
                [answer addObject:routesM[i][1]];
                [routesM removeObjectAtIndex:i];
            } else if([[answer firstObject] isEqualToString:routesM[i][1]]){
                [answer insertObject:routesM[i][0] atIndex:0];
                [routesM removeObjectAtIndex:i];
            }
        }
    } while (routesM.count &gt; 0);
    return [answer componentsJoinedByString:@&quot;, &quot;];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Fun #4: Phone Call]]></title>
    <link href="https://lockxmonk.github.io/15140141868103.html"/>
    <updated>2017-12-23T15:29:46+08:00</updated>
    <id>https://lockxmonk.github.io/15140141868103.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15140141868103/15140147655873.jpg" alt=""/><br/>
<img src="media/15140141868103/15140147745826.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;
int phoneCall(int min1, int min2_10, int min11, int s) {
    if (s&lt;min1) return 0;
    int sum = 1;
    sum+= (s-min1)&gt;min2_10*9 ? 9 : (s-min1)/min2_10;
    sum+= (s-min1-9*min2_10)&lt;0 ? 0 : (s-min1-9*min2_10)/min11;
    return sum;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't give me five!]]></title>
    <link href="https://lockxmonk.github.io/15140137962108.html"/>
    <updated>2017-12-23T15:23:16+08:00</updated>
    <id>https://lockxmonk.github.io/15140137962108.html</id>
    <content type="html"><![CDATA[
<p>Don&#39;t give me five!</p>

<p>In this kata you get the start number and the end number of a region and should return the count of all numbers except numbers with a 5 in it. The start and the end number are both inclusive!</p>

<p>Examples:</p>

<pre><code>1,9 -&gt; 1,2,3,4,6,7,8,9 -&gt; Result 8
4,17 -&gt; 4,6,7,8,9,10,11,12,13,14,16,17 -&gt; Result 12
</code></pre>

<p>The result may contain fives. ;-)<br/>
The start number will always be smaller than the end number. Both numbers can be also negative!</p>

<p>I&#39;m very curious for your solutions and the way you solve it. Maybe someone of you will find an easy pure mathematics solution.</p>

<p>Have fun coding it and please don&#39;t forget to vote and rank this kata! :-)</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;
int dontGiveMeFive(int start, int end)
{
  int sum = 0;
    for (int i = start; i&lt;=end; i++) {
        if ([[NSString stringWithFormat:@&quot;%i&quot;,i] rangeOfString:@&quot;5&quot;].location!=NSNotFound) {
            continue;
        }
        sum++;
    }
    return sum;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Moves in squared strings (I)]]></title>
    <link href="https://lockxmonk.github.io/15139993814636.html"/>
    <updated>2017-12-23T11:23:01+08:00</updated>
    <id>https://lockxmonk.github.io/15139993814636.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15139993814636/15139993826350.jpg" alt=""/><br/>
<img src="media/15139993814636/15139994003399.jpg" alt=""/></p>

<p>题目链接：<a href="https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc">https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc</a></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSString *vertMirror(NSString *strng) {
    NSMutableString *res = [[NSMutableString alloc] init];
    NSArray *stringArray = [strng componentsSeparatedByString:@&quot;\n&quot;];
    for (NSString *tmpStr in stringArray) {
        NSMutableString * reverseString = [NSMutableString string];
        for(int i = 0 ; i &lt; tmpStr.length; i ++){
            //倒序读取字符并且存到可变数组数组中
            unichar c = [tmpStr characterAtIndex:tmpStr.length- i -1];
            [reverseString appendFormat:@&quot;%c&quot;,c];
        }
        
        if ([tmpStr isEqualToString:[stringArray lastObject]]) {
            [res appendString:reverseString];
            break;
        }
        
        [reverseString appendString:@&quot;\n&quot;];
        [res appendString:reverseString];
    }
    
    return res;
}

NSString *horMirror(NSString *strng) {
    NSMutableString *res = [[NSMutableString alloc] init];;
    NSArray *stringAry = [strng componentsSeparatedByString:@&quot;\n&quot;];
    for (int i = stringAry.count-1; i&gt;=0; i--) {
        [res appendString:stringAry[i]];
        if (i==0) {
            break;
        }
        [res appendString:@&quot;\n&quot;];
    }
    return res;
}

NSString *oper(NSString *(*f)(NSString *), NSString *s) {
    return f(s);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sum of many ints]]></title>
    <link href="https://lockxmonk.github.io/15139938131506.html"/>
    <updated>2017-12-23T09:50:13+08:00</updated>
    <id>https://lockxmonk.github.io/15139938131506.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15139938131506/15139938214932.jpg" alt=""/></p>

<p>题目链接：<a href="https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc">https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc</a></p>

<p>注意<code>long long</code>类型。</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

long long f(long long n, long long m) {
    long long sum = 0;
    long long q = n/m;
    long long p = n%m;
    sum+= (m*(m-1)/2)*q;
    sum+= (p+1)*p/2;
    return sum;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ Longest Univalue Path]]></title>
    <link href="https://lockxmonk.github.io/15139334894228.html"/>
    <updated>2017-12-22T17:04:49+08:00</updated>
    <id>https://lockxmonk.github.io/15139334894228.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15139334894228/15139334918786.jpg" alt=""/></p>

<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int dfs(TreeNode* node, int&amp; lup) {
        int l = node-&gt;left ? dfs(node-&gt;left, lup) : 0;
        int r = node-&gt;right ? dfs(node-&gt;right, lup) : 0;
        int resl = node-&gt;left &amp;&amp; node-&gt;left-&gt;val == node-&gt;val ? l + 1 : 0;
        int resr = node-&gt;right &amp;&amp; node-&gt;right-&gt;val == node-&gt;val ? r + 1 : 0;
        lup = max(lup, resl + resr);
        return max(resl, resr);
    }

    int longestUnivaluePath(TreeNode* root) {
        int lup = 0;
        if (root) dfs(root, lup);
        return lup;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Isomorphic Strings]]></title>
    <link href="https://lockxmonk.github.io/15137396102567.html"/>
    <updated>2017-12-20T11:13:30+08:00</updated>
    <id>https://lockxmonk.github.io/15137396102567.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15137396102567/15137396123443.jpg" alt=""/></p>

<p>一开始写的代码，超时版本，用的集合。</p>

<pre><code class="language-c++">bool isIsomorphic(string s, string t) {
    unordered_map&lt;char, set&lt;int&gt;&gt; Smap;
    unordered_map&lt;char, vector&lt;int&gt;&gt; Tmap;
    for (int i = 0; i&lt;s.size(); i++) {
        Smap[s[i]].insert(i);
        Tmap[t[i]].push_back(i);
    }
    if (Smap.size()!=Tmap.size()) {
        return 0;
    }else{
        for (int j = 0; j&lt;s.size(); j++) {
            vector&lt;int&gt; a = Tmap[t[j]];
            set&lt;int&gt; b = Smap[s[j]];
            int len = b.size();
            for (auto num : a) {
                b.insert(num);
                if (len!=b.size()) {
                    return 0;
                }
            }
        }
    }
    
    return 1;
}
</code></pre>

<p>修改后的版本。</p>

<pre><code class="language-c++">class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int m1[256] = {0}, m2[256] = {0}, n = s.size();
        for (int i = 0; i &lt; n; ++i) {
            if (m1[s[i]] != m2[t[i]]) return false;  //判断两个字符串i位置的字符上次出现的位置是否一样。
            m1[s[i]] = i + 1;   //记录上次该字符出现的位置
            m2[t[i]] = i + 1;   //记录上次该字符出现的位置
        }
        return true;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Path Sum II]]></title>
    <link href="https://lockxmonk.github.io/15136732474119.html"/>
    <updated>2017-12-19T16:47:27+08:00</updated>
    <id>https://lockxmonk.github.io/15136732474119.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15136732474119/15136732503183.jpg" alt=""/></p>

<p>运用前序遍历</p>

<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void findPaths(TreeNode* node, int sum, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt; &gt;&amp; paths) {
        if (!node) return;
        path.push_back(node -&gt; val);
        if (!(node -&gt; left) &amp;&amp; !(node -&gt; right) &amp;&amp; sum == node -&gt; val)
            paths.push_back(path);
        findPaths(node -&gt; left, sum - node -&gt; val, path, paths);
        findPaths(node -&gt; right, sum - node -&gt; val, path, paths);
        path.pop_back();
    }

    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
        vector&lt;vector&lt;int&gt; &gt; paths;
        vector&lt;int&gt; path;
        findPaths(root, sum, path, paths);
        return paths;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Path Sum]]></title>
    <link href="https://lockxmonk.github.io/15136718150164.html"/>
    <updated>2017-12-19T16:23:35+08:00</updated>
    <id>https://lockxmonk.github.io/15136718150164.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15136718150164/15136718241722.jpg" alt=""/></p>

<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if (root == NULL) return false;
        if (root-&gt;val == sum &amp;&amp; root-&gt;left ==  NULL &amp;&amp; root-&gt;right == NULL) return true;
        
        return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linked List Cycle II]]></title>
    <link href="https://lockxmonk.github.io/15134129335933.html"/>
    <updated>2017-12-16T16:28:53+08:00</updated>
    <id>https://lockxmonk.github.io/15134129335933.html</id>
    <content type="html"><![CDATA[
<p>题目链接：<a href="https://leetcode.com/problems/linked-list-cycle-ii/description/">https://leetcode.com/problems/linked-list-cycle-ii/description/</a></p>

<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>

<p>Note: Do not modify the linked list.</p>

<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (head==NULL||head-&gt;next==NULL) {
            return NULL;
        }
        ListNode *slow = head;
        ListNode *fast = head;
        ListNode *entry = head;
        while (fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next) {
            fast = fast-&gt;next-&gt;next;
            slow = slow-&gt;next;
            if (fast==slow) {
                while (slow!=entry) {
                    slow = slow-&gt;next;
                    entry = entry-&gt;next;
                }
                return entry;;
            }
        }
        return NULL;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linked List Cycle]]></title>
    <link href="https://lockxmonk.github.io/15134088955356.html"/>
    <updated>2017-12-16T15:21:35+08:00</updated>
    <id>https://lockxmonk.github.io/15134088955356.html</id>
    <content type="html"><![CDATA[
<p>Given a linked list, determine if it has a cycle in it.</p>

<p>Follow up:<br/>
Can you solve it without using extra space?</p>

<p><strong>使用快慢两个指针来判断是否有环，当有环的时候，快指针会停留在环内知道慢指针赶上与之相等。</strong></p>

<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (head==NULL||head-&gt;next==NULL) {
            return 0;
        }
        ListNode *slow = head;
        ListNode *fast = head;
        while (fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next) {
            fast = fast-&gt;next-&gt;next;
            slow = slow-&gt;next;
            if (fast==slow) {
                return 1;
            }
        }
        return 0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ Convert a Number to Hexadecimal]]></title>
    <link href="https://lockxmonk.github.io/15131536329153.html"/>
    <updated>2017-12-13T16:27:12+08:00</updated>
    <id>https://lockxmonk.github.io/15131536329153.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15131536329153/15131536540833.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string toHex(int num) {
        const string HEX =&quot;0123456789abcdef&quot;;
        if (num==0) return &quot;0&quot;;
        string res =&quot;&quot;;
        int count  = 0;
        while (num&amp;&amp;count++&lt;8) {
            //&amp;0xf表示取二进制的低四位
            res = HEX[(num&amp;0xf)]+res;
            num&gt;&gt;=4;
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
</feed>
