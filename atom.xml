<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2017-12-08T21:49:54+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Relative Ranks]]></title>
    <link href="https://lockxmonk.github.io/15128072112005.html"/>
    <updated>2017-12-09T16:13:31+08:00</updated>
    <id>https://lockxmonk.github.io/15128072112005.html</id>
    <content type="html"><![CDATA[
<p>Given scores of <strong>N</strong> athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;.</p>

<p><img src="media/15128072112005/15128073582183.jpg" alt=""/></p>

<p><code>pair</code>的用法和优先队列的使用</p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) {
        priority_queue&lt;pair&lt;int,int&gt; &gt; pq;
        for(int i=0;i&lt;nums.size();i++)
        {
            pq.push(make_pair(nums[i],i));
        }
        vector&lt;string&gt; res(nums.size(),&quot;&quot;);
        int count = 1;
        for(int i=0; i&lt;nums.size();i++)
        {
            if(count==1) {res[pq.top().second] = &quot;Gold Medal&quot;; count++;}
            else if(count==2) {res[pq.top().second] = &quot;Silver Medal&quot;; count++;}
            else if(count==3) {res[pq.top().second] = &quot;Bronze Medal&quot;; count++;}
            else {res[pq.top().second] = to_string(count); count++;}
            pq.pop();
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Valid Anagram]]></title>
    <link href="https://lockxmonk.github.io/15128043838038.html"/>
    <updated>2017-12-09T15:26:23+08:00</updated>
    <id>https://lockxmonk.github.io/15128043838038.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15128043838038/15128043943990.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.length() != t.length()) return false;
        unordered_map&lt;char, int&gt; map;
        for (int i =0; i&lt;s.length(); i++) {
            map[s[i]]++;
            map[t[i]]--;
        }
        for(auto s:map){
            if(s.second&lt;0) return 0;
        }
        return 1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Assign Cookies]]></title>
    <link href="https://lockxmonk.github.io/15128026901484.html"/>
    <updated>2017-12-09T14:58:10+08:00</updated>
    <id>https://lockxmonk.github.io/15128026901484.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15128026901484/15128027017206.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int logG=0;
        for (int i=0; i&lt;s.size(); i++) {
            if (g[logG]&lt;=s[i]&amp;&amp;logG&lt;g.size()) {
                logG++;
            }
        }
        return logG;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ransom Note]]></title>
    <link href="https://lockxmonk.github.io/15128009688279.html"/>
    <updated>2017-12-09T14:29:28+08:00</updated>
    <id>https://lockxmonk.github.io/15128009688279.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15128009688279/15128009813033.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map&lt;char, int&gt; map;
        for (int i = 0; i&lt;magazine.length(); i++) {
            map[magazine[i]]++;
        }
        for (int j = 0; j&lt;ransomNote.length(); j++) {
            if(--map[ransomNote[j]]&lt;0) return 0;
        }
        return 1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reverse String II]]></title>
    <link href="https://lockxmonk.github.io/15127898937133.html"/>
    <updated>2017-12-09T11:24:53+08:00</updated>
    <id>https://lockxmonk.github.io/15127898937133.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127898937133/15127899074799.jpg" alt=""/></p>

<p>运用内置的<code>reverse</code>函数</p>

<pre><code class="language-c++">class Solution {
public:
    string reverseStr(string s, int k) {
        for (int i = 0; i&lt;s.length(); i+=2*k) {
            reverse(s.begin()+i, min(s.begin()+i+k, s.end()));
        }
        return s;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Base 7]]></title>
    <link href="https://lockxmonk.github.io/15127884486398.html"/>
    <updated>2017-12-09T11:00:48+08:00</updated>
    <id>https://lockxmonk.github.io/15127884486398.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127884486398/15127884572899.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string convertToBase7(int num) {
        int x = abs(num); string res;
        do {
          res = to_string(x%7)+res;
        } while (x/=7);
        
        return (num&gt;=0? &quot;&quot; : &quot;-&quot;) + res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[License Key Formatting]]></title>
    <link href="https://lockxmonk.github.io/15127864249320.html"/>
    <updated>2017-12-09T10:27:04+08:00</updated>
    <id>https://lockxmonk.github.io/15127864249320.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127864249320/15127864500019.jpg" alt=""/></p>

<p>第一版：</p>

<pre><code class="language-c++">    int log = 0;
    string ele=&quot;&quot;;
    string re=&quot;&quot;;
    for (int i = S.length()-1; i&gt;=0; i--) {
        if (S[i]!=&#39;-&#39;) {
            log++;
            S[i]=toupper(S[i]);
            ele = S[i]+ele;
        }
        if (log==K||i==0) {
            if (i==0) {
                re = ele+re;
            }else{
                re = &#39;-&#39;+ele+re;
            }
            log = 0;
            ele = &quot;&quot;;
        }
    }
    return re[0]==&#39;-&#39;?re.substr(1,re.length()-1):re;
</code></pre>

<p>第二版：运用栈</p>

<pre><code class="language-c++">class Solution {
public:
    string licenseKeyFormatting(string S, int K) {
        stack&lt;string&gt; st;
        string line;
        for(int i=S.length()-1;i&gt;=0;i--){
            if(S[i]==&#39;-&#39;) continue;
            
            if(line.length()&lt;K){
                if(S[i]&gt;=&#39;a&#39; &amp;&amp; S[i]&lt;=&#39;z&#39;) line.insert(0, 1, S[i]-&#39;a&#39;+&#39;A&#39;);
                else line.insert(0, 1, S[i]);
                
                if(line.length()==K){
                    st.push(line);
                    line=&quot;&quot;;
                }
            }
        }
        if(st.empty()) return line;
        
        if(line.length() == 0){
            line += st.top();
            st.pop();
        }
        while(!st.empty()){
            line+=&#39;-&#39;;
            line+=st.top();
            st.pop();
        }
        return line;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Happy Number]]></title>
    <link href="https://lockxmonk.github.io/15127409536382.html"/>
    <updated>2017-12-08T21:49:13+08:00</updated>
    <id>https://lockxmonk.github.io/15127409536382.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127409536382/15127409821970.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int happy(int num){
        int a = 0;
        while (num!=0) {
            a += int(pow(num%10, 2));
            num/=10;
        }
        return a;
    }


    bool isHappy(int n) {
        int slow, fast;
        slow = fast = n;
        do {
            slow = happy(slow);
            fast = happy(fast);
            fast = happy(fast);
        } while(slow != fast);

        return slow==1?1:0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find the Difference]]></title>
    <link href="https://lockxmonk.github.io/15127221024719.html"/>
    <updated>2017-12-08T16:35:02+08:00</updated>
    <id>https://lockxmonk.github.io/15127221024719.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127221024719/15127221121271.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    char findTheDifference(string s, string t) {
        char sum = 0;
        for (char c: s) {
            sum^=c;
        }
        for (char c: t) {
            sum^=c;
        }
        return sum;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distribute Candies]]></title>
    <link href="https://lockxmonk.github.io/15127198152754.html"/>
    <updated>2017-12-08T15:56:55+08:00</updated>
    <id>https://lockxmonk.github.io/15127198152754.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127198152754/15127198177167.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int distributeCandies(vector&lt;int&gt;&amp; candies) {
        int res = 0;
        unordered_map&lt;int, vector&lt;int&gt;&gt; map;
        for (int i =0; i&lt;candies.size(); i++) {
            map[candies[i]].push_back(candies[i]);
        }
        if (map.size()&lt;=candies.size()/2) {
            return map.size();
        }else{
            return candies.size()/2;
        }
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fizz Buzz]]></title>
    <link href="https://lockxmonk.github.io/15127166881202.html"/>
    <updated>2017-12-08T15:04:48+08:00</updated>
    <id>https://lockxmonk.github.io/15127166881202.html</id>
    <content type="html"><![CDATA[
<p>Write a program that outputs the string representation of numbers from 1 to n.</p>

<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>

<p><img src="media/15127166881202/15127167059726.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; fizzBuzz(int n) {
        vector&lt;string&gt; res;
        for (int i=1; i&lt;=n; i++) {
            if (i%3==0&amp;&amp;i%5==0) {
                res.push_back(&quot;FizzBuzz&quot;);
            }else if (i%5==0){
                res.push_back(&quot;Buzz&quot;);
            }else if(i%3==0){
                res.push_back(&quot;Fizz&quot;);
            }else{
                res.push_back(to_string(i));
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sum of Two Integers]]></title>
    <link href="https://lockxmonk.github.io/15127150080101.html"/>
    <updated>2017-12-08T14:36:48+08:00</updated>
    <id>https://lockxmonk.github.io/15127150080101.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127150080101/15127150099516.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int getSum(int a, int b) {
        int sum = a;
        while (b!=0) {
            sum = a^b;
            b = (a&amp;b)&lt;&lt;1;
            a = sum;
        }
        return a;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Employee Importance]]></title>
    <link href="https://lockxmonk.github.io/15127074753393.html"/>
    <updated>2017-12-08T12:31:15+08:00</updated>
    <id>https://lockxmonk.github.io/15127074753393.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127074753393/15127075000371.jpg" alt=""/></p>

<pre><code class="language-c++">/*
// Employee info
class Employee {
public:
    // It&#39;s the unique ID of each node.
    // unique id of this employee
    int id;
    // the importance value of this employee
    int importance;
    // the id of direct subordinates
    vector&lt;int&gt; subordinates;
};
*/
class Solution {
public:
    int getImportance(vector&lt;Employee*&gt; employees, int id) {
        unordered_map&lt;int ,Employee*&gt; map;
        for(auto emp:employees){
            map[emp-&gt;id] = emp;
        }
        return help(map,id);
    }
    
    int help(unordered_map&lt;int, Employee*&gt;&amp; map, int id){
        int sum = map[id]-&gt;importance;
        for(auto element : map[id]-&gt;subordinates){
            sum += help(map, element);
        }
        return sum;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Single Number]]></title>
    <link href="https://lockxmonk.github.io/15127037334925.html"/>
    <updated>2017-12-08T11:28:53+08:00</updated>
    <id>https://lockxmonk.github.io/15127037334925.html</id>
    <content type="html"><![CDATA[
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>

<pre><code class="language-c++">class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        for (int i =0; i&lt;nums.size(); i++) {
            if (nums[i]!=nums[i+1]) {
                return nums[i];
            }else{
                i++;
            }
        }
        return -1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nim Game]]></title>
    <link href="https://lockxmonk.github.io/15126366447476.html"/>
    <updated>2017-12-07T16:50:44+08:00</updated>
    <id>https://lockxmonk.github.io/15126366447476.html</id>
    <content type="html"><![CDATA[
<p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>

<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>

<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>

<p>列举1~n情况，每4个一循环.</p>

<pre><code class="language-c++">class Solution {
public:
    bool canWinNim(int n) {
        return n%4!=0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next Greater Element I]]></title>
    <link href="https://lockxmonk.github.io/15126354530210.html"/>
    <updated>2017-12-07T16:30:53+08:00</updated>
    <id>https://lockxmonk.github.io/15126354530210.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15126354530210/15126354552862.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; res;
        for(auto num1:findNums){
            for (int i = 0; i&lt;nums.size(); i++) {
                int log = 0;
                if (nums[i]==num1) {
                    for (int j = i; j&lt;nums.size(); j++) {
                        if (nums[j]&gt;num1) {
                            res.push_back(nums[j]);
                            log = 1;
                            break;
                        }
                    }
                    if (log == 0) res.push_back(-1);
                    break;
                }
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Island Perimeter]]></title>
    <link href="https://lockxmonk.github.io/15126325722591.html"/>
    <updated>2017-12-07T15:42:52+08:00</updated>
    <id>https://lockxmonk.github.io/15126325722591.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15126325722591/15126325750006.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int squNum = 0 ,log = 0;
        for (int i = 0; i&lt;grid.size(); i++) {
            for (int j = 0; j&lt;grid[0].size(); j++) {
                if (grid[i][j]==1) {
                    squNum++;
                    if (i!=0&amp;&amp;grid[i-1][j]==1) {
                        log+=2;
                    }
                    if (j!=grid[0].size()-1&amp;&amp;grid[i][j+1]==1) {
                        log+=2;
                    }
                }
            }
        }
        return squNum*4-log;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hamming Distance]]></title>
    <link href="https://lockxmonk.github.io/15126119727244.html"/>
    <updated>2017-12-07T09:59:32+08:00</updated>
    <id>https://lockxmonk.github.io/15126119727244.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15126119727244/15126119824070.jpg" alt=""/></p>

<p>利用按位异或操作<code>^</code>来标记不同的位置。<br/>
<code>c++<br/>
class Solution {<br/>
public:<br/>
    int hammingDistance(int x, int y) {<br/>
        int tmp = x^y;<br/>
        int res = 0;<br/>
        while (tmp) {<br/>
            if ((tmp&gt;&gt;1)&lt;&lt;1!=tmp) {<br/>
                res++;<br/>
            }<br/>
            tmp&gt;&gt;=1;<br/>
        }<br/>
        return res;<br/>
    }<br/>
};<br/>
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keyboard Row]]></title>
    <link href="https://lockxmonk.github.io/15125498375074.html"/>
    <updated>2017-12-06T16:43:57+08:00</updated>
    <id>https://lockxmonk.github.io/15125498375074.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15125498375074/15125498549999.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) {
        set&lt;char&gt; row1 = {&#39;q&#39;, &#39;w&#39;, &#39;e&#39;, &#39;r&#39;, &#39;t&#39;, &#39;y&#39;,&#39;u&#39;, &#39;i&#39;, &#39;o&#39;, &#39;p&#39;};
        set&lt;char&gt; row2 = {&#39;a&#39;, &#39;s&#39;, &#39;d&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;};
        set&lt;char&gt; row3 = { &#39;z&#39;, &#39;x&#39;, &#39;c&#39;, &#39;v&#39;, &#39;b&#39; ,&#39;n&#39;, &#39;m&#39;};
        vector&lt;set&lt;char&gt;&gt; rows = {row1,row2,row3};
        vector&lt;string&gt; res;
        for (auto str: words) {
            int log = 0;
            for (int i = 0; i&lt;rows.size(); i++) {
                if (rows[i].count((char)tolower(str[0]))&gt;0) {
                    log = i;
                }
            }
            for (int j = 0; j&lt;str.length(); j++) {
                if (rows[log].count((char)tolower(str[j]))==0) {
                    break;
                }
                if (j==str.length()-1) {
                    res.push_back(str);
                }
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Repeated String Match]]></title>
    <link href="https://lockxmonk.github.io/15125446581353.html"/>
    <updated>2017-12-06T15:17:38+08:00</updated>
    <id>https://lockxmonk.github.io/15125446581353.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15125446581353/15125446683319.jpg" alt=""/></p>

<p>要考虑<code>&quot;abc&quot; &quot;abc&quot; &quot;abc&quot;</code>和<code>&quot;c abc a&quot;</code>的情况，所以<code>i&lt;=lenB/lenA+2</code><br/>
<code>c++<br/>
class Solution {<br/>
public:<br/>
    int repeatedStringMatch(string A, string B) {<br/>
        int lenA = A.length(),lenB = B.length();<br/>
        string tmp = A;<br/>
        for (int i = 1; i&lt;=lenB/lenA+2; i++ , tmp+=A) {<br/>
            if (tmp.find(B)!=string::npos) {<br/>
                return i;<br/>
            }<br/>
        }<br/>
        return -1;<br/>
    }<br/>
};<br/>
</code></p>

]]></content>
  </entry>
  
</feed>
