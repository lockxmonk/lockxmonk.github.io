<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2017-12-12T15:08:14+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[![](media/15139993814636/15139993826350.jpg)]]></title>
    <link href="https://lockxmonk.github.io/15139993814636.html"/>
    <updated>2017-12-23T11:23:01+08:00</updated>
    <id>https://lockxmonk.github.io/15139993814636.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15139993814636/15139994003399.jpg" alt=""/></p>

<p>题目链接：<a href="https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc">https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc</a></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSString *vertMirror(NSString *strng) {
    NSMutableString *res = [[NSMutableString alloc] init];
    NSArray *stringArray = [strng componentsSeparatedByString:@&quot;\n&quot;];
    for (NSString *tmpStr in stringArray) {
        NSMutableString * reverseString = [NSMutableString string];
        for(int i = 0 ; i &lt; tmpStr.length; i ++){
            //倒序读取字符并且存到可变数组数组中
            unichar c = [tmpStr characterAtIndex:tmpStr.length- i -1];
            [reverseString appendFormat:@&quot;%c&quot;,c];
        }
        
        if ([tmpStr isEqualToString:[stringArray lastObject]]) {
            [res appendString:reverseString];
            break;
        }
        
        [reverseString appendString:@&quot;\n&quot;];
        [res appendString:reverseString];
    }
    
    return res;
}

NSString *horMirror(NSString *strng) {
    NSMutableString *res = [[NSMutableString alloc] init];;
    NSArray *stringAry = [strng componentsSeparatedByString:@&quot;\n&quot;];
    for (int i = stringAry.count-1; i&gt;=0; i--) {
        [res appendString:stringAry[i]];
        if (i==0) {
            break;
        }
        [res appendString:@&quot;\n&quot;];
    }
    return res;
}

NSString *oper(NSString *(*f)(NSString *), NSString *s) {
    return f(s);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sum of many ints]]></title>
    <link href="https://lockxmonk.github.io/15139938131506.html"/>
    <updated>2017-12-23T09:50:13+08:00</updated>
    <id>https://lockxmonk.github.io/15139938131506.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15139938131506/15139938214932.jpg" alt=""/></p>

<p>题目链接：<a href="https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc">https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc</a></p>

<p>注意<code>long long</code>类型。</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

long long f(long long n, long long m) {
    long long sum = 0;
    long long q = n/m;
    long long p = n%m;
    sum+= (m*(m-1)/2)*q;
    sum+= (p+1)*p/2;
    return sum;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ Longest Univalue Path]]></title>
    <link href="https://lockxmonk.github.io/15139334894228.html"/>
    <updated>2017-12-22T17:04:49+08:00</updated>
    <id>https://lockxmonk.github.io/15139334894228.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15139334894228/15139334918786.jpg" alt=""/></p>

<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int dfs(TreeNode* node, int&amp; lup) {
        int l = node-&gt;left ? dfs(node-&gt;left, lup) : 0;
        int r = node-&gt;right ? dfs(node-&gt;right, lup) : 0;
        int resl = node-&gt;left &amp;&amp; node-&gt;left-&gt;val == node-&gt;val ? l + 1 : 0;
        int resr = node-&gt;right &amp;&amp; node-&gt;right-&gt;val == node-&gt;val ? r + 1 : 0;
        lup = max(lup, resl + resr);
        return max(resl, resr);
    }

    int longestUnivaluePath(TreeNode* root) {
        int lup = 0;
        if (root) dfs(root, lup);
        return lup;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Isomorphic Strings]]></title>
    <link href="https://lockxmonk.github.io/15137396102567.html"/>
    <updated>2017-12-20T11:13:30+08:00</updated>
    <id>https://lockxmonk.github.io/15137396102567.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15137396102567/15137396123443.jpg" alt=""/></p>

<p>一开始写的代码，超时版本，用的集合。</p>

<pre><code class="language-c++">bool isIsomorphic(string s, string t) {
    unordered_map&lt;char, set&lt;int&gt;&gt; Smap;
    unordered_map&lt;char, vector&lt;int&gt;&gt; Tmap;
    for (int i = 0; i&lt;s.size(); i++) {
        Smap[s[i]].insert(i);
        Tmap[t[i]].push_back(i);
    }
    if (Smap.size()!=Tmap.size()) {
        return 0;
    }else{
        for (int j = 0; j&lt;s.size(); j++) {
            vector&lt;int&gt; a = Tmap[t[j]];
            set&lt;int&gt; b = Smap[s[j]];
            int len = b.size();
            for (auto num : a) {
                b.insert(num);
                if (len!=b.size()) {
                    return 0;
                }
            }
        }
    }
    
    return 1;
}
</code></pre>

<p>修改后的版本。</p>

<pre><code class="language-c++">class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int m1[256] = {0}, m2[256] = {0}, n = s.size();
        for (int i = 0; i &lt; n; ++i) {
            if (m1[s[i]] != m2[t[i]]) return false;  //判断两个字符串i位置的字符上次出现的位置是否一样。
            m1[s[i]] = i + 1;   //记录上次该字符出现的位置
            m2[t[i]] = i + 1;   //记录上次该字符出现的位置
        }
        return true;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Path Sum II]]></title>
    <link href="https://lockxmonk.github.io/15136732474119.html"/>
    <updated>2017-12-19T16:47:27+08:00</updated>
    <id>https://lockxmonk.github.io/15136732474119.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15136732474119/15136732503183.jpg" alt=""/></p>

<p>运用前序遍历</p>

<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    void findPaths(TreeNode* node, int sum, vector&lt;int&gt;&amp; path, vector&lt;vector&lt;int&gt; &gt;&amp; paths) {
        if (!node) return;
        path.push_back(node -&gt; val);
        if (!(node -&gt; left) &amp;&amp; !(node -&gt; right) &amp;&amp; sum == node -&gt; val)
            paths.push_back(path);
        findPaths(node -&gt; left, sum - node -&gt; val, path, paths);
        findPaths(node -&gt; right, sum - node -&gt; val, path, paths);
        path.pop_back();
    }

    vector&lt;vector&lt;int&gt;&gt; pathSum(TreeNode* root, int sum) {
        vector&lt;vector&lt;int&gt; &gt; paths;
        vector&lt;int&gt; path;
        findPaths(root, sum, path, paths);
        return paths;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Path Sum]]></title>
    <link href="https://lockxmonk.github.io/15136718150164.html"/>
    <updated>2017-12-19T16:23:35+08:00</updated>
    <id>https://lockxmonk.github.io/15136718150164.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15136718150164/15136718241722.jpg" alt=""/></p>

<pre><code class="language-c++">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if (root == NULL) return false;
        if (root-&gt;val == sum &amp;&amp; root-&gt;left ==  NULL &amp;&amp; root-&gt;right == NULL) return true;
        
        return hasPathSum(root-&gt;left, sum-root-&gt;val) || hasPathSum(root-&gt;right, sum-root-&gt;val);
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linked List Cycle II]]></title>
    <link href="https://lockxmonk.github.io/15134129335933.html"/>
    <updated>2017-12-16T16:28:53+08:00</updated>
    <id>https://lockxmonk.github.io/15134129335933.html</id>
    <content type="html"><![CDATA[
<p>题目链接：<a href="https://leetcode.com/problems/linked-list-cycle-ii/description/">https://leetcode.com/problems/linked-list-cycle-ii/description/</a></p>

<p>Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</p>

<p>Note: Do not modify the linked list.</p>

<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        if (head==NULL||head-&gt;next==NULL) {
            return NULL;
        }
        ListNode *slow = head;
        ListNode *fast = head;
        ListNode *entry = head;
        while (fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next) {
            fast = fast-&gt;next-&gt;next;
            slow = slow-&gt;next;
            if (fast==slow) {
                while (slow!=entry) {
                    slow = slow-&gt;next;
                    entry = entry-&gt;next;
                }
                return entry;;
            }
        }
        return NULL;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Linked List Cycle]]></title>
    <link href="https://lockxmonk.github.io/15134088955356.html"/>
    <updated>2017-12-16T15:21:35+08:00</updated>
    <id>https://lockxmonk.github.io/15134088955356.html</id>
    <content type="html"><![CDATA[
<p>Given a linked list, determine if it has a cycle in it.</p>

<p>Follow up:<br/>
Can you solve it without using extra space?</p>

<p><strong>使用快慢两个指针来判断是否有环，当有环的时候，快指针会停留在环内知道慢指针赶上与之相等。</strong></p>

<pre><code class="language-c++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if (head==NULL||head-&gt;next==NULL) {
            return 0;
        }
        ListNode *slow = head;
        ListNode *fast = head;
        while (fast-&gt;next&amp;&amp;fast-&gt;next-&gt;next) {
            fast = fast-&gt;next-&gt;next;
            slow = slow-&gt;next;
            if (fast==slow) {
                return 1;
            }
        }
        return 0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ Convert a Number to Hexadecimal]]></title>
    <link href="https://lockxmonk.github.io/15131536329153.html"/>
    <updated>2017-12-13T16:27:12+08:00</updated>
    <id>https://lockxmonk.github.io/15131536329153.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15131536329153/15131536540833.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string toHex(int num) {
        const string HEX =&quot;0123456789abcdef&quot;;
        if (num==0) return &quot;0&quot;;
        string res =&quot;&quot;;
        int count  = 0;
        while (num&amp;&amp;count++&lt;8) {
            //&amp;0xf表示取二进制的低四位
            res = HEX[(num&amp;0xf)]+res;
            num&gt;&gt;=4;
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Number of Boomerangs]]></title>
    <link href="https://lockxmonk.github.io/15131518267208.html"/>
    <updated>2017-12-13T15:57:06+08:00</updated>
    <id>https://lockxmonk.github.io/15131518267208.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15131518267208/15131518346128.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int numberOfBoomerangs(vector&lt;pair&lt;int, int&gt;&gt;&amp; points) {
        int res = 0;
        for (int i =0; i&lt;points.size(); i++) {
            unordered_map&lt;long, int&gt; map(points.size());
            for (int j = 0; j&lt;points.size(); j++) {
                if (j==i) continue;
                int dy = points[j].second - points[i].second;
                int dx = points[j].first - points[i].first;

                int dis = dy*dy + dx*dx;
                map[dis]++;
            }

            for (auto p : map) {
                if (p.second&gt;1) {
                    /*
                     * for all the groups of points,
                     * number of ways to select 2 from n =
                     * nP2 = n!/(n - 2)! = n * (n - 1)
                     */
                    res+=p.second*(p.second-1);
                }
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Palindromic Substring]]></title>
    <link href="https://lockxmonk.github.io/15130621165951.html"/>
    <updated>2017-12-12T15:01:56+08:00</updated>
    <id>https://lockxmonk.github.io/15130621165951.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15130621165951/15130621284508.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return &quot;&quot;;
        if (s.size() == 1) return s;
        int min_start = 0, max_len = 1;
        for (int i = 0; i &lt; s.size();) {
            if (s.size() - i &lt;= max_len / 2) break;
            int j = i, k = i;
            while (k &lt; s.size()-1 &amp;&amp; s[k+1] == s[k]) ++k; // Skip duplicate characters.
            i = k+1;
            while (k &lt; s.size()-1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) { ++k; --j; } // Expand.
            int new_len = k - j + 1;
            if (new_len &gt; max_len) { min_start = j; max_len = new_len; }
        }
        return s.substr(min_start, max_len);
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Palindrome Pairs]]></title>
    <link href="https://lockxmonk.github.io/15130603513802.html"/>
    <updated>2017-12-12T14:32:31+08:00</updated>
    <id>https://lockxmonk.github.io/15130603513802.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15130603513802/15130603727154.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    bool isPalindrome(string s) {
        if (s.size() &lt;= 1) return true;
        int i = 0;
        int j = s.size() - 1;
        while (i &lt; j) {
            if (s[i++] != s[j--]) return false;
        }

        return true;
    }

    vector&lt;vector&lt;int&gt;&gt; palindromePairs(vector&lt;string&gt;&amp; words) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if (!words.size()) return res;
        unordered_map&lt;string, int&gt; word_idx;
        for (int i = 0; i &lt; words.size(); ++i) {
            word_idx[words[i]] = i;
        }
        vector&lt;int&gt; slu(2);
        for (int i = 0; i &lt; words.size(); ++i) {
            int len = words[i].length();
            for (int l = 0; l &lt;= len; ++l) {
                string left = words[i].substr(0, l);
                string right = words[i].substr(l);
                string rleft = left;
                string rright = right;
                reverse(rleft.begin(), rleft.end());
                reverse(rright.begin(), rright.end());
                if (word_idx.find(rleft) != word_idx.end()) {
                    if (word_idx[rleft] != i &amp;&amp; isPalindrome(right)) {
                        res.push_back({i,word_idx[rleft]});
                    }

                }
                if (l != 0 &amp;&amp; word_idx.find(rright) != word_idx.end()) {
                    if (word_idx[rright] != i &amp;&amp; isPalindrome(left)) {
                        res.push_back({word_idx[rright],i});
                    }

                }

            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intersection of Two Arrays II]]></title>
    <link href="https://lockxmonk.github.io/15130426368802.html"/>
    <updated>2017-12-12T09:37:16+08:00</updated>
    <id>https://lockxmonk.github.io/15130426368802.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15130426368802/15130427333668.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        unordered_map&lt;int, int&gt; map;
        vector&lt;int&gt; res;
        for(auto num1:nums1){
            map[num1]++;
        }

        for(auto num2:nums2){
            if (map[num2]&gt;0) {
                map[num2]--;
                res.push_back(num2);
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sort Characters By Frequency]]></title>
    <link href="https://lockxmonk.github.io/15129821006078.html"/>
    <updated>2017-12-11T16:48:20+08:00</updated>
    <id>https://lockxmonk.github.io/15129821006078.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129821006078/15129821362536.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string frequencySort(string s) {
        unordered_map&lt;char, int&gt; map;
        for (int i =0; i&lt;s.length(); i++) {
            map[s[i]]++;
        }

        sort(s.begin(), s.end(), [&amp;map](char a ,char b){
            return map[a]&gt;map[b] || (map[a] == map[b] &amp;&amp; a &gt; b);
        });
        
        return s;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Unique Character in a String]]></title>
    <link href="https://lockxmonk.github.io/15129806433168.html"/>
    <updated>2017-12-11T16:24:03+08:00</updated>
    <id>https://lockxmonk.github.io/15129806433168.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129806433168/15129806517273.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map&lt;char, int&gt; map;
        for (int i =0; i&lt;s.length(); i++) {
            map[s[i]]++;
        }
        for (int i =0; i&lt;s.length(); i++) {
            if (map[s[i]]==1) {
                return i;
            }
        }
        return -1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Minimum Moves to Equal Array Elements II]]></title>
    <link href="https://lockxmonk.github.io/15129796221707.html"/>
    <updated>2017-12-11T16:07:02+08:00</updated>
    <id>https://lockxmonk.github.io/15129796221707.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129796221707/15129796318879.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int minMoves2(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        if(n &lt;= 1) return 0;
        sort(nums.begin(), nums.end());
        int mid = nums.size()/2 ,res = 0;
        for(int i = 0; i &lt; mid; ++i)
        {
            res+=nums[mid]-nums[i];
        }
        for (int j = n-1; j&gt;mid; j--) {
            res+=nums[j]-nums[mid];
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Minimum Moves to Equal Array Elements]]></title>
    <link href="https://lockxmonk.github.io/15129788527282.html"/>
    <updated>2017-12-11T15:54:12+08:00</updated>
    <id>https://lockxmonk.github.io/15129788527282.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129788527282/15129788644532.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int minMoves(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        if(n &lt;= 1)
            return 0;
        int mn = nums[0];   //mn为最小数字
        int sum = nums[0];
        for(int i = 1; i &lt; n; ++i)
        {
            mn = min(mn,nums[i]);
            sum += nums[i];
        }
        return sum - mn*n;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Range Addition II]]></title>
    <link href="https://lockxmonk.github.io/15129760305793.html"/>
    <updated>2017-12-11T15:07:10+08:00</updated>
    <id>https://lockxmonk.github.io/15129760305793.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129760305793/15129772098038.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) {
        for (auto tmp:ops) {
            m = min(m, tmp[0]);
            n = min(n, tmp[1]);
        }
        return m*n;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beauty Contest（旋转卡壳）]]></title>
    <link href="https://lockxmonk.github.io/15129738955534.html"/>
    <updated>2017-12-11T14:31:35+08:00</updated>
    <id>https://lockxmonk.github.io/15129738955534.html</id>
    <content type="html"><![CDATA[
<p>Description<br/>
Bessie, Farmer John&#39;s prize cow, has just won first place in a bovine beauty contest, earning the title &#39;Miss Cow World&#39;. As a result, Bessie will make a tour of N (2 &lt;= N &lt;= 50,000) farms around the world in order to spread goodwill between farmers and their cows. For simplicity, the world will be represented as a two-dimensional plane, where each farm is located at a pair of integer coordinates (x,y), each having a value in the range -10,000 ... 10,000. No two farms share the same pair of coordinates.</p>

<p>Even though Bessie travels directly in a straight line between pairs of farms, the distance between some farms can be quite large, so she wants to bring a suitcase full of hay with her so she has enough food to eat on each leg of her journey. Since Bessie refills her suitcase at every farm she visits, she wants to determine the maximum possible distance she might need to travel so she knows the size of suitcase she must bring.Help Bessie by computing the maximum distance among all pairs of farms.</p>

<p>Input<br/>
 Line 1: A single integer, N</p>

<p>Lines 2..N+1: Two space-separated integers x and y specifying coordinate of each farm</p>

<p>Output<br/>
Line 1: A single integer that is the squared distance between the pair of farms that are farthest apart from each other.</p>

<p>Sample Input</p>

<p>4<br/>
0 0<br/>
0 1<br/>
1 1<br/>
1 0</p>

<p>Sample Output</p>

<p>2</p>

<h2 id="toc_0">算法思想</h2>

<h3 id="toc_1">流程：</h3>

<ol>
<li><p>求凸包：最远点对一定在凸包上（可以反证法证之），所以找出凸包后在其上找最远点对就可以少考虑很多点。求凸包可用<code>andrew</code>算法，它是基于<code>graham</code>算法，且更快更稳定。不同于<code>graham</code>算法的逆时针排序，<code>andrew</code>算法采用了点的水平排序，然后分别求下凸包以及上凸包，这样下来整个的凸包便求好了。而且该算法可以解决凸包中有重合点、共线点等问题<img src="media/15129738955534/15129741482264.jpg" alt=""/></p></li>
<li><p>旋转卡壳<br/>
就是两个平行线正好把凸包卡住，其中卡着的点称为对踵点对.<br/>
<img src="media/15129738955534/15129741907694.jpg" alt=""/></p></li>
</ol>

<p>那么怎么才能找到最远点对呢？<br/>
<img src="media/15129738955534/15129742545712.jpg" alt=""/></p>

<p>对于上图中的6个三角形的公共底边，可知当三角形的顶点在凸包上按逆时针旋转时，三角形的面积先由小变大再由大变小，即成单峰函数变化。所以在峰值时对应的凸包顶点距底边对应的两个对踵点的距离比其他情况大，这样，枚举每一个边并找到其面积单峰函数峰值对应的顶点，同时更新最大距离，旋转一趟下来便可以得到最后的结果。求面积单峰函数的峰值也很简单，就是通过叉积比较两个三角形的大小，当后者的面积比前者小时便找到了峰值，然后求距离更新最大值即可。</p>

<pre><code class="language-c++">    #include &lt;cstdio&gt;  
    #include &lt;vector&gt;  
    #include &lt;algorithm&gt;  
    #include &lt;cstring&gt;  
    using namespace std;  
    const int maxn = 50000 + 10;  
    typedef int type_xy;  
      
    struct P  
    {  
        type_xy x, y;  
        P() {}  
        P(type_xy x, type_xy y) : x(x), y(y) {}  
        P operator + (P p){ return P(x + p.x, y + p.y); }  
        P operator - (P p){ return P(x - p.x, y - p.y); }  
        P operator * (type_xy d){ return P(x*d, y*d); }  
        bool operator &lt; (const P&amp; a) const  
        {  
            if (x != a.x) return x &lt; a.x;  
            else return y &lt; a.y;  
        }  
        type_xy dot(P p) { return x*p.x + y*p.y; }  
        type_xy det(P p) { return x*p.y - y*p.x; }  
    };  
      
    int N;  
    P ps[maxn];  
      
    //字典序比较  
    bool cmp_x(const P&amp; p, const P&amp; q)  
    {  
        if (p.x != q.x)  
            return p.x &lt; q.x;  
        return p.y &lt; q.y;  
    }  
      
    //求凸包  
    vector&lt;P&gt; convex_hull(P* ps, int n)  
    {  
        sort(ps, ps + n, cmp_x);  
        int k = 0;          //凸包的顶点数  
        vector&lt;P&gt; qs(n * 2);        //构造中的凸包  
        //构造凸包的下侧  
        for (int i = 0; i &lt; n; i++){  
            while (k &gt; 1 &amp;&amp; (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) &lt;= 0)  
                k--;  
            qs[k++] = ps[i];  
        }  
        //构造凸包的上侧  
        for (int i = n - 2, t = k; i &gt;= 0; i--){  
            while (k &gt; t &amp;&amp; (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) &lt;= 0)  
                k--;  
            qs[k++] = ps[i];  
        }  
        qs.resize(k - 1);  
        return qs;  
    }  
      
    //距离的平方  
    double dist(P p, P q)  
    {  
        return (p - q).dot(p - q);  
    }  
      
      
    void solve()  
    {  
        vector&lt;P&gt; qs = convex_hull(ps, N);  
        int n = qs.size();  
        if (n == 2){         //特别处理凸包退化的情况  
            printf(&quot;%.0f\n&quot;, dist(qs[0], qs[1]));  
            return;  
        }  
        int i = 0, j = 0;           //某个方向上的对踵点对  
        //求出x轴方向上的对踵点对  
        for (int k = 0; k &lt; n; k++){  
            if (!cmp_x(qs[i], qs[k]))  
                i = k;  
            if (cmp_x(qs[j], qs[k]))  
                j = k;  
        }  
        double res = 0;  
        int si = i, sj = j;  
        while (i != sj || j != si){     //将方向逐步旋转180度  
            res = max(res, dist(qs[i], qs[j]));  
            //判断先转到边i-(i+1)的法线方向还是边j-(j+1)的法线方向  
            if ((qs[(i + 1) % n] - qs[i]).det(qs[(j + 1) % n] - qs[j]) &lt; 0)  
                i = (i + 1) % n;        //先转到边i-(i+1)的法线方向  
            else  
                j = (j + 1) % n;        //先转到边j-(j+1)的法线方向  
        }  
        printf(&quot;%.0f\n&quot;, res);  
    }  
      
    int main()  
    {  
        while (scanf(&quot;%d&quot;, &amp;N) != EOF){  
            for (int i = 0; i &lt; N; i++){  
                scanf(&quot;%d%d&quot;, &amp;ps[i].x, &amp;ps[i].y);  
            }  
            solve();  
        }  
        return 0;  
    }  
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Excel Sheet Column Title]]></title>
    <link href="https://lockxmonk.github.io/15129633578167.html"/>
    <updated>2017-12-11T11:35:57+08:00</updated>
    <id>https://lockxmonk.github.io/15129633578167.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129633578167/15129633692969.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string convertToTitle(int n) {
        string res = &quot;&quot;;
        while (n!=0) {
            res = char(&#39;A&#39;+(--n)%26)+res;
            n=n/26;
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
</feed>
