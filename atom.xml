<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2018-01-06T14:00:48+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[First Missing Positive]]></title>
    <link href="https://lockxmonk.github.io/15162636130743.html"/>
    <updated>2018-01-18T16:20:13+08:00</updated>
    <id>https://lockxmonk.github.io/15162636130743.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162636130743/15162636149442.jpg" alt=""/></p>

<pre><code class="language-objc">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; map;
        int min = INT_MAX, max = 0, res = 1;
        for (int i = 0; i&lt;nums.size(); i++) {
            if (nums[i]&lt;=min&amp;&amp;nums[i]&gt;=0) {
                min = nums[i];
            }else if (nums[i]&lt;0) min = 0;
            if (nums[i]&gt;=max) max = nums[i];
            map[nums[i]]++;
        }
        for (int j=min; j&lt;=max; j++) {
            if (j==0) continue;
            if (min&gt;=2) {
                return 1;
            }
            if (map[j]==0) {
                res = j;
                break;
            }
            if (j==max) {
                res = max+1;
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find the Duplicate Number]]></title>
    <link href="https://lockxmonk.github.io/15162583169716.html"/>
    <updated>2018-01-18T14:51:56+08:00</updated>
    <id>https://lockxmonk.github.io/15162583169716.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162583169716/15162583183298.jpg" alt=""/></p>

<pre><code class="language-objc">class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; map;
        int res = 0;
        for (int i = 0; i&lt;nums.size(); i++) {
            if (map[nums[i]]==0) {
                map[nums[i]]++;
            }else{
                res = nums[i];
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set Mismatch]]></title>
    <link href="https://lockxmonk.github.io/15162440984880.html"/>
    <updated>2018-01-18T10:54:58+08:00</updated>
    <id>https://lockxmonk.github.io/15162440984880.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162440984880/15162441100081.jpg" alt=""/></p>

<pre><code class="language-objc">class Solution {
public:
    vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        vector&lt;int&gt; res;
        vector&lt;int&gt; a(len+1);   //因为数组从0开始，所以除去0，在后面加上1位

        for (int i = 0; i&lt;len; i++) {
            if (a[nums[i]]==0) {
                a[nums[i]]+=1;
            }else{
                res.push_back(nums[i]);
            }
        }

        for (int j = 1; j&lt;=len; j++) {
            if (a[j]==0) {
                res.push_back(j);
            }
        }

        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find Anagram Mappings]]></title>
    <link href="https://lockxmonk.github.io/15162401864030.html"/>
    <updated>2018-01-18T09:49:46+08:00</updated>
    <id>https://lockxmonk.github.io/15162401864030.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162401864030/15162401885331.jpg" alt=""/></p>

<pre><code class="language-objc">class Solution {
public:
    vector&lt;int&gt; anagramMappings(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {
        unordered_map&lt;int, int&gt; map;
        vector&lt;int&gt; res;
        for (int i = 0; i&lt;B.size(); i++) {
            map[B[i]]=i;
        }
        for (int j = 0; j&lt;A.size(); j++) {
            res.push_back(map[A[j]]);
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Length of Last Word]]></title>
    <link href="https://lockxmonk.github.io/15162389890253.html"/>
    <updated>2018-01-18T09:29:49+08:00</updated>
    <id>https://lockxmonk.github.io/15162389890253.html</id>
    <content type="html"><![CDATA[
<pre><code>![](media/15162389890253/15162389958774.jpg)
</code></pre>

<pre><code class="language-objc">class Solution {
public:
    int lengthOfLastWord(string s) {
        int len = s.size();
        int cout = 0;
        for (int i=len-1; i&gt;=0; i--) {
            if(cout&gt;0&amp;&amp;s[i]==&#39; &#39;) break;

            if (s[i]==&#39; &#39;) {
                continue;
            }else{
                cout++;
            }

        }
        return cout;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find matching parenthesis]]></title>
    <link href="https://lockxmonk.github.io/15155525710565.html"/>
    <updated>2018-01-10T10:49:31+08:00</updated>
    <id>https://lockxmonk.github.io/15155525710565.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15155525710565/15155525754064.jpg" alt=""/><br/>
<img src="media/15155525710565/15155525919147.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

int findParenMatch(NSString *s, int n) {
    int res = -1;
    NSString *tmp = [s substringWithRange:NSMakeRange(n, 1)];
    if ([tmp isEqualToString:@&quot;(&quot;]) {
        int logF = 0;
        for (int i = n+1; i&lt;s.length; i++) {
            NSString *tmpStrF = [s substringWithRange:NSMakeRange(i, 1)];
            if ([tmpStrF isEqualToString:@&quot;(&quot;]) logF++;
            if ([tmpStrF isEqualToString:@&quot;)&quot;]) {
                logF--;
                if (logF&lt;0) {
                    res = i;
                    break;
                }
            }
        }
    }else if ([tmp isEqualToString:@&quot;)&quot;]){
        int logB = 0;
        for (int i = n-1; i&gt;=0; i--) {
            NSString *tmpStrB = [s substringWithRange:NSMakeRange(i, 1)];
            if ([tmpStrB isEqualToString:@&quot;)&quot;]) logB++;
            if ([tmpStrB isEqualToString:@&quot;(&quot;]) {
                logB--;
                if (logB&lt;0) {
                    res = i;
                    break;
                }
            }
        }
    }
    return res;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVO自己的理解]]></title>
    <link href="https://lockxmonk.github.io/15153763176511.html"/>
    <updated>2018-01-08T09:51:57+08:00</updated>
    <id>https://lockxmonk.github.io/15153763176511.html</id>
    <content type="html"><![CDATA[
<ol>
<li>KVO利用runtime，生成了一个对象的子类，并生成子类对象替换原来对象的isa指针，重写了set方法。</li>
<li>KVO是基于KVC的，可以明显的发现在改变容器的时候，通过KVC改变改变容器中的值或者使用set方法时，会触发KVO通知函数，而简单的使用addObject：方法时却没有触发，这是因为KVO只响应set方法。<font color=red>可以说kvc是kvo的入口</font></li>
<li>直接使用KVO在项目中不是很好用，代码结构比较松散，需要自己封装或使用其它三方框架。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Where my anagrams at?]]></title>
    <link href="https://lockxmonk.github.io/15152183997863.html"/>
    <updated>2018-01-06T13:59:59+08:00</updated>
    <id>https://lockxmonk.github.io/15152183997863.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15152183997863/15152184280248.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *anagrams(NSString *s, NSArray *a) {
    NSMapTable *map = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableStrongMemory];
    for (int i = 0; i&lt;[s length]; i++) {
        NSString *str = [s substringWithRange:NSMakeRange(i, 1)];
        if ([map objectForKey:str]) {
            [map setObject:@([[map objectForKey:str] intValue]+1) forKey:str];
        }else{
            [map setObject:@(1) forKey:str];
        }
    }
    NSMutableArray *res = a.mutableCopy;
    for (NSString *ele in a) {
        if(ele.length!=s.length){
            [res removeObject:ele];
            continue;
        }
        NSMapTable *tmp = [map copy];
        for (int j=0; j&lt;[ele length]; j++) {
            NSString *tmpStr = [ele substringWithRange:NSMakeRange(j, 1)];
            if ([tmp objectForKey:tmpStr]) {
                int log =[[tmp objectForKey:tmpStr] intValue]-1;
                if (log&lt;0){
                    [res removeObject:ele];
                    break;
                }
                [tmp setObject:@(log) forKey:tmpStr];
            }else{
                [res removeObject:ele];
                break;
            }
        }
    }
    return res;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perimeter of squares in a rectangle]]></title>
    <link href="https://lockxmonk.github.io/15152039082618.html"/>
    <updated>2018-01-06T09:58:28+08:00</updated>
    <id>https://lockxmonk.github.io/15152039082618.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15152039082618/15152039109281.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

unsigned long long perimeter(int n) {
    NSMutableArray *numQu = @[@0,@1].mutableCopy;
    unsigned long long n0 = 0,n1=1;
    for (int i = 2; i&lt;=n+1; i++) {
        unsigned long long sum = n0+n1;
        n0 = n1;
        n1 = sum;
        [numQu addObject:@(sum)];
    }
    unsigned long long tol = 0;
    for (NSNumber* ele in numQu) {
        tol+=[ele unsignedLongLongValue];
    }
    return tol*4;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking遇到的问题]]></title>
    <link href="https://lockxmonk.github.io/15151211562254.html"/>
    <updated>2018-01-05T10:59:16+08:00</updated>
    <id>https://lockxmonk.github.io/15151211562254.html</id>
    <content type="html"><![CDATA[
<p>由于<code>AFNetworking</code>运用了官方<code>NSURLSession</code>所以其中有一些坑</p>

<h2 id="toc_0">1.苹果运用NSJSONSerialization解析，出现数字类型精度问题</h2>

<p>当服务器给我传回来一个<code>3.0</code>的数字类型时，在安卓端是没有问题的，但是在iOS这里会出现<code>2.99999</code>这样的问题。</p>

<p><font color=red><strong>出现这个问题的原因是：苹果在json解析时，默认为双精度的double类型。</strong></font></p>

<pre><code>我们相处的解决方案有两种：
1. 跟后台协商将数字型的值改为`字符型`
2. 使用第三方的json解析。
</code></pre>

<p>最后我们使用的是第一种方法，因为第二种势必要修改了AFNetwork的源码，开发与维护成本相比较来说要大。</p>

<h2 id="toc_1">2.json解析失败</h2>

<p>由于AF默认的解析方式为<code>0</code>（返回的对象是不可变的，<code>NSDictionary</code>或<code>NSArray</code>）：<br/>
<img src="media/15151211562254/15151222443779.jpg" alt=""/></p>

<p>我们来看一下都有什么选项：<br/>
<img src="media/15151211562254/15151222806031.jpg" alt=""/></p>

<p>所以当我们服务器返回的json数据是<strong>碎片化</strong>的（最外层既不是<code>NSArray</code>也不是<code>NSDictionary</code>），那么解析的时候就会出错了。</p>

<p>解决方法是：</p>

<p><img src="media/15151211562254/15151327758647.jpg" alt=""/><br/>
在0后添加<code>|</code>字符，增加这种情况，允许碎片化数据。</p>

<h2 id="toc_2">3. 请求后response的状态码范围问题</h2>

<p>正常项目中正常请求成功会返回200，但是服务器若是给你返回了500（我不知道后台为啥会返回这个码），问题就出现了：</p>

<p>这是由于下面的原因：<br/>
<img src="media/15151211562254/15151343155944.jpg" alt=""/><br/>
会发现上图中可接受状态码的范围是200-300；</p>

<p>具体解决方法就不说了。。。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1's, 0's and wildcards]]></title>
    <link href="https://lockxmonk.github.io/15145180239158.html"/>
    <updated>2017-12-29T11:27:03+08:00</updated>
    <id>https://lockxmonk.github.io/15145180239158.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15145180239158/15145180364703.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *changeTo(NSMutableArray*log, NSMutableArray*res){
    if (log.count&gt;0) {
        NSRange loc = {[[log lastObject] integerValue],1};
        NSMutableArray *cop = res.mutableCopy;
        for (NSString *tmp in res) {
            [cop addObject:[tmp stringByReplacingCharactersInRange:loc withString:@&quot;0&quot;]];
            [cop addObject:[tmp stringByReplacingCharactersInRange:loc withString:@&quot;1&quot;]];
            [cop removeObject:tmp];
        }
        [log removeLastObject];
        return changeTo(log, cop);
    }else{
        return res;
    }
}

NSArray *possibilities(NSString *s) {
    NSMutableArray *log = @[].mutableCopy;
    NSMutableArray *res = @[].mutableCopy;
    for (int i = 0; i&lt;s.length; i++) {
        if ([s characterAtIndex:i]==&#39;?&#39;) {
            [log addObject:@(i)];
        }
    }
    [res addObject:s];

    NSArray *tol = changeTo(log , res);
    
    return tol;
}
</code></pre>

<p>简化版：</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *possibilities(NSString *s) {
  // NSLog(@&quot;User `possibilities` accidentally invoked!\n&quot;);
  if ([s rangeOfString: @&quot;?&quot;].length == 0) return @[s];
  NSString *r = [s stringByReplacingOccurrencesOfString: @&quot;?&quot; withString: @&quot;0&quot; options: 0 range: [s rangeOfString: @&quot;?&quot;]], *t = [s stringByReplacingOccurrencesOfString: @&quot;?&quot; withString: @&quot;1&quot; options: 0 range: [s rangeOfString: @&quot;?&quot;]];
  return [possibilities(r) arrayByAddingObjectsFromArray: possibilities(t)];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Pig Latin]]></title>
    <link href="https://lockxmonk.github.io/15143494387976.html"/>
    <updated>2017-12-27T12:37:18+08:00</updated>
    <id>https://lockxmonk.github.io/15143494387976.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15143494387976/15143494406501.jpg" alt=""/></p>

<p>一开始的复杂版:</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSString *pigIt(NSString *s) {
    NSMutableArray *str = [s componentsSeparatedByString:@&quot; &quot;].mutableCopy;
    NSMutableString *res = @&quot;&quot;.mutableCopy;
    for (NSString *tmp in str) {
        unichar c = [tmp characterAtIndex:0];
        if ((c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)) {
            NSMutableString *change = tmp.mutableCopy;
            [change appendFormat:@&quot;%c&quot;,c];
            if ([tmp isEqualToString:[str lastObject]]) {
                [change appendString:@&quot;ay&quot;];
            }else{
                [change appendString:@&quot;ay &quot;];
            }
            [res appendString:[change substringFromIndex:1]];
        }else{
            [res appendFormat:@&quot;%c&quot;,c];
        }
    }
    return res;
}
</code></pre>

<p>简化版</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSString *pigIt(NSString *s) {
  NSMutableArray *result = [s componentsSeparatedByString: @&quot; &quot;];
  for (size_t i = 0; i &lt; [result count]; i++) result[i] = [[[result[i] substringFromIndex: 1] stringByAppendingString: [result[i] substringToIndex: 1]] stringByAppendingString: @&quot;ay&quot;];
  return [result componentsJoinedByString: @&quot; &quot;];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sum without highest and lowest number]]></title>
    <link href="https://lockxmonk.github.io/15143439533653.html"/>
    <updated>2017-12-27T11:05:53+08:00</updated>
    <id>https://lockxmonk.github.io/15143439533653.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15143439533653/15143439550035.jpg" alt=""/></p>

<pre><code class="language-objc">int sum(int* numbers, int numbersCount)
{
    if(numbersCount&lt;=1) return 0;
    int min = INT_MAX;
    int max = INT_MIN;
    int sum = 0;
    for (int i = 0; i&lt;numbersCount; i++)
    {
        if(numbers[i]&gt;max) max = numbers[i];
        if(numbers[i]&lt;min) min = numbers[i];
        sum+= numbers[i];
    }
    return sum-min-max;
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find the missing term in an Arithmetic Progression]]></title>
    <link href="https://lockxmonk.github.io/15142765984953.html"/>
    <updated>2017-12-26T16:23:18+08:00</updated>
    <id>https://lockxmonk.github.io/15142765984953.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15142765984953/15142766000094.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSNumber *findMissing(NSArray *list) {
    int len = [list count];
    int n = len+1;
    int d1 = [list[1] intValue]-[list[0] intValue];
    int d2 = [list[len-1] intValue]-[list[len-2] intValue];
    int d = 0;
    if (d1&lt;0) {
        d = d1&gt;d2?d1:d2;
    }else{
        d = d1&lt;d2?d1:d2;
    }
    if (n == 3) {
        return @(([[list firstObject] intValue]+[[list lastObject] intValue])/2);
    }
    int num = [[list firstObject] intValue];
    for (int i = 0;i&lt;len;i++) {
        if ([list[i] intValue]!=num) {
            return @(num);
        }
        num+=d;
    }
    
    return @(0);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Valid Parentheses]]></title>
    <link href="https://lockxmonk.github.io/15141803762335.html"/>
    <updated>2017-12-25T13:39:36+08:00</updated>
    <id>https://lockxmonk.github.io/15141803762335.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15141803762335/15141803778513.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

bool validParentheses(NSString *s) {
    // TODO: Return a boolean value indicating whether the
    // order of parentheses in the given string is valid
    if (s.length==0) {
        return 0;
    }
    int sum = 0;
    NSMutableArray *res = @[].mutableCopy;
    for (int i = 0; i&lt;s.length; i++) {
        if ([s characterAtIndex:i]==(unichar)&#39;(&#39;) {
            [res addObject:@(&#39;(&#39;)];
            sum++;
        }
        if ([s characterAtIndex:i]==(unichar)&#39;)&#39;) {
            if ([[res lastObject] isEqual:@(&#39;(&#39;)]) {
                [res removeObjectAtIndex:res.count-1];
            }else{
                [res addObject:@(&#39;)&#39;)];
            }
            sum--;
        }
    }
    if (sum!=0||[res count]!=0) {
        return 0;
    }
    return 1;
}
</code></pre>

<p>简化版：</p>

<pre><code class="language-objc">
#import &lt;Foundation/Foundation.h&gt;

bool validParentheses(NSString *s) {
  int brackets = 0;
  for (int i = 0; i &lt; [s length]; i++) {
    if ([s characterAtIndex: i] == &#39;(&#39;) brackets++;
    else if ([s characterAtIndex: i] == &#39;)&#39;) if (--brackets &lt; 0) return false;
  }
  return !brackets;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Follow that Spy]]></title>
    <link href="https://lockxmonk.github.io/15140206056964.html"/>
    <updated>2017-12-23T17:16:45+08:00</updated>
    <id>https://lockxmonk.github.io/15140206056964.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15140206056964/15140206079284.jpg" alt=""/></p>

<p>自己的麻烦些的代码：用了<code>NSMapTable</code></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;
NSString *findRoutes(NSArray *routes){
    if ([routes count]==1) {
        return [NSString stringWithFormat:@&quot;%@, %@&quot;,routes[0][0],routes[0][1]];
    }
    NSMapTable *map = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableWeakMemory];
    NSMapTable *tol = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableWeakMemory];
    for (NSArray *tmp in routes) {
        [map setObject:tmp[1] forKey:tmp[0]];
        for (NSString* tmpTol in tmp) {
            if ([tol objectForKey:tmpTol]) {
                [tol setObject:@&quot;1&quot; forKey:tmpTol];
            }else{
                [tol setObject:@&quot;0&quot; forKey:tmpTol];
            }
        }
    }
    NSString *str = @&quot;&quot;;
    NSString *end = @&quot;&quot;;
    NSEnumerator *enumerator = [tol keyEnumerator];
    for (NSString *tmp in enumerator) {
        if ([[tol objectForKey:tmp] isEqualToString:@&quot;0&quot;]) {
            if (![map objectForKey:tmp]) {
                end = tmp;
                continue;
            }
            str = tmp;
        }
    }
    NSString *res = @&quot;&quot;;
    res = [res stringByAppendingFormat:@&quot;%@, &quot;, str];
    while ([map objectForKey:str]) {
       res =  [res stringByAppendingFormat:@&quot;%@, &quot;, [map objectForKey:str]];
       str = [map objectForKey:str];
        if ([[map objectForKey:str] isEqualToString:end]) {
            res = [res stringByAppendingString:end];
            break;
        }
    }
    return res;
}
</code></pre>

<p>别人的简短代码：</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;
NSString *findRoutes(NSArray *routes){

    NSMutableArray * routesM = [routes mutableCopy];
    NSMutableArray * answer = [@[routes[0][0]] mutableCopy];
    do{
        for(int i = (int)routesM.count - 1; i &gt;= 0; i--){
            if([[answer lastObject] isEqualToString:routesM[i][0]]){
                [answer addObject:routesM[i][1]];
                [routesM removeObjectAtIndex:i];
            } else if([[answer firstObject] isEqualToString:routesM[i][1]]){
                [answer insertObject:routesM[i][0] atIndex:0];
                [routesM removeObjectAtIndex:i];
            }
        }
    } while (routesM.count &gt; 0);
    return [answer componentsJoinedByString:@&quot;, &quot;];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Fun #4: Phone Call]]></title>
    <link href="https://lockxmonk.github.io/15140141868103.html"/>
    <updated>2017-12-23T15:29:46+08:00</updated>
    <id>https://lockxmonk.github.io/15140141868103.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15140141868103/15140147655873.jpg" alt=""/><br/>
<img src="media/15140141868103/15140147745826.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;
int phoneCall(int min1, int min2_10, int min11, int s) {
    if (s&lt;min1) return 0;
    int sum = 1;
    sum+= (s-min1)&gt;min2_10*9 ? 9 : (s-min1)/min2_10;
    sum+= (s-min1-9*min2_10)&lt;0 ? 0 : (s-min1-9*min2_10)/min11;
    return sum;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Don't give me five!]]></title>
    <link href="https://lockxmonk.github.io/15140137962108.html"/>
    <updated>2017-12-23T15:23:16+08:00</updated>
    <id>https://lockxmonk.github.io/15140137962108.html</id>
    <content type="html"><![CDATA[
<p>Don&#39;t give me five!</p>

<p>In this kata you get the start number and the end number of a region and should return the count of all numbers except numbers with a 5 in it. The start and the end number are both inclusive!</p>

<p>Examples:</p>

<pre><code>1,9 -&gt; 1,2,3,4,6,7,8,9 -&gt; Result 8
4,17 -&gt; 4,6,7,8,9,10,11,12,13,14,16,17 -&gt; Result 12
</code></pre>

<p>The result may contain fives. ;-)<br/>
The start number will always be smaller than the end number. Both numbers can be also negative!</p>

<p>I&#39;m very curious for your solutions and the way you solve it. Maybe someone of you will find an easy pure mathematics solution.</p>

<p>Have fun coding it and please don&#39;t forget to vote and rank this kata! :-)</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;
int dontGiveMeFive(int start, int end)
{
  int sum = 0;
    for (int i = start; i&lt;=end; i++) {
        if ([[NSString stringWithFormat:@&quot;%i&quot;,i] rangeOfString:@&quot;5&quot;].location!=NSNotFound) {
            continue;
        }
        sum++;
    }
    return sum;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Moves in squared strings (I)]]></title>
    <link href="https://lockxmonk.github.io/15139993814636.html"/>
    <updated>2017-12-23T11:23:01+08:00</updated>
    <id>https://lockxmonk.github.io/15139993814636.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15139993814636/15139993826350.jpg" alt=""/><br/>
<img src="media/15139993814636/15139994003399.jpg" alt=""/></p>

<p>题目链接：<a href="https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc">https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc</a></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSString *vertMirror(NSString *strng) {
    NSMutableString *res = [[NSMutableString alloc] init];
    NSArray *stringArray = [strng componentsSeparatedByString:@&quot;\n&quot;];
    for (NSString *tmpStr in stringArray) {
        NSMutableString * reverseString = [NSMutableString string];
        for(int i = 0 ; i &lt; tmpStr.length; i ++){
            //倒序读取字符并且存到可变数组数组中
            unichar c = [tmpStr characterAtIndex:tmpStr.length- i -1];
            [reverseString appendFormat:@&quot;%c&quot;,c];
        }
        
        if ([tmpStr isEqualToString:[stringArray lastObject]]) {
            [res appendString:reverseString];
            break;
        }
        
        [reverseString appendString:@&quot;\n&quot;];
        [res appendString:reverseString];
    }
    
    return res;
}

NSString *horMirror(NSString *strng) {
    NSMutableString *res = [[NSMutableString alloc] init];;
    NSArray *stringAry = [strng componentsSeparatedByString:@&quot;\n&quot;];
    for (int i = stringAry.count-1; i&gt;=0; i--) {
        [res appendString:stringAry[i]];
        if (i==0) {
            break;
        }
        [res appendString:@&quot;\n&quot;];
    }
    return res;
}

NSString *oper(NSString *(*f)(NSString *), NSString *s) {
    return f(s);
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sum of many ints]]></title>
    <link href="https://lockxmonk.github.io/15139938131506.html"/>
    <updated>2017-12-23T09:50:13+08:00</updated>
    <id>https://lockxmonk.github.io/15139938131506.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15139938131506/15139938214932.jpg" alt=""/></p>

<p>题目链接：<a href="https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc">https://www.codewars.com/kata/moves-in-squared-strings-i/train/objc</a></p>

<p>注意<code>long long</code>类型。</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

long long f(long long n, long long m) {
    long long sum = 0;
    long long q = n/m;
    long long p = n%m;
    sum+= (m*(m-1)/2)*q;
    sum+= (p+1)*p/2;
    return sum;
}
</code></pre>

]]></content>
  </entry>
  
</feed>
