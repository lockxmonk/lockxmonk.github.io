<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2017-12-04T21:02:54+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Battleships in a Board]]></title>
    <link href="https://lockxmonk.github.io/15124598875437.html"/>
    <updated>2017-12-05T15:44:47+08:00</updated>
    <id>https://lockxmonk.github.io/15124598875437.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15124598875437/15124598979272.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        int m = board.size();
        int n = board[0].size();
        int res = 0;
        for (int i=0; i&lt;m; i++) {
            for (int j =0; j&lt;n; j++) {
                if ((board[i][j]==&#39;X&#39;)&amp;&amp;(i==0||board[i-1][j]!=&#39;X&#39;)&amp;&amp;(j==0||board[i][j-1]!=&#39;X&#39;)) {
                    ++res;
                }
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Complex Number Multiplication]]></title>
    <link href="https://lockxmonk.github.io/15124576449217.html"/>
    <updated>2017-12-05T15:07:24+08:00</updated>
    <id>https://lockxmonk.github.io/15124576449217.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15124576449217/15124576549963.jpg" alt=""/></p>

<p>第一次写的复杂版：</p>

<pre><code class="language-c++">string complexNumberMultiply(string a, string b) {
    int a1=0 ,b1=0 ,a2=0 ,b2=0;
    for (int i = 0; i&lt;a.length(); i++) {
        int log = 0;
        if (a[i]==&#39;+&#39;) {
            log = i;
            string tmp;
            for (int j=0; j&lt;i; j++) {
                tmp+=a[j];
            }
            sscanf(tmp.c_str(), &quot;%d&quot;,&amp;a1);
            tmp = &quot;&quot;;
            for (int m = i+1; m&lt;a.length()-1; m++) {
                tmp+=a[m];
            }
            sscanf(tmp.c_str(), &quot;%d&quot;,&amp;b1);
        }
    }
    for (int i = 0; i&lt;b.length(); i++) {
        int log = 0;
        if (b[i]==&#39;+&#39;) {
            log = i;
            string tmp;
            for (int j=0; j&lt;i; j++) {
                tmp+=b[j];
            }
            sscanf(tmp.c_str(), &quot;%d&quot;,&amp;a2);
            tmp = &quot;&quot;;
            for (int m = i+1; m&lt;b.length()-1; m++) {
                tmp+=b[m];
            }
            sscanf(tmp.c_str(), &quot;%d&quot;,&amp;b2);
        }
    }
    string res = to_string(a1*a2-b1*b2)+&quot;+&quot;+to_string(a1*b2+a2*b1)+&quot;i&quot;;
    return res;
}
</code></pre>

<p>精简版：</p>

<pre><code class="language-c++">class Solution {
public:
    string complexNumberMultiply(string a, string b) {
        int c,d,e,f;
        char ret[100];
        sscanf(a.c_str(),&quot;%d+%di&quot;,&amp;c,&amp;d);
        sscanf(b.c_str(),&quot;%d+%di&quot;,&amp;e,&amp;f);
        cout&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;&quot; &quot;&lt;&lt;e&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;endl;
        sprintf(ret,&quot;%d+%di&quot;,(c*e-f*d),(d*e+c*f));
        string ans(ret);
        return ans;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Student Attendance Record I]]></title>
    <link href="https://lockxmonk.github.io/15124550672696.html"/>
    <updated>2017-12-05T14:24:27+08:00</updated>
    <id>https://lockxmonk.github.io/15124550672696.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15124550672696/15124551477663.jpg" alt=""/></p>

<p>优化前：<br/>
<code>c++<br/>
bool checkRecord(string s) {<br/>
    int logA = 0;<br/>
    for (int i=0; i&lt;s.length(); i++) {<br/>
        if (s[i]==&#39;A&#39;) {<br/>
            logA++;<br/>
            if (logA&gt;1) {<br/>
                return 0;<br/>
            }<br/>
        }<br/>
        if (i&gt;1&amp;&amp;s[i]==&#39;L&#39;&amp;&amp;s[i-1]==&#39;L&#39;&amp;&amp;s[i-2]==&#39;L&#39;) {<br/>
            return 0;<br/>
        }<br/>
    }<br/>
    return 1;<br/>
}<br/>
</code></p>

<p>优化后：</p>

<pre><code class="language-c++">class Solution {
public:
    bool checkRecord(string s) {
        int count_A = 0;
        int pos = 0;
        while(pos&lt;s.length())
        {
            if(s[pos]==&#39;A&#39;)
            {
                count_A++;
                pos++;
                if(count_A&gt;1)
                    return false;
            }
            else if(s[pos]==&#39;L&#39;)
            {
                int count = 0;
                while(pos&lt;s.length()&amp;&amp;s[pos]==&#39;L&#39;)
                {
                    count++;
                    pos++;
                }
                if(count&gt;2)
                    return false;
            }
            else
                pos++;
            
        }
        return true;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Baseball Game]]></title>
    <link href="https://lockxmonk.github.io/15124490673294.html"/>
    <updated>2017-12-05T12:44:27+08:00</updated>
    <id>https://lockxmonk.github.io/15124490673294.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15124490673294/15124490974323.jpg" alt=""/><br/>
<img src="media/15124490673294/15124491075954.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int calPoints(vector&lt;string&gt;&amp; ops) {
        int sum = 0, score = 0;
        vector&lt;int&gt; rounds;
        for (string op : ops) {
            if (op == &quot;C&quot;) {
                sum -= rounds.back();
                rounds.pop_back();
                continue;
            }
            if (op == &quot;D&quot;) {
                sum += score = rounds.back() * 2;
            }
            else if (op == &quot;+&quot;) {
                sum += score = rounds[rounds.size() - 1] + rounds[rounds.size() - 2];
            }
            else {
                sum += score = stoi(op);
            }
            rounds.push_back(score);
        }
        return sum;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implement strStr()]]></title>
    <link href="https://lockxmonk.github.io/15123924891077.html"/>
    <updated>2017-12-04T21:01:29+08:00</updated>
    <id>https://lockxmonk.github.io/15123924891077.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15123924891077/15123924935113.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int strStr(string haystack, string needle) {
        int j = 0;  //标记needle的初始位置
        int h = haystack.length(), n = needle.length();
        if (!n) {
            return 0;
        }
        for (int i =0; i&lt;h-n+1; i++) {
            int tmp = i;
            while (tmp&lt;h &amp;&amp; j&lt;n &amp;&amp; haystack[tmp]==needle[j]) {
                tmp++;
                j++;
            }
            if (j==n) {
                return i;
            }else{
                j=0;
            }
        }
        return -1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String Compression]]></title>
    <link href="https://lockxmonk.github.io/15123884479504.html"/>
    <updated>2017-12-04T19:54:07+08:00</updated>
    <id>https://lockxmonk.github.io/15123884479504.html</id>
    <content type="html"><![CDATA[
<p>Given an array of characters, compress it in-place.</p>

<p>The length after compression must always be smaller than or equal to the original array.</p>

<p>Every element of the array should be a character (not int) of length 1.</p>

<p>After you are done modifying the input array in-place, return the new length of the array.</p>

<p>Follow up:<br/>
Could you solve it using only O(1) extra space?</p>

<p><img src="media/15123884479504/15123884710226.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int compress(vector&lt;char&gt;&amp; chars) {
        int tol = 1;    //统计相同字符的数量
        for (int i = 0; i&lt;chars.size(); i++) {
            while (i!=chars.size()-1 &amp;&amp; chars[i]==chars[i+1]) {
                chars.erase(chars.begin()+i+1);
                tol++;
            }
            int log = 0; //标记插入数字是1的情况
            int logNum = 0;  //统计插入的数字个数
            while (log==1||tol!=1 &amp;&amp; tol&gt;0) {
                chars.insert(chars.begin()+i+1, char(tol%10+&#39;0&#39;));
                tol/=10;
                log = tol==1?tol:0;
                logNum++;
            }
            i+=logNum;
            tol = 1;
        }
        return chars.size();
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Count Binary Substrings]]></title>
    <link href="https://lockxmonk.github.io/15123785215963.html"/>
    <updated>2017-12-04T17:08:41+08:00</updated>
    <id>https://lockxmonk.github.io/15123785215963.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15123785215963/15123785359347.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int countBinarySubstrings(string s) {
        vector&lt;int&gt; res;
        int tol = 1;
        for (int i=1; i&lt;=s.length(); i++) {
            if (s[i]==s[i-1]) {
                tol++;
            }else{
                res.push_back(tol);
                tol =1;
            }
        }
        int count = 0;
        for(int i=1, n=res.size(); i&lt;n; ++i){
            count += min(res[i-1], res[i]);
        }
        return count;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Detect Capital]]></title>
    <link href="https://lockxmonk.github.io/15123751997678.html"/>
    <updated>2017-12-04T16:13:19+08:00</updated>
    <id>https://lockxmonk.github.io/15123751997678.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15123751997678/15123752096895.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    bool detectCapitalUse(string word) {
        int a[word.length()];
        int r = 0;
        for (int i = 0; i&lt;word.length(); i++) {
            if (word[i]&gt;=&#39;A&#39;&amp;&amp;word[i]&lt;=&#39;Z&#39;) {
                a[i] = 1;
                r+=a[i];
            }
        }
        if (r==word.length()||(a[0]==1&amp;&amp;r==1)||r==0) {
            return true;
        }
        return false;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reverse String]]></title>
    <link href="https://lockxmonk.github.io/15123699886595.html"/>
    <updated>2017-12-04T14:46:28+08:00</updated>
    <id>https://lockxmonk.github.io/15123699886595.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15123699886595/15123699978085.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string reverseString(string s) {
        int str = 0;
        int end = s.length()-1;
        while (str&lt;=end) {
            char tmp;
            tmp = s[str];
            s[str] = s[end];
            s[end] = tmp;
            str++;
            end--;
        }
        return s;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reverse Words in a String III]]></title>
    <link href="https://lockxmonk.github.io/15123539966341.html"/>
    <updated>2017-12-04T10:19:56+08:00</updated>
    <id>https://lockxmonk.github.io/15123539966341.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15123539966341/15123540495829.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string reverseWords(string s) {
        string res;
        int str = 0;
        for (int i=0; i&lt;s.length(); i++) {
            if (s[i]==&#39; &#39;||i==s.length()-1) {
                int j = i==s.length()-1 ? i:i-1;
                while (j&gt;=str) {
                    char tmp = s[str];
                    s[str] = s[j];
                    s[j] = tmp;
                    j--;
                    str++;
                }
                str = i+1;
            }
        }

        return s;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Judge Route Circle]]></title>
    <link href="https://lockxmonk.github.io/15122038176626.html"/>
    <updated>2017-12-02T16:36:57+08:00</updated>
    <id>https://lockxmonk.github.io/15122038176626.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15122038176626/15122038286763.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    bool judgeCircle(string moves) {
        int UD = 0 ,LR = 0;
        for(char a:moves){
            if (a==&#39;U&#39;) {
                UD++;
            }else if (a==&#39;D&#39;){
                UD--;
            }else if (a==&#39;L&#39;){
                LR++;
            }else if (a==&#39;R&#39;){
                LR--;
            }
        }
        return (UD==0&amp;&amp;LR==0) ? 1:0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Self Dividing Numbers]]></title>
    <link href="https://lockxmonk.github.io/15122027653799.html"/>
    <updated>2017-12-02T16:19:25+08:00</updated>
    <id>https://lockxmonk.github.io/15122027653799.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15122027653799/15122027840243.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; selfDividingNumbers(int left, int right) {
        vector&lt;int&gt; v;
        for (int i = left; i &lt;= right; ++i) {
            int j= i;
            bool ok = 1;
            while (j) {
                int d= (j%10);
                if (d == 0 || i % d) ok = 0;
                j/=10;
            }
            if (ok) v.push_back(i);
        }
        return v;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Non-decreasing Array]]></title>
    <link href="https://lockxmonk.github.io/15122009526780.html"/>
    <updated>2017-12-02T15:49:12+08:00</updated>
    <id>https://lockxmonk.github.io/15122009526780.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15122009526780/15122009632510.jpg" alt=""/></p>

<p><strong>用到了<code>is_sorted</code>来判断是否升序排列</strong></p>

<pre><code class="language-c++">class Solution {
public:
    bool checkPossibility(vector&lt;int&gt;&amp; nums) {
        for (int i=0; i &lt; nums.size()-1; i++){
            if (nums[i] &gt; nums[i+1]){
                
                int temp = nums[i];
                //
                // &quot;erase&quot; nums[i], then check if nums is sorted without nums[i]
                //
                nums[i] = nums[i+1];
                if (is_sorted(nums.begin(), nums.end())) { return true; }
                
                //
                // &quot;erase&quot; nums[i+1], then check if nums is sorted without nums[i+1]
                //
                nums[i+1] = nums[i] = temp;
                if (is_sorted(nums.begin(), nums.end())) { return true; }
                
                //
                // nums is NOT sorted (without nums[i] XOR without nums[i+1])
                //
                return false;
            }
        }
        return true;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Third Maximum Number]]></title>
    <link href="https://lockxmonk.github.io/15121974728141.html"/>
    <updated>2017-12-02T14:51:12+08:00</updated>
    <id>https://lockxmonk.github.io/15121974728141.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15121974728141/15121974890265.jpg" alt=""/></p>

<p><strong>利用set的自动排序和去除重复元素来解决问题。</strong></p>

<pre><code class="language-c++">class Solution {
public:
    int thirdMax(vector&lt;int&gt;&amp; nums) {
        set&lt;int&gt; result;
        for (int num:nums) {
            result.insert(num);
            if (result.size()&gt;3) {
                result.erase(result.begin());
            }
        }
        return result.size()&lt;3? *result.rbegin():*result.begin();
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K-diff Pairs in an Array]]></title>
    <link href="https://lockxmonk.github.io/15121892650067.html"/>
    <updated>2017-12-02T12:34:25+08:00</updated>
    <id>https://lockxmonk.github.io/15121892650067.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15121892650067/15121892810535.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findPairs(vector&lt;int&gt;&amp; nums, int k) {
        if (k&lt;0) {
            return 0;
        }
        unordered_set&lt;int&gt; result;  //用集合避免重复
        unordered_map&lt;int, int&gt; hash;   //hash表来映射所需数值
        for (int i = 0; i&lt;nums.size(); i++) {
            if (hash.count(nums[i]+k)) {
                result.insert(nums[i]+k);
            }
            if (hash.count(nums[i]-k)) {
                result.insert(nums[i]);
            }
            hash[nums[i]] += 1;
        }
        return result.size();
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shortest Unsorted Continuous Subarray]]></title>
    <link href="https://lockxmonk.github.io/15121252648085.html"/>
    <updated>2017-12-01T18:47:44+08:00</updated>
    <id>https://lockxmonk.github.io/15121252648085.html</id>
    <content type="html"><![CDATA[
<p>Given an integer array, you need to find one <strong>continuous</strong> subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.</p>

<p>You need to find the <strong>shortest</strong> such subarray and output its length.</p>

<p><img src="media/15121252648085/15121252900217.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; sortNums = nums;
        sort(sortNums.begin(), sortNums.end());
        int str = 0,end = nums.size()-1;
        while (nums[str]==sortNums[str]) {
            if (str==end) {
                return 0;
            }
            str++;
        }
        while (nums[end]==sortNums[end]) {
            end--;
        }
        return end-str+1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Can Place Flowers]]></title>
    <link href="https://lockxmonk.github.io/15121123646545.html"/>
    <updated>2017-12-01T15:12:44+08:00</updated>
    <id>https://lockxmonk.github.io/15121123646545.html</id>
    <content type="html"><![CDATA[
<p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p>

<p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.</p>

<p><img src="media/15121123646545/15121188914337.jpg" alt=""/></p>

<p><strong>第一种：3格的滑动窗口</strong></p>

<pre><code class="language-c++">class Solution {
public:
    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) {
        int str = 0 ,end = 2;
        int tol = 0;
        if (flowerbed.size()==1&amp;&amp;flowerbed[0]==0) {
            tol++;
        }else if(flowerbed[0]==0&amp;&amp;flowerbed[1]==0) {
            flowerbed[0]=1;
            tol++;
        }
        
        while (end&lt;=flowerbed.size()-1) {
            if (!(flowerbed[str]||flowerbed[str+1]||flowerbed[end])) {
                flowerbed[str+1] = 1;
                tol++;
            }
            str++;
            end++;
        }
        if (flowerbed.size()&gt;=3&amp;&amp;flowerbed[flowerbed.size()-1]==0&amp;&amp;flowerbed[flowerbed.size()-2]==0) {
            tol++;
        }
        return tol&gt;=n?1:0;
    }
};
</code></pre>

<p>第二种：</p>

<pre><code class="language-c++">class Solution {
public:
    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) {
        for (int i = 0; i &lt; flowerbed.size(); i++) {
            if (!flowerbed[i] &amp;&amp; (i == 0 || !flowerbed[i - 1]) &amp;&amp; (i == flowerbed.size() - 1 || !flowerbed[i + 1])) {
                flowerbed[i] = 1;
                n--;
            }
        }
        return n &lt;= 0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Contains Duplicate II]]></title>
    <link href="https://lockxmonk.github.io/15121120473287.html"/>
    <updated>2017-12-01T15:07:27+08:00</updated>
    <id>https://lockxmonk.github.io/15121120473287.html</id>
    <content type="html"><![CDATA[
<p>Given an array of integers and an integer <code>k</code>, find out whether there are two distinct indices <code>i</code> and <code>j</code> in the array such that <code>nums[i] = nums[j]</code> and the absolute difference between <code>i</code> and <code>j</code> is at most <code>k</code>.</p>

<p>判断数组中是否有重复的元素，并且下标之差不超过<code>k</code>。</p>

<pre><code class="language-c++">class Solution {
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int, int&gt; hash;
        for (int i=0; i&lt;nums.size(); i++) {
            if (hash.find(nums[i])!=hash.end()&amp;&amp;i-hash[nums[i]]&lt;=k) {
                return 1;
            }else{
                hash[nums[i]] = i;
            }
        }
        return 0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Sum]]></title>
    <link href="https://lockxmonk.github.io/15121110105671.html"/>
    <updated>2017-12-01T14:50:10+08:00</updated>
    <id>https://lockxmonk.github.io/15121110105671.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15121110105671/15121110244234.jpg" alt=""/></p>

<p><strong>运用hash表</strong></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hash;
        vector&lt;int&gt; result;
        for (int i=0; i&lt;nums.size(); i++) {
            int numToFind = target - nums[i];
            if (hash.find(numToFind)!=hash.end()) {
                result.push_back(hash[numToFind]);
                result.push_back(i);
            }
            hash[nums[i]] = i;
        }
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maximum Average Subarray I]]></title>
    <link href="https://lockxmonk.github.io/15120990794732.html"/>
    <updated>2017-12-01T11:31:19+08:00</updated>
    <id>https://lockxmonk.github.io/15120990794732.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15120990794732/15120991082558.jpg" alt=""/></p>

<p><strong>解决方法：滑动窗口方案</strong></p>

<pre><code class="language-c++">class Solution {
public:
    double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) {
        double r = INT_MIN;
        double sum = 0;
        for (int i = 0; i&lt;nums.size(); i++) {
            if (i&lt;k) {
                sum+=nums[i];
            }else{
                r = max(sum, r);
                sum +=nums[i]-nums[i-k];
            }
        }
        r = max(sum, r);
        return r/double(k);
    }
};
</code></pre>

]]></content>
  </entry>
  
</feed>
