<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2018-03-05T22:42:00+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[2015年蓝桥杯省赛C/C++ A组题解]]></title>
    <link href="https://lockxmonk.github.io/15197807986881.html"/>
    <updated>2018-02-28T09:19:58+08:00</updated>
    <id>https://lockxmonk.github.io/15197807986881.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">方程整数解</a>
</li>
<li>
<a href="#toc_1">星系炸弹</a>
<ul>
<li>
<a href="#toc_2">Excel电子表格法：</a>
</li>
</ul>
</li>
<li>
<a href="#toc_3">奇妙的数字</a>
</li>
<li>
<a href="#toc_4">格子中输出</a>
</li>
<li>
<a href="#toc_5">九数组分数</a>
</li>
<li>
<a href="#toc_6">牌型种数</a>
</li>
<li>
<a href="#toc_7">手链样式</a>
</li>
<li>
<a href="#toc_8">饮料换购</a>
</li>
</ul>


<h2 id="toc_0">方程整数解</h2>

<p>方程: a<sup>2</sup> + b<sup>2</sup> + c<sup>2</sup> = 1000 <br/>
这个方程有整数解吗？有：a,b,c=6,8,30 就是一组解。 <br/>
你能算出另一组合适的解吗？ <br/>
请填写该解中最小的数字。 <br/>
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p>

<p>直接暴力枚举。。</p>

<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main()
{
    for (int i=1;i&lt;=33;i++) {
        for (int j=i;j&lt;=33;j++) {
            for (int k=j;k&lt;=33;k++) {
                if (i*i+j*j+k*k==1000) {
                    printf(&quot;%d %d %d\n&quot;,i,j,k);
                }
            }
        }
    }
    return 0;
}
</code></pre>

<p>答案是10.</p>

<h2 id="toc_1">星系炸弹</h2>

<p>在X星系的广袤空间中漂浮着许多X星人造“炸弹”，用来作为宇宙中的路标。 <br/>
每个炸弹都可以设定多少天之后爆炸。 <br/>
比如：阿尔法炸弹2015年1月1日放置，定时为15天，则它在2015年1月16日爆炸。 <br/>
有一个贝塔炸弹，2014年11月9日放置，定时为1000天，请你计算它爆炸的准确日期。 <br/>
请填写该日期，格式为 yyyy-mm-dd <br/>
即4位年份2位月份2位日期。比如： <br/>
2015-02-19 <br/>
请严格按照格式书写。不能出现其它文字或符号。</p>

<p>这个直接excel或者手算就可以了。。</p>

<p>计算： <br/>
    2014.11. 9----2015. 1. 1       53天<br/><br/>
    2015. 1. 1 ----2017. 1. 1     731天<br/><br/>
    2017. 1. 1 ----2017. 8. 1     212天<br/><br/>
    2017. 8. 1 ----2017. 8. 5      4天<br/>
    53+731+212+4=1000天</p>

<h3 id="toc_2">Excel电子表格法：</h3>

<p>打开Excel电子表格，在单元格A1中输入2014/11/9，在单元格B1中输入公式=A1+1000即可得到答案。<br/>
但是Excel中有效日期为1900年1月1日以后的日期，1900年以前的日期无法正常显示。<img src="media/15197807986881/15197811893178.jpg" alt=""/></p>

<h2 id="toc_3">奇妙的数字</h2>

<p>小明发现了一个奇妙的数字。它的平方和立方正好把0~9的10个数字每个用且只用了一次。 <br/>
你能猜出这个数字是多少吗？ <br/>
请填写该数字，不要填写任何多余的内容。</p>

<p>还是暴力枚举就可以了。</p>

<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int b[10];

void solu(int x,int b[])
{
    while (x) {
        b[x%10]++;
        x/=10;
    }
}

int main()
{
    for (int i=1,j;i&lt;9999;i++) {
        memset(b,0,sizeof(b));
        solu(i*i,b);
        solu(i*i*i,b);
        for (j=0;j&lt;=9;j++)
            if (b[j]!=1) break;
        //每个b[i]都等于1，j才会大于9
        if (j&gt;9) {
            printf(&quot;%d\n&quot;,i);
            break;
        }
    }
    return 0;
}
</code></pre>

<h2 id="toc_4">格子中输出</h2>

<p>StringInGrid函数会在一个指定大小的格子中打印指定的字符串。 <br/>
要求字符串在水平、垂直两个方向上都居中。 <br/>
如果字符串太长，就截断。 <br/>
如果不能恰好居中，可以稍稍偏左或者偏上一点。 <br/>
<strong>下面的程序实现这个逻辑，请填写划线部分缺少的代码。</strong></p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void StringInGrid(int width, int height, const char* s)
{
    int i,k;
    char buf[1000];
    strcpy(buf, s);
    if(strlen(s)&gt;width-2) buf[width-2]=0;
    
    printf(&quot;+&quot;);
    for(i=0;i&lt;width-2;i++) printf(&quot;-&quot;);
    printf(&quot;+\n&quot;);
    
    for(k=1; k&lt;(height-1)/2;k++){
        printf(&quot;|&quot;);
        for(i=0;i&lt;width-2;i++) printf(&quot; &quot;);
        printf(&quot;|\n&quot;);
    }
    
    printf(&quot;|&quot;);
    
    printf(&quot;%*s%s%*s&quot;,_____________________________________________);  //填空
              
    printf(&quot;|\n&quot;);
    
    for(k=(height-1)/2+1; k&lt;height-1; k++){
        printf(&quot;|&quot;);
        for(i=0;i&lt;width-2;i++) printf(&quot; &quot;);
        printf(&quot;|\n&quot;);
    }   
    
    printf(&quot;+&quot;);
    for(i=0;i&lt;width-2;i++) printf(&quot;-&quot;);
    printf(&quot;+\n&quot;);  
}

int main()
{
    StringInGrid(20,6,&quot;abcd1234&quot;);
    return 0;
}
</code></pre>

<p>很明显，填空的上面是输出上半部分，下面是输出下半部分，所以我们填的这个就是正中间那行。 <br/>
要做这题首先要知道<code>%*s</code>是个什么。。。<br/>
反正当年是没填出的居多 <strong>输出控制符</strong> <br/>
也就是说碰到<code>*</code>的时候我们要额外给一个整型参数控制宽度。</p>

<p>我们看到第9行，buf已经完成了截断，而s没有截断，所以我们要用也只能用buf。 <br/>
然后我们算出左边右边的宽度，<strong>值得注意的是，左右的宽度表达式是不一样的。 <br/>
因为题目里说了不对称是要靠左，</strong>可以把abcd1234最后的4去掉看看效果。 <br/>
感觉查了这么多博客都没一个人填对的。。。唉= =</p>

<p><code>答案：(width-strlen(buf)-2)/2,&quot;&quot;,buf,(width-strlen(buf)-2+1)/2,&quot;&quot;</code></p>

<h2 id="toc_5">九数组分数</h2>

<p>1,2,3…9 这九个数字组成一个分数，其值恰好为1/3，如何组法？ <br/>
下面的程序实现了该功能，请填写划线部分缺失的代码。</p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;

void test(int x[])
{
    int a = x[0]*1000 + x[1]*100 + x[2]*10 + x[3];
    int b = x[4]*10000 + x[5]*1000 + x[6]*100 + x[7]*10 + x[8];

    if(a*3==b) printf(&quot;%d / %d\n&quot;, a, b);
}

void f(int x[], int k)
{
    int i,t;
    if(k&gt;=9){
        test(x);
        return;
    }

    for(i=k; i&lt;9; i++){
        {t=x[k]; x[k]=x[i]; x[i]=t;}
        f(x,k+1);
        _________________________________ // 填空处
    }
}

int main()
{
    int x[] = {1,2,3,4,5,6,7,8,9};
    f(x,0);  
    return 0;
}
</code></pre>

<p>这主要考的是回溯的基本概念 回溯资料<br/><br/>
简单的说这一次做的改变肯定要复原。</p>

<p><strong>答案：{t=x[k]; x[k]=x[i]; x[i]=t;}</strong></p>

<h2 id="toc_6">牌型种数</h2>

<p>小明被劫持到X赌城，被迫与其他3人玩牌。 <br/>
一副扑克牌（去掉大小王牌，共52张），均匀发给4个人，每个人13张。 <br/>
这时，小明脑子里突然冒出一个问题： <br/>
如果不考虑花色，只考虑点数，也不考虑自己得到的牌的先后顺序，自己手里能拿到的初始牌型组合一共有多少种呢？ </p>

<p>请填写该整数，不要填写任何多余的内容或说明文字。</p>

<p>dfs，当然首先要知道每个数字都有四张牌。</p>

<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int cnt[15],ans=0;

void dfs(int dep,int last)
{
    if (dep&gt;13) {
        ans++;
        return;
    }
    for (int i=last;i&lt;=13;i++) {
        if (cnt[i]&lt;4) {
            cnt[i]++;
            dfs(dep+1,i);
            cnt[i]--;
        }
    }
}

int main()
{
    dfs(1,1);
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>

<p>答案：3598180</p>

<h2 id="toc_7">手链样式</h2>

<p>小明有3颗红珊瑚，4颗白珊瑚，5颗黄玛瑙。 <br/>
他想用它们串成一圈作为手链，送给女朋友。 <br/>
现在小明想知道：如果考虑手链可以随意转动或翻转，一共可以有多少不同的组合样式呢？ 请你提交该整数。不要填写任何多余的内容或说明性的文字。</p>

<pre><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
using namespace std;

int res[10000][12],a[12];

bool same(int a[],int b[])
{
    for (int k=0;k&lt;12;k++) {
        bool f=true;
        for (int i=0;i&lt;12;i++) {
            if (a[i]!=b[(i+k)%12]) {        //因为是环形，不固定起点。所以用(i+k)%12
                f=false;
                break;
            }
        }
        if (f) return true;
        f=true;
        for (int i=0;i&lt;12;i++) {
            if (a[11-i]!=b[(i+k)%12]) {     //又因为可以翻转所以 从左边或者右边都应该检查。
                f=false;
                break;
            }
        }
        if (f) return true;
    }
    return false;
}

int main()
{
    int ans=0;
    a[0]=a[1]=a[2]=1;
    a[3]=a[4]=a[5]=a[6]=2;
    a[7]=a[8]=a[9]=a[10]=a[11]=3;
    do {
        bool ok=true;
        for (int i=1;i&lt;=ans;i++) {
            if (same(res[i],a)) {
                ok=false;
                break;
            }
        }
        if (ok) {
            ans++;
            for (int i=0;i&lt;12;i++) {
                res[ans][i]=a[i];
            }
        }
    } while (next_permutation(a,a+12));
    printf(&quot;%d\n&quot;,ans);
    return 0;
}

</code></pre>

<p>首先来分析一下题目：3类珠子，一共12个，我们用字符串a=&quot;333444455555“表示，要求环形的排列数，注意理解可以随意转动或翻转，这跟直线型的有不同。举个例子：</p>

<p>例如，在直线型排列中a=&quot;333444455555“ 和 b=&quot;444455555333“ 是不同的排列，原因是直线型的起点是固定的，对应位置元素只要有一个不同，则排列不同。但是在环形里面，由于可以任意转动，也就是起点不固定的，当b以第一个3为起点时往右数时，它就和a完全一样了。另外，任意翻转的意思是b不但起点不固定，而且排列的方向可以往右数，也可以往左数。</p>

<p>dfs写起来比较难受，这题就用next_permutation，改函数的方法是对数组从低到高逐次进行全排列。若可以进行排列就返回true，反之false<br/>
所以只要把所有答案都记录下来，每次都正反判断一遍即可。</p>

<h2 id="toc_8">饮料换购</h2>

<p>乐羊羊饮料厂正在举办一次促销优惠活动。乐羊羊C型饮料，凭3个瓶盖可以再换一瓶C型饮料，并且可以一直循环下去(但不允许暂借或赊账)。<br/>
请你计算一下，如果小明不浪费瓶盖，尽量地参加活动，那么，对于他初始买入的n瓶饮料，最后他一共能喝到多少瓶饮料。</p>

<p>输入：一个整数n，表示开始购买的饮料数量（0 &lt; n &lt; 10000） <br/>
输出：一个整数，表示实际得到的饮料数<br/>
例如： <br/>
用户输入： <br/>
100 <br/>
程序应该输出： <br/>
149<br/>
用户输入： <br/>
101 <br/>
程序应该输出： <br/>
151<br/>
资源约定： <br/>
峰值内存消耗 &lt; 256M <br/>
CPU消耗 &lt; 1000ms</p>

<p>这道题简单模拟即可。</p>

<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

int main()
{
    int s,n;
    scanf(&quot;%d&quot;,&amp;n);
    s=n;
    while (n&gt;=3) {
        s+=n/3;
        n=n/3+n%3;
    }
    printf(&quot;%d\n&quot;,s);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2016年第七届蓝桥杯C/C++程序设计本科B组省赛]]></title>
    <link href="https://lockxmonk.github.io/15196931743279.html"/>
    <updated>2018-02-27T08:59:34+08:00</updated>
    <id>https://lockxmonk.github.io/15196931743279.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">1.煤球数目</a>
</li>
<li>
<a href="#toc_1">2.生日蜡烛</a>
</li>
<li>
<a href="#toc_2">3.凑算式</a>
</li>
<li>
<a href="#toc_3">4.快速排序</a>
</li>
<li>
<a href="#toc_4">网友年龄（A组）</a>
</li>
<li>
<a href="#toc_5">方格填数</a>
</li>
<li>
<a href="#toc_6">消除尾一</a>
</li>
<li>
<a href="#toc_7">寒假作业</a>
</li>
<li>
<a href="#toc_8">剪邮票</a>
</li>
<li>
<a href="#toc_9">四平方和</a>
</li>
<li>
<a href="#toc_10">密码脱落</a>
</li>
</ul>


<h2 id="toc_0">1.煤球数目</h2>

<p>有一堆煤球，堆成三角棱锥形。具体：<br/>
第一层放1个，<br/>
第二层3个（排列成三角形），<br/>
第三层6个（排列成三角形），<br/>
第四层10个（排列成三角形），<br/>
....<br/>
如果一共有100层，共有多少个煤球？</p>

<p>请填表示煤球总数目的数字。</p>

<p>思路：1 2 3 4 5 6……这一个等差数列的前n项和为(1+n)*n/2</p>

<p>第1层的煤球数目为1</p>

<p>第2层的煤球数目为1+2</p>

<p>第3层的煤球数目为1+2+3</p>

<p>……</p>

<p>第i层的煤球数组为(1+n)*n/2</p>

<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main()
{
    int sum=0,n;
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;i++)
    {
        sum+=i*(i+1)/2;
    }
    cout&lt;&lt;sum&lt;&lt;endl;
    return 0;
}

</code></pre>

<h2 id="toc_1">2.生日蜡烛</h2>

<p>某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。<br/>
现在算起来，他一共吹熄了236根蜡烛。<br/>
请问，他从多少岁开始过生日party的？<br/>
请填写他开始过生日party的年龄数</p>

<p>思路：1 2 3 4 5 6……这一个等差数列的前n项和为(1+n)*n/2</p>

<p>设从a岁开始过生日，到了b岁一共吹熄了236根蜡烛。</p>

<p>即为：(a+b)(b-a+1)/2=236</p>

<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main()
{
    for(int i=1;i&lt;=100;i++)
        for(int j=i;j&lt;=100;j++)
        {
            if((i+j)*(j-i+1)/2==236)
                cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;endl;
        }
    
    return 0;
}

</code></pre>

<h2 id="toc_2">3.凑算式</h2>

<p>如图，这个算式中A~I代表1~9的数字，不同的字母代表不同的数字。<br/>
<img src="media/15196931743279/15196949623359.jpg" alt=""/></p>

<p>比如：<br/>
6+8/3+952/714 就是一种解法，<br/>
5+3/1+972/486 是另一种解法。</p>

<p>这个算式一共有多少种解法？</p>

<p>思路：暴力解决，注意每个字母代表的数字不相等。</p>

<p>答案：29</p>

<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main()
{
    int sum=0;
    for(int a=1; a&lt;=9; a++)
        for(int b=1; b&lt;=9; b++)
        {
            if(a==b) continue;
            for(int c=1; c&lt;=9; c++)
            {
                if(c==a||c==b) continue;
                for(int d=1; d&lt;=9; d++)
                {
                    if(d==a||d==b||d==c)continue;
                    for(int e=1; e&lt;=9; e++)
                    {
                        if(e==a||e==b||e==c||e==d) continue;
                        for(int f=1; f&lt;=9; f++)
                        {
                            if(f==a||f==b||f==c||f==d||f==e) continue;
                            for(int g=1; g&lt;=9; g++)
                            {
                                if(g==a||g==b||g==c||g==d||g==e||g==f) continue;
                                for(int h=1; h&lt;=9; h++)
                                {
                                    if(h==a||h==b||h==c||h==d||h==e||h==f||h==g) continue;
                                    for(int i=1; i&lt;=9; i++)
                                    {
                                        if(i==a||i==b||i==c||i==d||i==e||i==f||i==g||i==h) continue;
                                        int t1=a*c*(100*g+10*h+i);
                                        int t2=b*(100*g+10*h+i);
                                        int t3=c*(100*d+10*e+f);
                                        int t4=10*c*(100*g+10*h+i);
                                        if(t1+t2+t3==t4)
                                            sum++;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

    cout&lt;&lt;sum&lt;&lt;endl;
    return 0;
}
</code></pre>

<h2 id="toc_3">4.快速排序</h2>

<p>排序在各种场合经常被用到。<br/>
快速排序是十分常用的高效率的算法。</p>

<p>其思想是：先选一个“标尺”，<br/>
用它把整个队列过一遍筛子，<br/>
以保证：其左边的元素都不大于它，其右边的元素都不小于它。</p>

<p>这样，排序问题就被分割为两个子区间。<br/>
再分别对子区间排序就可以了。</p>

<p>下面的代码是一种实现，请分析并填写划线部分缺少的代码。</p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;

void swap(int a[], int i, int j)
{
    int t = a[i];
    a[i] = a[j];
    a[j] = t;
}

int partition(int a[], int p, int r)
{
    int i = p;
    int j = r + 1;
    int x = a[p];
    while(1){
        while(i&lt;r &amp;&amp; a[++i]&lt;x);
        while(a[--j]&gt;x);
        if(i&gt;=j) break;
        swap(a,i,j);
    }
    _______________;//填空位置
    return j;
}

void quicksort(int a[], int p, int r)
{
    if(p&lt;r){
        int q = partition(a,p,r);
        quicksort(a,p,q-1);
        quicksort(a,q+1,r);
    }
}
    
int main()
{
    int i;
    int a[] = {5,13,6,24,2,8,19,27,6,12,1,17};
    int N = 12;
    
    quicksort(a, 0, N-1);
    
    for(i=0; i&lt;N; i++) printf(&quot;%d &quot;, a[i]);
    printf(&quot;\n&quot;);
    
    return 0;
}

</code></pre>

<p>思路：快速排序，填空位置为经过比较之后，将最初选的“标尺”放在中间，即：标尺左边的数小于标尺，右边的数则大于它。注意不要多填分号。</p>

<p>答案：<code>swap(a,p,j)</code></p>

<h2 id="toc_4">网友年龄（A组）</h2>

<p>某君新认识一网友。 当问及年龄时，他的网友说： “我的年龄是个2位数，我比儿子大27岁, 如果把我的年龄的两位数字交换位置，刚好就是我儿子的年龄” <br/>
请你计算：网友的年龄一共有多少种可能情况？ <br/>
提示：30岁就是其中一种可能哦. 请填写表示可能情况的种数。 <br/>
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p>

<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main()
{
    int m = 0;
    for(int i=0;i&lt;=9;i++)
        for(int j=0;j&lt;=9;j++)
        {
            if(9*(i-j)==27){
                m++;
            }
                
        }
    cout&lt;&lt;m&lt;&lt;endl;
    return 0;
}

</code></pre>

<p><strong>枚举一下：7</strong></p>

<h2 id="toc_5">方格填数</h2>

<p>如下的10个格子 <br/>
<img src="media/15196931743279/15196986302778.jpg" alt=""/><br/>
填入0~9的数字。要求：连续的两个数字不能相邻。 （左右、上下、对角都算相邻） <br/>
一共有多少种可能的填数方案？ <br/>
请填写表示方案数目的整数。 <br/>
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;
using namespace std;

/*本来要判断八个格子，
 *但是由于是从左往右从上往下填的，
 *只要判断左、左上、上、右上
 */
const int dx[]={0,-1,-1,-1};
const int dy[]={-1,-1,0,1};
const int INF=1e9;
bool used[10];
int ans=0;
int a[5][5];

bool alright(int n,int x,int y)
{
    for (int i=0;i&lt;4;i++) {
        int xx=x+dx[i],yy=y+dy[i];
        if (xx&lt;1||yy&lt;1||xx&gt;3||yy&gt;4) continue;
        if (abs(n-a[xx][yy])==1) return false;
    }
    return true;
}

void dfs(int x,int y)
{
    if (x==3&amp;&amp;y==4) {
        ans++;
        return;
    }
    for (int i=0;i&lt;=9;i++) {
        if (!used[i]&amp;&amp;alright(i,x,y)) {
            a[x][y]=i;
            used[i]=true;
            if (y==4) dfs(x+1,1);
            else dfs(x,y+1);
            used[i]=false;
            a[x][y]=-INF;
        }
    }
}

int main()
{
    for (int i=1;i&lt;=3;i++) {
        for (int j=1;j&lt;=4;j++) {
            a[i][j]=-INF;
        }
    }
    dfs(1,2);
    printf(&quot;%d\n&quot;,ans);
    return 0;
}

</code></pre>

<p><strong>正确答案：1580</strong></p>

<h2 id="toc_6">消除尾一</h2>

<p>下面的代码把一个整数的二进制表示的最右边的连续的1全部变成0 <br/>
如果最后一位是0，则原数字保持不变。 <br/>
如果采用代码中的测试数据，应该输出：</p>

<blockquote>
<p>00000000000000000000000001100111     00000000000000000000000001100000<br/>
00000000000000000000000000001100     00000000000000000000000000001100  </p>
</blockquote>

<p>请仔细阅读程序，填写划线部分缺少的代码。</p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;

void f(int x) 
{  
    int i; 
    for(i=0; i&lt;32; i++) printf(&quot;%d&quot;, (x&gt;&gt;(31-i))&amp;1);  
    printf(&quot;   &quot;);

    x = _______________________;   

    for(i=0; i&lt;32; i++) printf(&quot;%d&quot;, (x&gt;&gt;(31-i))&amp;1);  
    printf(&quot;\n&quot;);  
}

int main() 
{ 
    f(103);  
    f(12);  
    return 0; 
}
</code></pre>

<p>要消除x末尾所有的1，可以先把x加上1：</p>

<p>00000000000000000000000001100111 + 1 =<br/>
00000000000000000000000001101000</p>

<p>答案为：x&amp;(x+1)</p>

<h2 id="toc_7">寒假作业</h2>

<p>现在小学的数学题目也不是那么好玩的。 <br/>
看看这个寒假作业： <br/>
□ + □ = □ <br/>
□ - □ = □ <br/>
□ × □ = □ <br/>
□ ÷ □ = □ <br/>
每个方块代表1~13中的某一个数字，但不能重复。 <br/>
比如： <br/>
6 + 7 = 13 <br/>
9 - 8 = 1 <br/>
3 * 4 = 12 <br/>
10 / 2 = 5 <br/>
以及： <br/>
7 + 6 = 13 <br/>
9 - 8 = 1 <br/>
3 * 4 = 12 <br/>
10 / 2 = 5 <br/>
就算两种解法。（加法，乘法交换律后算不同的方案） <br/>
你一共找到了多少种方案？ <br/>
请填写表示方案数目的整数。 <br/>
注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p>

<pre><code class="language-c++">#include &lt;bits/stdc++.h&gt;
using namespace std;

bool used[15];
int a[15];
int ans=0;

void dfs(int dep)
{
    if (dep==13) {
        //必须整除，变成乘法判断
        if (a[10]==a[11]*a[12]) ans++;
        return;
    }
    if (dep==10) {
        if (a[7]*a[8]!=a[9]) return;
    }
    if (dep==7) {
        if (a[4]-a[5]!=a[6]) return;
    }
    if (dep==4) {
        if (a[1]+a[2]!=a[3]) return;
    }
    for (int i=1;i&lt;=13;i++) {
        if (!used[i]) {
            used[i]=true;
            a[dep]=i;
            dfs(dep+1);
            a[dep]=-1;
            used[i]=false;
        }
    }
}

int main()
{
    dfs(1);
    printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>

<p>**答案：64 **</p>

<h2 id="toc_8">剪邮票</h2>

<p>如【图1.jpg】, 有12张连在一起的12生肖的邮票。 <br/>
现在你要从中剪下5张来，要求必须是连着的。 （仅仅连接一个角不算相连） <br/>
比如，【图2.jpg】，【图3.jpg】中，粉红色所示部分就是合格的剪取。<img src="media/15196931743279/15196995565395.jpg" alt=""/><br/>
<img src="media/15196931743279/15196995582711.jpg" alt=""/><br/>
<img src="media/15196931743279/15196995604055.jpg" alt=""/></p>

<p>思路：先找到5个数的组合，然后从第一个数字开始遍历，经过上下左右操作检测5个数是否都被访问一遍，如果5个数都可以遍历到则种类+1。</p>

<p>在原图中向上为-4，向下为+4，向左为-1，向右为+1，但是遇到3 4 5 7 8这种4+1=5但是这种情况不符合，所以重构一下原图：<br/>
<img src="media/15196931743279/15196999942024.jpg" alt=""/></p>

<p>这样，向上为-5，向下为+5，向左为-1，向右为+1，避免了每行最后一个+1后等于下一行第一个的情况。</p>

<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int mp[12]= {1,2,3,4,6,7,8,9,11,12,13,14};
int aa[5],vis[5],sum=0;
int b[4]= {-1,1,-5,+5};
void dfs(int n)
{
    for(int i=0; i&lt;4; i++)
    {
        int t=aa[n]+b[i];
        if(t&lt;1||t&gt;14||t==5||t==10) continue;
        for(int j=0; j&lt;5; j++)
            if(!vis[j]&amp;&amp;aa[j]==t)
            {
                vis[j]=1;
                dfs(j);
            }
    }
}

int main()
{

    for(int a=0; a&lt;12; a++)
        for(int b=a+1; b&lt;12; b++)
            for(int c=b+1; c&lt;12; c++)
                for(int d=c+1; d&lt;12; d++)
                    for(int e=d+1; e&lt;12; e++)
                    {
                        aa[0]=mp[a];
                        aa[1]=mp[b];
                        aa[2]=mp[c];
                        aa[3]=mp[d];
                        aa[4]=mp[e];
                        for(int i=0; i&lt;5; i++)
                            vis[i]=0;
                        vis[0]=1;
                        dfs(0);
                        int flag=1;;
                        for(int i=0; i&lt;5; i++)
                        {
                            if(vis[i]!=1)
                            {
                                flag=0;
                                break;
                            }
                        }
                        if(flag==0) continue;
                        else
                            sum++;
                    }

    cout&lt;&lt;sum&lt;&lt;endl;

    return 0;
}
</code></pre>

<p><strong>答案：116</strong></p>

<h2 id="toc_9">四平方和</h2>

<p>四平方和定理，又称为拉格朗日定理： <br/>
每个正整数都可以表示为至多4个正整数的平方和。 <br/>
如果把0包括进去，就正好可以表示为4个数的平方和。<br/>
比如： <br/>
5 = 0<sup>2</sup> + 0<sup>2</sup> + 1<sup>2</sup> + 2<sup>2</sup> <br/>
7 = 1<sup>2</sup> + 1<sup>2</sup> + 1<sup>2</sup> + 2<sup>2</sup> <br/>
（<sup>符号表示乘方的意思）</sup><br/>
对于一个给定的正整数，可能存在多种平方和的表示法。 <br/>
要求你对4个数排序： 0 &lt;= a &lt;= b &lt;= c &lt;= d <br/>
并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法<br/>
程序输入为一个正整数N (N&lt;5000000) <br/>
要求输出4个非负整数，按从小到大排序，中间用空格分开<br/>
例如，输入： <br/>
5 <br/>
则程序应该输出： <br/>
0 0 1 2 <br/>
再例如，输入： <br/>
12 <br/>
则程序应该输出： <br/>
0 2 2 2 <br/>
再例如，输入： <br/>
773535 <br/>
则程序应该输出： <br/>
1 1 267 838<br/>
资源约定： <br/>
峰值内存消耗 &lt; 256M <br/>
CPU消耗 &lt; 3000ms</p>

<p>直接暴力解决。。</p>

<pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;math.h&gt;
using namespace std;
int mp[12]= {1,2,3,4,6,7,8,9,11,12,13,14};
int aa[5],vis[5],sum=0;
int b[4]= {-1,1,-5,+5};

void resolve(int n){
    for (int d = 0; d&lt;=sqrt(n); d++) {
        for (int c=0; c&lt;=sqrt(n); c++) {
            for (int b=0; b&lt;=sqrt(n); b++) {
                for (int a=0; a&lt;=sqrt(n); a++) {
                    if (a*a+b*b+c*c+d*d==n) {
                        cout&lt;&lt;d&lt;&lt;c&lt;&lt;b&lt;&lt;a&lt;&lt;endl;
                        return;
                    }
                }
            }
        }
    }
}

int main()
{
    int n=0;
    cin&gt;&gt;n;
    resolve(n);
    return 0;
}

</code></pre>

<h2 id="toc_10">密码脱落</h2>

<p>X星球的考古学家发现了一批古代留下来的密码。 <br/>
这些密码是由A、B、C、D 四种植物的种子串成的序列。 <br/>
仔细分析发现，这些密码串当初应该是前后对称的（也就是我们说的镜像串）。 <br/>
由于年代久远，其中许多种子脱落了，因而可能会失去镜像的特征。<br/>
你的任务是： 给定一个现在看到的密码串，计算一下从当初的状态，它要至少脱落多少个种子，才可能会变成现在的样子。<br/>
输入一行，表示现在看到的密码串（长度不大于1000） <br/>
要求输出一个正整数，表示至少脱落了多少个种子。<br/>
例如，输入： <br/>
ABCBA <br/>
则程序应该输出： <br/>
0 <br/>
再例如，输入： <br/>
ABDCDCBABC <br/>
则程序应该输出： <br/>
3<br/>
资源约定： <br/>
峰值内存消耗 &lt; 256M <br/>
CPU消耗 &lt; 1000ms</p>

<hr/>

<p>由于是对称的，所以本体可以使用动态规划来将原字符串跟逆序字符串进行比较，来求最大公共子序列（不是串，可以是不连续的）</p>

<p>dp[i][j]保存的是原串的i号位置之前的所有字符跟逆序串的j号位置之前的所有字符的最大公共子序列（包括i,j号位置）</p>

<p>最后用当前字符串长度n减去dp[n][n]就是结果，dp[n][n]是对所有字符进行计算之后的结果。</p>

<hr/>

<pre><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;iostream&gt;
using namespace std;

char s[1010];
int dp[1010][1010];

int main()
{
    scanf(&quot;%s&quot;,s+1);
    int n=strlen(s+1);
    for (int i=1;i&lt;=n;i++) {
        for (int j=1;j&lt;=n;j++) {
            if (s[i]==s[n+1-j]) {
                dp[i][j]=dp[i-1][j-1]+1;
            } else {
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        }
    }
    printf(&quot;%d\n&quot;,n-dp[n][n]);
    return 0;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[2017第八届蓝桥杯C/C++ B组省赛]]></title>
    <link href="https://lockxmonk.github.io/15196116405308.html"/>
    <updated>2018-02-26T10:20:40+08:00</updated>
    <id>https://lockxmonk.github.io/15196116405308.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">第一题 购物单</a>
</li>
<li>
<a href="#toc_1">第二题 等差素数列</a>
</li>
<li>
<a href="#toc_2">第三题 承压计算</a>
</li>
<li>
<a href="#toc_3">第四题  方格分割</a>
</li>
<li>
<a href="#toc_4">第六题 最大公共子串</a>
</li>
<li>
<a href="#toc_5">第七题 日期问题</a>
</li>
<li>
<a href="#toc_6">输入</a>
</li>
<li>
<a href="#toc_7">输出</a>
</li>
<li>
<a href="#toc_8">样例输入</a>
</li>
<li>
<a href="#toc_9">样例输出</a>
</li>
<li>
<a href="#toc_10">第八题 包子凑数</a>
</li>
<li>
<a href="#toc_11">第九题 分巧克力</a>
</li>
<li>
<a href="#toc_12">第十题 k倍区间</a>
</li>
<li>
<a href="#toc_13">输入</a>
</li>
<li>
<a href="#toc_14">输出</a>
</li>
</ul>


<h2 id="toc_0">第一题 购物单</h2>

<p>小明刚刚找到工作，老板人很好，只是老板夫人很爱购物。老板忙的时候经常让小明帮忙到商场代为购物。小明很厌烦，但又不好推辞。</p>

<p>这不，XX大促销又来了！老板夫人开出了长长的购物单，都是有打折优惠的。<br/>
小明也有个怪癖，不到万不得已，从不刷卡，直接现金搞定。<br/>
现在小明很心烦，请你帮他计算一下，需要从取款机上取多少现金，才能搞定这次购物。</p>

<p>取款机只能提供100元面额的纸币。小明想尽可能少取些现金，够用就行了。<br/>
你的任务是计算出，小明最少需要取多少现金。</p>

<p>以下是让人头疼的购物单，为了保护隐私，物品名称被隐藏了</p>

<pre><code>--------------------
****     180.90       88折
****      10.25       65折
****      56.14        9折
****     104.65        9折
****     100.30       88折
****     297.15       半价
****      26.75       65折
****     130.62       半价
****     240.28       58折
****     270.62        8折
****     115.87       88折
****     247.34       95折
****      73.21        9折
****     101.00       半价
****      79.54       半价
****     278.44        7折
****     199.26       半价
****      12.97        9折
****     166.30       78折
****     125.50       58折
****      84.98        9折
****     113.35       68折
****     166.57       半价
****      42.56        9折
****      81.90       95折
****     131.78        8折
****     255.89       78折
****     109.17        9折
****     146.69       68折
****     139.33       65折
****     141.16       78折
****     154.74        8折
****      59.42        8折
****      85.44       68折
****     293.70       88折
****     261.79       65折
****      11.30       88折
****     268.27       58折
****     128.29       88折
****     251.03        8折
****     208.39       75折
****     128.88       75折
****      62.06        9折
****     225.87       75折
****      12.89       75折
****      34.28       75折
****      62.16       58折
****     129.12       半价
****     218.37       半价
****     289.69       8折
--------------------
</code></pre>

<p>需要说明的是，88折指的是按标价的88%计算，而8折是按80%计算，余者类推。<br/>
特别地，半价是按50%计算。</p>

<p>请提交小明要从取款机上提取的金额，单位是元。<br/>
答案是一个整数，类似4300的样子，结尾必然是00，不要填写任何多余的内容。</p>

<p>特别提醒：不许携带计算器入场，也不能打开手机。</p>

<p><strong>解答：</strong> 就是基本的运算。</p>

<pre><code class="language-c++">#include&lt;stdio.h&gt;
main()
{
    float a;
    a = 180.90*0.88+10.25*0.65+56.14*0.9+104.65*0.9+100.3*0.88+297.15*0.5+26.75*0.65+130.62*0.5 
    +240.28*0.58+270.62*0.8+115.87*0.88+247.34*0.95+73.21*0.9+101*0.5+79.54*0.5+278.44*0.7+199.26*0.5 
    +12.97*0.9+166.30*0.78+125.50*0.58+84.98*0.9+113.35*0.68+166.57*0.5+42.56*0.9+81.90*0.95 
    +131.78*0.8+255.89*0.78+109.17*0.9+146.69*0.68+139.33*0.65+141.16*0.78+154.74*0.8+59.42*0.8 
    +85.44*0.68+293.70*0.88+261.79*0.65+11.30*0.88+268.27*0.58+128.29*0.88+251.03*0.8+208.39*0.75 
    +128.88*0.75+62.06*0.9+225.87*0.75+12.89*0.75+34.28*0.75+62.16*0.58+129.12*0.5+218.37*0.5+289.69*0.8; 
    printf(&quot;%f&quot;,a);
} 
</code></pre>

<p><strong>算出来结果为5136.859375 取钱应为5200</strong></p>

<h2 id="toc_1">第二题 等差素数列</h2>

<p>2,3,5,7,11,13,....是素数序列。</p>

<p>类似：7,37,67,97,127,157 这样完全由素数组成的等差数列，叫等差素数数列。<br/>
上边的数列公差为30，长度为6。</p>

<p>2004年，格林与华人陶哲轩合作证明了：存在任意长度的素数等差数列。<br/>
这是数论领域一项惊人的成果！</p>

<p>有这一理论为基础，请你借助手中的计算机，满怀信心地搜索：</p>

<p>长度为10的等差素数列，其公差最小值是多少？</p>

<p>注意：需要提交的是一个整数，不要填写任何多余的内容和说明文字。</p>

<p><strong>先用素数筛筛出素数，然后暴力</strong></p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;memory.h&gt;
#include &lt;iostream&gt;
using namespace std;
int p[100010];
int prim[100010];
int len=0;
void isp()
{
    //构造素数数列
    memset(p,0,sizeof(p));
    p[0]=1;p[1]=1;p[2]=0;
    for(int i=0;i&lt;10000;i++)
    {
        if(p[i])
            continue;
        for(int j=i;j*i&lt;10000;j++)
        {
            p[i*j]=1;
        }
        prim[len++]=i;
    }
    
}
int main()
{
    isp();
    for(int i=0;i&lt;len;i++)
    {
        int ss=prim[i];  //记录当前素数
        for(int c=1;c&lt;1000;c++)     //c为公差
        {
            int j;
            for(j=1;j&lt;10;j++)
            {
                if(p[ss+c*j])
                    break;
            }
            if(j&gt;=10)
            {
                cout&lt;&lt;c&lt;&lt;&#39; &#39;&lt;&lt;ss&lt;&lt;endl;
                return 0;
            }
        }
    }
}
</code></pre>

<p><strong>答案为210.</strong></p>

<h2 id="toc_2">第三题 承压计算</h2>

<p>X星球的高科技实验室中整齐地堆放着某批珍贵金属原料。</p>

<p>每块金属原料的外形、尺寸完全一致，但重量不同。<br/>
金属材料被严格地堆放成金字塔形。</p>

<pre><code>                             7 
                            5 8 
                           7 8 8 
                          9 2 7 2 
                         8 1 4 9 1 
                        8 1 8 8 4 1 
                       7 9 6 1 4 5 4 
                      5 6 5 5 6 9 5 6 
                     5 5 4 7 9 3 5 5 1 
                    7 5 7 9 7 4 7 3 3 1 
                   4 6 4 5 5 8 8 3 2 4 3 
                  1 1 3 3 1 6 6 5 5 4 4 2 
                 9 9 9 2 1 9 1 9 2 9 5 7 9 
                4 3 3 7 7 9 3 6 1 3 8 8 3 7 
               3 6 8 1 5 3 9 5 8 3 8 1 8 3 3 
              8 3 2 3 3 5 5 8 5 4 2 8 6 7 6 9 
             8 1 8 1 8 4 6 2 2 1 7 9 4 2 3 3 4 
            2 8 4 2 2 9 9 2 8 3 4 9 6 3 9 4 6 9 
           7 9 7 4 9 7 6 6 2 8 9 4 1 8 1 7 2 1 6 
          9 2 8 6 4 2 7 9 5 4 1 2 5 1 7 3 9 8 3 3 
         5 2 1 6 7 9 3 2 8 9 5 5 6 6 6 2 1 8 7 9 9 
        6 7 1 8 8 7 5 3 6 5 4 7 3 4 6 7 8 1 3 2 7 4 
       2 2 6 3 5 3 4 9 2 4 5 7 6 6 3 2 7 2 4 8 5 5 4 
      7 4 4 5 8 3 3 8 1 8 6 3 2 1 6 2 6 4 6 3 8 2 9 6 
     1 2 4 1 3 3 5 3 4 9 6 3 8 6 5 9 1 5 3 2 6 8 8 5 3 
    2 2 7 9 3 3 2 8 6 9 8 4 4 9 5 8 2 6 3 4 8 4 9 3 8 8 
   7 7 7 9 7 5 2 7 9 2 5 1 9 2 6 5 3 9 3 5 7 3 5 4 2 8 9 
  7 7 6 6 8 7 5 5 8 2 4 7 7 4 7 2 6 9 2 1 8 2 9 8 5 7 3 6 
 5 9 4 5 5 7 5 5 6 3 5 3 9 5 8 9 5 4 1 2 6 1 4 3 5 3 2 4 1 
X X X X X X X X X X X X X X X X X X X X X X X X X X X X X X 
</code></pre>

<p>其中的数字代表金属块的重量（计量单位较大）。<br/>
最下一层的X代表30台极高精度的电子秤。</p>

<p>假设每块原料的重量都十分精确地平均落在下方的两个金属块上，<br/>
最后，所有的金属块的重量都严格精确地平分落在最底层的电子秤上。<br/>
电子秤的计量单位很小，所以显示的数字很大。</p>

<p>工作人员发现，其中读数最小的电子秤的示数为：2086458231</p>

<p>请你推算出：读数最大的电子秤的示数为多少？</p>

<p>注意：需要提交的是一个整数，不要填写任何多余的内容。</p>

<p><strong>只要把第i行的第j个平均分给第i+1行的第j个和第i+1行的第j+1个</strong></p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
using namespace std;
double num[35][35];
int main()
{
    for(int i=1;i&lt;=29;i++)
        for(int j=1;j&lt;=i;j++)
            cin&gt;&gt;num[i][j];
    for(int i=1;i&lt;=29;i++){
        for(int j=1;j&lt;=i;j++)
        {
            num[i+1][j]+=num[i][j]/2;
            num[i+1][j+1]+=num[i][j]/2;
        }
    }
    double maxn=-1;
    double minn=INT_MAX;
    for(int i=1;i&lt;=30;i++)
    {
        if(maxn&lt;num[30][i]) maxn=num[30][i];
        if(minn&gt;num[30][i]) minn=num[30][i];
    }
    printf(&quot;%lf&quot;,maxn*2086458231/minn);  //进行单位的的换算
}
</code></pre>

<h2 id="toc_3">第四题  方格分割</h2>

<p>6x6的方格，沿着格子的边线剪开成两部分。<br/>
要求这两部分的形状完全相同。</p>

<p>如图：p1.png, p2.png, p3.png 就是可行的分割法。</p>

<p>试计算：<br/>
包括这3种分法在内，一共有多少种不同的分割方法。<br/>
注意：旋转对称的属于同一种分割法。</p>

<p>请提交该整数，不要填写任何多余的内容或说明文字。<br/>
<img src="media/15196116405308/15196154889838.jpg" alt=""/><br/>
<strong>应该把边当成走廊，因为剪出的是中心对称，所以必定经过（3，3）<br/>
所以可以从（3，3）开始出发两个人以中心对称的方式出发，当走到边界的时候两个人走的路线就是剪开的线路<br/>
因为是中心对称，这样出来的答案应该除以4</strong></p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;iostream&gt;
using namespace std;
int visited[10][10];
int ans=0;
int dir[4][2]={0,1,1,0,0,-1,-1,0};
void dfs(int x,int y)
{
    if(x==0||y==0||x==6||y==6)
    {
        ans++;
        return ;
    }
    for(int i=0;i&lt;4;i++)
    {
        int nx=x+dir[i][0];
        int ny=y+dir[i][1];
        if(visited[nx][ny])
            continue;
        visited[nx][ny]=1;
        visited[6-nx][6-ny]=1;
        dfs(nx,ny);
        visited[nx][ny]=0;      //上次路线假设情况求取后 ，将路线标记置为0
        visited[6-nx][6-ny]=0;  //同上对称图形也将路线标记置为0
    }
}
int main()
{
    memset(visited,0,sizeof(visited));
    visited[3][3]=1;
    dfs(3,3);
    printf(&quot;%d %d\n&quot;,ans,ans/4);
}
</code></pre>

<h2 id="toc_4">第六题 最大公共子串</h2>

<p>最大公共子串长度问题就是：<br/>
求两个串的所有子串中能够匹配上的最大长度是多少。</p>

<p>比如：&quot;abcdkkk&quot; 和 &quot;baabcdadabc&quot;，<br/>
可以找到的最长的公共子串是&quot;abcd&quot;,所以最大公共子串长度为4。</p>

<p>下面的程序是采用矩阵法进行求解的，这对串的规模不大的情况还是比较有效的解法。</p>

<p>请分析该解法的思路，并补全划线部分缺失的代码。</p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

#define N 256
int f(const char* s1, const char* s2)
{
    int a[N][N];
    int len1 = strlen(s1);
    int len2 = strlen(s2);
    int i,j;

    memset(a,0,sizeof(int)*N*N);
    int max = 0;
    for(i=1; i&lt;=len1; i++){
        for(j=1; j&lt;=len2; j++){
            if(s1[i-1]==s2[j-1]) {
                a[i][j] = __________________________;  //填空
                if(a[i][j] &gt; max) max = a[i][j];
            }
        }
    }

    return max;
}

int main()
{
    printf(&quot;%d\n&quot;, f(&quot;abcdkkk&quot;, &quot;baabcdadabc&quot;));
    return 0;
}
</code></pre>

<p>基础dp，答案：a[i-1][j-1]+1</p>

<h2 id="toc_5">第七题 日期问题</h2>

<p>小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在1960年1月1日至2059年12月31日。令小明头疼的是，这些日期采用的格式非常不统一，有采用年/月/日的，有采用月/日/年的，还有采用日/月/年的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。  </p>

<p>比如02/03/04，可能是2002年03月04日、2004年02月03日或2004年03月02日。  </p>

<p>给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？</p>

<h2 id="toc_6">输入</h2>

<p>一个日期，格式是&quot;AA/BB/CC&quot;。  (0 &lt;= A, B, C &lt;= 9)  </p>

<h2 id="toc_7">输出</h2>

<p>输出若干个不相同的日期，每个日期一行，格式是&quot;yyyy-MM-dd&quot;。多个日期按从早到晚排列。  </p>

<h2 id="toc_8">样例输入</h2>

<p>02/03/04  </p>

<h2 id="toc_9">样例输出</h2>

<p>2002-03-04<br/><br/>
2004-02-03<br/><br/>
2004-03-02  </p>

<p>资源约定：<br/>
峰值内存消耗（含虚拟机） &lt; 256M<br/>
CPU消耗  &lt; 1000ms</p>

<p>注意：<br/>
main函数需要返回0;<br/>
只使用ANSI C/ANSI C++ 标准;<br/>
不要调用依赖于编译环境或操作系统的特殊函数。<br/>
所有依赖的函数必须明确地在源文件中 #include <xxx><br/>
不能通过工程设置而省略常用头文件。</p>

<p>提交程序时，注意选择所期望的语言类型和编译器类型。</p>

<p>只有年/月/日的，月/日/年的，日/月/年三种情况</p>

<pre><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;
int time[150][15][35];
bool pd(int n,int y,int r)
{
    int rn=0;
    if(n%400==0||(n%100!=0&amp;&amp;n%4==0))
        rn=1;
    if(n==1||n==3||n==5||n==7||n==8||n==10||n==12)
        if(r&gt;31) return 0;
    if(n==4||n==6||n==9||n==11)
        if(r&gt;30) return 0;
    if(n==2)
        if(r&gt;28+rn) return 0;
    return 1;
}

int main()
{
    int a,b,c;
    //memset(time,0,sizeof(time));
    scanf(&quot;%d/%d/%d&quot;,&amp;a,&amp;b,&amp;c);
    if(a&gt;=60&amp;&amp;b&lt;=12&amp;&amp;c&lt;=31)
        time[a-60][b][c]=1;
    if(a&lt;60&amp;&amp;b&lt;=12&amp;&amp;c&lt;=31)
        time[a+40][b][c]=1;
    
    if(c&gt;=60&amp;&amp;a&lt;=12&amp;&amp;b&lt;=31)
        time[c-60][a][b]=1;
    if(c&lt;60&amp;&amp;a&lt;=12&amp;&amp;c&lt;=31)
        time[c+40][a][b]=1;
    
    if(c&gt;=60&amp;&amp;b&lt;=12&amp;&amp;a&lt;=31)
        time[c-60][b][a]=1;
    if(c&lt;60&amp;&amp;b&lt;=12&amp;&amp;a&lt;=31)
        time[c+40][b][a]=1;
    for(int i=0;i&lt;=100;i++)
        for(int j=1;j&lt;=12;j++)
            for(int k=1;k&lt;=31;k++)
                if(time[i][j][k]==1)
                {
                    if(pd(i,j,k))
                    {
                        
                        printf(&quot;%d-&quot;,i+1960);
                        if(j&lt;9)
                            printf(&quot;0%d-&quot;,j);
                        else
                            printf(&quot;%d-&quot;,j);
                        if(k&lt;9)
                            printf(&quot;0%d\n&quot;,k);
                        else
                            printf(&quot;%d\n&quot;,k);
                    }
                }
}

</code></pre>

<h2 id="toc_10">第八题 包子凑数</h2>

<p>小明几乎每天早晨都会在一家包子铺吃早餐。他发现这家包子铺有N种蒸笼，其中第i种蒸笼恰好能放Ai个包子。每种蒸笼都有非常多笼，可以认为是无限笼。</p>

<p>每当有顾客想买X个包子，卖包子的大叔就会迅速选出若干笼包子来，使得这若干笼中恰好一共有X个包子。比如一共有3种蒸笼，分别能放3、4和5个包子。当顾客想买11个包子时，大叔就会选2笼3个的再加1笼5个的（也可能选出1笼3个的再加2笼4个的）。</p>

<p>当然有时包子大叔无论如何也凑不出顾客想买的数量。比如一共有3种蒸笼，分别能放4、5和6个包子。而顾客想买7个包子时，大叔就凑不出来了。</p>

<p>小明想知道一共有多少种数目是包子大叔凑不出来的。</p>

<p><strong>这题可以使用欧几里得拓展算法：<br/>
对于不完全为 0 的非负整数 a，b，gcd（a，b）表示 a，b 的最大公约数，必然<br/>
存在整数对 x，y ，使得 gcd（a，b）=ax+by。</strong></p>

<p>简单的说就是当所有的输入的最大公约数都为1时，为有限个，否则为无限个。</p>

<pre><code class="language-c++">#include &lt;cstdio&gt;
#include &lt;cstring&gt;
using namespace std;

bool judge(int x,int y)
{
    int t;
    while(y&gt;0)
    {
        t=x%y;
        x=y;
        y=t;
    }
    if(x==1)
        return true;
    return false;
}

int a[110],n;
bool dp[10010];
int main()
{
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=0; i&lt;n; i++)
        scanf(&quot;%d&quot;,&amp;a[i]);
    int  flag=0;
    for(int i=0;i&lt;n;i++)
    {
        for(int j=1;j&lt;=n;j++)
        {
            if(judge(a[i],a[j]))
            {
                flag=1;
                break;
            }
        }
        if(flag==1)
            break;
    }
    if(flag!=1)
    {
        printf(&quot;INF\n&quot;);
        return 0;
    }
    dp[0]=1;
    for(int i=0; i&lt;n; i++)
    {
        for(int j=0; j+a[i]&lt;10000; j++)
            if(dp[j])
                dp[j+a[i]]=1;
    }
    int ans=0;
    for(int i=0; i&lt;10000; i++)
    {
        if(dp[i]!=1)
            ans++;
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}

</code></pre>

<h2 id="toc_11">第九题 分巧克力</h2>

<p>儿童节那天有K位小朋友到小明家做客。小明拿出了珍藏的巧克力招待小朋友们。<br/>
小明一共有N块巧克力，其中第i块是Hi x Wi的方格组成的长方形。为了公平起见，小明需要从这 N 块巧克力中切出K块巧克力分给小朋友们。切出的巧克力需要满足：<br/>
    1. 形状是正方形，边长是整数<br/><br/>
    2. 大小相同  </p>

<p>例如一块6x5的巧克力可以切出6块2x2的巧克力或者2块3x3的巧克力。</p>

<p>当然小朋友们都希望得到的巧克力尽可能大，你能帮小Hi计算出最大的边长是多少么？</p>

<p>输入<br/>
第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)<br/><br/>
以下N行每行包含两个整数Hi和Wi。(1 &lt;= Hi, Wi &lt;= 100000) <br/>
输入保证每位小朋友至少能获得一块1x1的巧克力。   </p>

<p>输出<br/>
输出切出的正方形巧克力最大可能的边长。</p>

<p>样例输入：<br/>
2 10<br/><br/>
6 5<br/><br/>
5 6  </p>

<p>样例输出：<br/>
2</p>

<p>资源约定：<br/>
峰值内存消耗（含虚拟机） &lt; 256M<br/>
CPU消耗  &lt; 1000ms</p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
#define N 100005
using namespace std;
int n,k;
struct cho
{
    int h;
    int w;
};
cho c[N];
bool judge(int len)
{
    int sum=0;
    for(int i=0;i&lt;len;i++)
    {
        sum+=(c[i].h/len)*(c[i].w/len);
        if(sum&gt;=k)
            return 1;
    }
    return 0;
}
int main()
{
    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
    int low=1;
    int high=100000;
    int mid;
    for(int i=0; i&lt;n; i++)
        scanf(&quot;%d%d&quot;,&amp;c[i].h,&amp;c[i].w);
    while(low&lt;high-1)
    {
        mid=(low+high)/2;
        if(!judge(mid))
            high=mid;
        else
            low=mid;
    }
    printf(&quot;%d\n&quot;,mid-1);
    return 0;
}

</code></pre>

<h2 id="toc_12">第十题 k倍区间</h2>

<p>给定一个长度为N的数列，A1, A2, ... AN，如果其中一段连续的子序列Ai, Ai+1, ... Aj(i &lt;= j)之和是K的倍数，我们就称这个区间[i, j]是K倍区间。  </p>

<p>你能求出数列中总共有多少个K倍区间吗？  </p>

<h2 id="toc_13">输入</h2>

<p>第一行包含两个整数N和K。(1 &lt;= N, K &lt;= 100000)<br/><br/>
以下N行每行包含一个整数Ai。(1 &lt;= Ai &lt;= 100000)  </p>

<h2 id="toc_14">输出</h2>

<p>输出一个整数，代表K倍区间的数目。  </p>

<p>例如，<br/>
输入：<br/>
5 2<br/>
1<br/><br/>
2<br/><br/>
3<br/><br/>
4<br/><br/>
5  </p>

<p>程序应该输出：<br/>
6</p>

<p>资源约定：<br/>
峰值内存消耗（含虚拟机） &lt; 256M<br/>
CPU消耗  &lt; 2000ms</p>

<p><strong>可通过滑动窗口的方法来解，提前对数据进行处理可缩短执行时间</strong></p>

<pre><code class="language-c++">#include &lt;stdio.h&gt;
using namespace std;
int a[100010];
long long dp[100010];
int main()
{
    int n,k,i,j;
    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);
    dp[0]=0;
    for(i=1;i&lt;=n;i++)
    {
        scanf(&quot;%d&quot;,&amp;a[i]);
        dp[i]=dp[i-1]+a[i];     //累加之前的数字
    }
    int ans=0;
    for(i=1;i&lt;=n;i++)
    {
        for(j=0;j&lt;=n-i;j++)
        {
            if((dp[j+i]-dp[j])%k==0)    //通过调整i，j来循环判断，这里i表示区间的长度，j为向右滑动步数。
                ans++;
        }
    }
    printf(&quot;%d\n&quot;,ans);
    return 0;
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Word in Dictionary through Deleting]]></title>
    <link href="https://lockxmonk.github.io/15166061069994.html"/>
    <updated>2018-01-22T15:28:26+08:00</updated>
    <id>https://lockxmonk.github.io/15166061069994.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15166061069994/15166062200635.jpg" alt=""/></p>

<p><strong>比较字符的大小时，若字符串a的首字符大于b的首字符则a比较大，不对后续字符进行判断。</strong></p>

<pre><code class="language-c++">class Solution {
public:
    string findLongestWord(string s, vector&lt;string&gt;&amp; d) {
            string ans;
            for (int i = 0; i &lt; d.size(); i++) {
                int pi = 0, pj = 0;
                for (; pi &lt; s.size() &amp;&amp; pj &lt; d[i].size(); pi++) {
                    pj += s[pi] == d[i][pj];
                }
                if (pj == d[i].size() &amp;&amp; (ans.size() &lt; d[i].size() || (ans.size() == d[i].size() &amp;&amp; ans &gt; d[i])))
                    ans = d[i];
            }
            return ans;
        }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Word in Dictionary]]></title>
    <link href="https://lockxmonk.github.io/15165851014842.html"/>
    <updated>2018-01-22T09:38:21+08:00</updated>
    <id>https://lockxmonk.github.io/15165851014842.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15165851014842/15165851083732.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string longestWord(vector&lt;string&gt;&amp; words) {
        sort(words.begin(), words.end());  //对字符串排好序，按照字符的ascll编码，匹配字典的排序
        unordered_set&lt;string&gt; set;
        string res = &quot;&quot;;
        for (int i = 0 ; i&lt;words.size(); i++) {
            if (words[i].size()==1||set.count(words[i].substr(0,words[i].size()-1))) {
                res = words[i].size()&gt;res.size() ? words[i]:res;
                set.insert(words[i]);
            }
        }

        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maximum Length of Repeated Subarray]]></title>
    <link href="https://lockxmonk.github.io/15164332920131.html"/>
    <updated>2018-01-20T15:28:12+08:00</updated>
    <id>https://lockxmonk.github.io/15164332920131.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15164332920131/15164336142430.jpg" alt=""/></p>

<p>运用了动态规划，从A的尾部，来遍历B。</p>

<pre><code class="language-c++">class Solution {
public:
    int findLength(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {
        int m = A.size(), n = B.size();
        if (!m||!n) {
            return 0;
        }
        vector&lt;int&gt; dp(n+1); //要比B的长度多一位，在下面j=为n-1时需要获取dp[j+1]的值
        int res = 0;
        for (int i = m-1; i&gt;=0; i--) {
            for (int j = 0; j&lt;n; j++) {
                dp[j] = A[i]==B[j] ? dp[j+1]+1 : 0;
                res = max(res, dp[j]);
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Largest Number At Least Twice of Others]]></title>
    <link href="https://lockxmonk.github.io/15164320874129.html"/>
    <updated>2018-01-20T15:08:07+08:00</updated>
    <id>https://lockxmonk.github.io/15164320874129.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15164320874129/15164320973707.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int dominantIndex(vector&lt;int&gt;&amp; nums) {
        int max = 0, tmp = 0,index = 0;
        for (int i = 0; i&lt;nums.size(); i++) {
            if(nums[i]&gt;=max) {
                tmp = max;
                max = nums[i];
                index = i;
            }else if (nums[i]&gt;tmp){
                tmp = nums[i];
            }
            if (i==nums.size()-1 &amp;&amp; tmp*2&lt;=max) return index;
        }
        return -1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reverse Linked List]]></title>
    <link href="https://lockxmonk.github.io/15163372118775.html"/>
    <updated>2018-01-19T12:46:51+08:00</updated>
    <id>https://lockxmonk.github.io/15163372118775.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15163372118775/15163372241677.jpg" alt=""/></p>

<p>迭代法:</p>

<pre><code class="language-c++">class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = NULL;
        while (head) {
            ListNode* next = head -&gt; next;
            head -&gt; next = pre;
            pre = head;
            head = next;
        } 
        return pre;
    }
};
</code></pre>

<p>递归法：</p>

<pre><code class="language-objc">class Solution {
public:   
    ListNode* reverseList(ListNode* head) {
        if (!head || !(head -&gt; next)) return head;
        ListNode* node = reverseList(head -&gt; next);
        head -&gt; next -&gt; next = head;
        head -&gt; next = NULL;
        return node; 
    }
}; 
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Missing Positive]]></title>
    <link href="https://lockxmonk.github.io/15162636130743.html"/>
    <updated>2018-01-18T16:20:13+08:00</updated>
    <id>https://lockxmonk.github.io/15162636130743.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162636130743/15162636149442.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; map;
        int min = INT_MAX, max = 0, res = 1;
        for (int i = 0; i&lt;nums.size(); i++) {
            if (nums[i]&lt;=min&amp;&amp;nums[i]&gt;=0) {
                min = nums[i];
            }else if (nums[i]&lt;0) min = 0;
            if (nums[i]&gt;=max) max = nums[i];
            map[nums[i]]++;
        }
        for (int j=min; j&lt;=max; j++) {
            if (j==0) continue;
            if (min&gt;=2) {
                return 1;
            }
            if (map[j]==0) {
                res = j;
                break;
            }
            if (j==max) {
                res = max+1;
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find the Duplicate Number]]></title>
    <link href="https://lockxmonk.github.io/15162583169716.html"/>
    <updated>2018-01-18T14:51:56+08:00</updated>
    <id>https://lockxmonk.github.io/15162583169716.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162583169716/15162583183298.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findDuplicate(vector&lt;int&gt;&amp; nums) {
        unordered_map&lt;int, int&gt; map;
        int res = 0;
        for (int i = 0; i&lt;nums.size(); i++) {
            if (map[nums[i]]==0) {
                map[nums[i]]++;
            }else{
                res = nums[i];
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Set Mismatch]]></title>
    <link href="https://lockxmonk.github.io/15162440984880.html"/>
    <updated>2018-01-18T10:54:58+08:00</updated>
    <id>https://lockxmonk.github.io/15162440984880.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162440984880/15162441100081.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; findErrorNums(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        vector&lt;int&gt; res;
        vector&lt;int&gt; a(len+1);   //因为数组从0开始，所以除去0，在后面加上1位

        for (int i = 0; i&lt;len; i++) {
            if (a[nums[i]]==0) {
                a[nums[i]]+=1;
            }else{
                res.push_back(nums[i]);
            }
        }

        for (int j = 1; j&lt;=len; j++) {
            if (a[j]==0) {
                res.push_back(j);
            }
        }

        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find Anagram Mappings]]></title>
    <link href="https://lockxmonk.github.io/15162401864030.html"/>
    <updated>2018-01-18T09:49:46+08:00</updated>
    <id>https://lockxmonk.github.io/15162401864030.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15162401864030/15162401885331.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; anagramMappings(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {
        unordered_map&lt;int, int&gt; map;
        vector&lt;int&gt; res;
        for (int i = 0; i&lt;B.size(); i++) {
            map[B[i]]=i;
        }
        for (int j = 0; j&lt;A.size(); j++) {
            res.push_back(map[A[j]]);
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Length of Last Word]]></title>
    <link href="https://lockxmonk.github.io/15162389890253.html"/>
    <updated>2018-01-18T09:29:49+08:00</updated>
    <id>https://lockxmonk.github.io/15162389890253.html</id>
    <content type="html"><![CDATA[
<pre><code>![](media/15162389890253/15162389958774.jpg)
</code></pre>

<pre><code class="language-c++">class Solution {
public:
    int lengthOfLastWord(string s) {
        int len = s.size();
        int cout = 0;
        for (int i=len-1; i&gt;=0; i--) {
            if(cout&gt;0&amp;&amp;s[i]==&#39; &#39;) break;

            if (s[i]==&#39; &#39;) {
                continue;
            }else{
                cout++;
            }

        }
        return cout;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find matching parenthesis]]></title>
    <link href="https://lockxmonk.github.io/15155525710565.html"/>
    <updated>2018-01-10T10:49:31+08:00</updated>
    <id>https://lockxmonk.github.io/15155525710565.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15155525710565/15155525754064.jpg" alt=""/><br/>
<img src="media/15155525710565/15155525919147.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

int findParenMatch(NSString *s, int n) {
    int res = -1;
    NSString *tmp = [s substringWithRange:NSMakeRange(n, 1)];
    if ([tmp isEqualToString:@&quot;(&quot;]) {
        int logF = 0;
        for (int i = n+1; i&lt;s.length; i++) {
            NSString *tmpStrF = [s substringWithRange:NSMakeRange(i, 1)];
            if ([tmpStrF isEqualToString:@&quot;(&quot;]) logF++;
            if ([tmpStrF isEqualToString:@&quot;)&quot;]) {
                logF--;
                if (logF&lt;0) {
                    res = i;
                    break;
                }
            }
        }
    }else if ([tmp isEqualToString:@&quot;)&quot;]){
        int logB = 0;
        for (int i = n-1; i&gt;=0; i--) {
            NSString *tmpStrB = [s substringWithRange:NSMakeRange(i, 1)];
            if ([tmpStrB isEqualToString:@&quot;)&quot;]) logB++;
            if ([tmpStrB isEqualToString:@&quot;(&quot;]) {
                logB--;
                if (logB&lt;0) {
                    res = i;
                    break;
                }
            }
        }
    }
    return res;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[KVO自己的理解]]></title>
    <link href="https://lockxmonk.github.io/15153763176511.html"/>
    <updated>2018-01-08T09:51:57+08:00</updated>
    <id>https://lockxmonk.github.io/15153763176511.html</id>
    <content type="html"><![CDATA[
<ol>
<li>KVO利用runtime，生成了一个对象的子类，并生成子类对象替换原来对象的isa指针，重写了set方法。</li>
<li>KVO是基于KVC的，可以明显的发现在改变容器的时候，通过KVC改变改变容器中的值或者使用set方法时，会触发KVO通知函数，而简单的使用addObject：方法时却没有触发，这是因为KVO只响应set方法。<font color=red>可以说kvc是kvo的入口</font></li>
<li>直接使用KVO在项目中不是很好用，代码结构比较松散，需要自己封装或使用其它三方框架。</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Where my anagrams at?]]></title>
    <link href="https://lockxmonk.github.io/15152183997863.html"/>
    <updated>2018-01-06T13:59:59+08:00</updated>
    <id>https://lockxmonk.github.io/15152183997863.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15152183997863/15152184280248.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *anagrams(NSString *s, NSArray *a) {
    NSMapTable *map = [NSMapTable mapTableWithKeyOptions:NSMapTableStrongMemory valueOptions:NSMapTableStrongMemory];
    for (int i = 0; i&lt;[s length]; i++) {
        NSString *str = [s substringWithRange:NSMakeRange(i, 1)];
        if ([map objectForKey:str]) {
            [map setObject:@([[map objectForKey:str] intValue]+1) forKey:str];
        }else{
            [map setObject:@(1) forKey:str];
        }
    }
    NSMutableArray *res = a.mutableCopy;
    for (NSString *ele in a) {
        if(ele.length!=s.length){
            [res removeObject:ele];
            continue;
        }
        NSMapTable *tmp = [map copy];
        for (int j=0; j&lt;[ele length]; j++) {
            NSString *tmpStr = [ele substringWithRange:NSMakeRange(j, 1)];
            if ([tmp objectForKey:tmpStr]) {
                int log =[[tmp objectForKey:tmpStr] intValue]-1;
                if (log&lt;0){
                    [res removeObject:ele];
                    break;
                }
                [tmp setObject:@(log) forKey:tmpStr];
            }else{
                [res removeObject:ele];
                break;
            }
        }
    }
    return res;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Perimeter of squares in a rectangle]]></title>
    <link href="https://lockxmonk.github.io/15152039082618.html"/>
    <updated>2018-01-06T09:58:28+08:00</updated>
    <id>https://lockxmonk.github.io/15152039082618.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15152039082618/15152039109281.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

unsigned long long perimeter(int n) {
    NSMutableArray *numQu = @[@0,@1].mutableCopy;
    unsigned long long n0 = 0,n1=1;
    for (int i = 2; i&lt;=n+1; i++) {
        unsigned long long sum = n0+n1;
        n0 = n1;
        n1 = sum;
        [numQu addObject:@(sum)];
    }
    unsigned long long tol = 0;
    for (NSNumber* ele in numQu) {
        tol+=[ele unsignedLongLongValue];
    }
    return tol*4;
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking遇到的问题]]></title>
    <link href="https://lockxmonk.github.io/15151211562254.html"/>
    <updated>2018-01-05T10:59:16+08:00</updated>
    <id>https://lockxmonk.github.io/15151211562254.html</id>
    <content type="html"><![CDATA[
<p>由于<code>AFNetworking</code>运用了官方<code>NSURLSession</code>所以其中有一些坑</p>

<h2 id="toc_0">1.苹果运用NSJSONSerialization解析，出现数字类型精度问题</h2>

<p>当服务器给我传回来一个<code>3.0</code>的数字类型时，在安卓端是没有问题的，但是在iOS这里会出现<code>2.99999</code>这样的问题。</p>

<p><font color=red><strong>出现这个问题的原因是：苹果在json解析时，默认为双精度的double类型。</strong></font></p>

<pre><code>我们相处的解决方案有两种：
1. 跟后台协商将数字型的值改为`字符型`
2. 使用第三方的json解析。
</code></pre>

<p>最后我们使用的是第一种方法，因为第二种势必要修改了AFNetwork的源码，开发与维护成本相比较来说要大。</p>

<h2 id="toc_1">2.json解析失败</h2>

<p>由于AF默认的解析方式为<code>0</code>（返回的对象是不可变的，<code>NSDictionary</code>或<code>NSArray</code>）：<br/>
<img src="media/15151211562254/15151222443779.jpg" alt=""/></p>

<p>我们来看一下都有什么选项：<br/>
<img src="media/15151211562254/15151222806031.jpg" alt=""/></p>

<p>所以当我们服务器返回的json数据是<strong>碎片化</strong>的（最外层既不是<code>NSArray</code>也不是<code>NSDictionary</code>），那么解析的时候就会出错了。</p>

<p>解决方法是：</p>

<p><img src="media/15151211562254/15151327758647.jpg" alt=""/><br/>
在0后添加<code>|</code>字符，增加这种情况，允许碎片化数据。</p>

<h2 id="toc_2">3. 请求后response的状态码范围问题</h2>

<p>正常项目中正常请求成功会返回200，但是服务器若是给你返回了500（我不知道后台为啥会返回这个码），问题就出现了：</p>

<p>这是由于下面的原因：<br/>
<img src="media/15151211562254/15151343155944.jpg" alt=""/><br/>
会发现上图中可接受状态码的范围是200-300；</p>

<p>具体解决方法就不说了。。。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1's, 0's and wildcards]]></title>
    <link href="https://lockxmonk.github.io/15145180239158.html"/>
    <updated>2017-12-29T11:27:03+08:00</updated>
    <id>https://lockxmonk.github.io/15145180239158.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15145180239158/15145180364703.jpg" alt=""/></p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *changeTo(NSMutableArray*log, NSMutableArray*res){
    if (log.count&gt;0) {
        NSRange loc = {[[log lastObject] integerValue],1};
        NSMutableArray *cop = res.mutableCopy;
        for (NSString *tmp in res) {
            [cop addObject:[tmp stringByReplacingCharactersInRange:loc withString:@&quot;0&quot;]];
            [cop addObject:[tmp stringByReplacingCharactersInRange:loc withString:@&quot;1&quot;]];
            [cop removeObject:tmp];
        }
        [log removeLastObject];
        return changeTo(log, cop);
    }else{
        return res;
    }
}

NSArray *possibilities(NSString *s) {
    NSMutableArray *log = @[].mutableCopy;
    NSMutableArray *res = @[].mutableCopy;
    for (int i = 0; i&lt;s.length; i++) {
        if ([s characterAtIndex:i]==&#39;?&#39;) {
            [log addObject:@(i)];
        }
    }
    [res addObject:s];

    NSArray *tol = changeTo(log , res);
    
    return tol;
}
</code></pre>

<p>简化版：</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSArray *possibilities(NSString *s) {
  // NSLog(@&quot;User `possibilities` accidentally invoked!\n&quot;);
  if ([s rangeOfString: @&quot;?&quot;].length == 0) return @[s];
  NSString *r = [s stringByReplacingOccurrencesOfString: @&quot;?&quot; withString: @&quot;0&quot; options: 0 range: [s rangeOfString: @&quot;?&quot;]], *t = [s stringByReplacingOccurrencesOfString: @&quot;?&quot; withString: @&quot;1&quot; options: 0 range: [s rangeOfString: @&quot;?&quot;]];
  return [possibilities(r) arrayByAddingObjectsFromArray: possibilities(t)];
}
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Simple Pig Latin]]></title>
    <link href="https://lockxmonk.github.io/15143494387976.html"/>
    <updated>2017-12-27T12:37:18+08:00</updated>
    <id>https://lockxmonk.github.io/15143494387976.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15143494387976/15143494406501.jpg" alt=""/></p>

<p>一开始的复杂版:</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSString *pigIt(NSString *s) {
    NSMutableArray *str = [s componentsSeparatedByString:@&quot; &quot;].mutableCopy;
    NSMutableString *res = @&quot;&quot;.mutableCopy;
    for (NSString *tmp in str) {
        unichar c = [tmp characterAtIndex:0];
        if ((c&gt;=&#39;a&#39;&amp;&amp;c&lt;=&#39;z&#39;)||(c&gt;=&#39;A&#39;&amp;&amp;c&lt;=&#39;Z&#39;)) {
            NSMutableString *change = tmp.mutableCopy;
            [change appendFormat:@&quot;%c&quot;,c];
            if ([tmp isEqualToString:[str lastObject]]) {
                [change appendString:@&quot;ay&quot;];
            }else{
                [change appendString:@&quot;ay &quot;];
            }
            [res appendString:[change substringFromIndex:1]];
        }else{
            [res appendFormat:@&quot;%c&quot;,c];
        }
    }
    return res;
}
</code></pre>

<p>简化版</p>

<pre><code class="language-objc">#import &lt;Foundation/Foundation.h&gt;

NSString *pigIt(NSString *s) {
  NSMutableArray *result = [s componentsSeparatedByString: @&quot; &quot;];
  for (size_t i = 0; i &lt; [result count]; i++) result[i] = [[[result[i] substringFromIndex: 1] stringByAppendingString: [result[i] substringToIndex: 1]] stringByAppendingString: @&quot;ay&quot;];
  return [result componentsJoinedByString: @&quot; &quot;];
}
</code></pre>

]]></content>
  </entry>
  
</feed>
