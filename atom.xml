<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2017-11-23T16:31:17+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[☆☆Find All Numbers Disappeared in an Array]]></title>
    <link href="https://lockxmonk.github.io/15119708919827.html"/>
    <updated>2017-11-29T23:54:51+08:00</updated>
    <id>https://lockxmonk.github.io/15119708919827.html</id>
    <content type="html"><![CDATA[
<p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>

<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>

<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>

<p><img src="media/15119708919827/15119710141999.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        for(int i=0; i&lt;len; i++) {
            int m = abs(nums[i])-1;  // index start from 0
            nums[m] = nums[m]&gt;0 ? -nums[m] : nums[m];
        }
        vector&lt;int&gt; res;
        for(int i = 0; i&lt;len; i++) {
            if(nums[i] &gt; 0) res.push_back(i+1);
        }
        return res;
    }
};
</code></pre>

<p>该题用了一个特殊的方法，<strong>取负法</strong>。</p>

<p><strong>含义是：将元素对应的位置取负。简单一句话可能不好理解，我们举个例子。假设在位置k放了元素i，则在取负的过程中i的取值有两种可能：为正，表示当前尚未遇到元素k将该位置取负；为负，表示当前已经有元素k出现，并将元素取负。但是我们不关心k，我们关心元素i。元素i既然出现，我们就看一下位置i：为正，表示这是元素i第一次出现，我们将位置i取负；为负，表示元素i已经出现过一次，我们不做任何操作。不管一个元素出现一次还是两次，只要出现它对应的位置就会被取负。当某个元素不出现的时候，该元素对应的位置始终访问不到，所以还是正值，通过这种方法我们就可以找到哪些元素没有出现。</strong> </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Max Area of Island]]></title>
    <link href="https://lockxmonk.github.io/15119656914314.html"/>
    <updated>2017-11-29T22:28:11+08:00</updated>
    <id>https://lockxmonk.github.io/15119656914314.html</id>
    <content type="html"><![CDATA[
<p>Given a non-empty 2D array <code>grid</code> of 0&#39;s and 1&#39;s, an island is a group of 1&#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>

<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)<br/>
<img src="media/15119656914314/15119657218724.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int areaNum(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int m ,int n){
        if (m&lt;grid.size()&amp;&amp;m&gt;=0&amp;&amp;n&lt;grid[0].size()&amp;&amp;n&gt;=0&amp;&amp;grid[m][n]==1) {
            //将经过的位置标记为0，避免循环检验
            grid[m][n] = 0;
            return 1+ areaNum(grid, m+1, n)+areaNum(grid, m, n+1)+areaNum(grid, m-1, n)+areaNum(grid, m, n-1);
        }
        return 0;
    }
    
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int result = 0;
        for (int i =0; i&lt;grid.size(); i++) {
            for (int j=0; j&lt;grid[0].size(); j++) {
                if (grid[i][j]==1) {
                    result = max(result, areaNum(grid, i, j));
                }
            }
        }
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Max Consecutive Ones]]></title>
    <link href="https://lockxmonk.github.io/15119430001845.html"/>
    <updated>2017-11-29T16:10:00+08:00</updated>
    <id>https://lockxmonk.github.io/15119430001845.html</id>
    <content type="html"><![CDATA[
<p>Given a binary array, find the maximum number of consecutive 1s in this array.<br/>
<img src="media/15119430001845/15119430248541.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) {
        int sum1 = 0;
        int tmp = 0;
        for (int i=0; i&lt;nums.size(); i++) {
        if (nums[i]==1) {
            tmp++;
        }else{
            tmp = 0;
        }
            sum1 = max(tmp, sum1);
        }
    
        return sum1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Range Sum Query 2D - Immutable]]></title>
    <link href="https://lockxmonk.github.io/15119407096444.html"/>
    <updated>2017-11-29T15:31:49+08:00</updated>
    <id>https://lockxmonk.github.io/15119407096444.html</id>
    <content type="html"><![CDATA[
<p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).<br/>
<img src="media/15119407096444/15119407391245.jpg" alt=""/></p>

<pre><code class="language-c++">class NumMatrix {
private:
    int col,row;
    vector&lt;vector&lt;int&gt;&gt; sums;
public:
    NumMatrix(vector&lt;vector&lt;int&gt;&gt; matrix) {
        row = matrix.size();
        col =row&gt;0 ? matrix[0].size():0;
        sums = vector&lt;vector&lt;int&gt;&gt;(row+1, vector&lt;int&gt;(col+1,0));
        for(int i=1;i&lt;=row;i++)
        {
            for(int j=1;j&lt;=col;j++)
            {
                sums[i][j] = sums[i-1][j]+sums[i][j-1]+matrix[i-1][j-1]-sums[i-1][j-1];
            }
        }
    }
    
    int sumRegion(int row1, int col1, int row2, int col2) {
        return sums[row2+1][col2+1]-sums[row2+1][col1]-sums[row1][col2+1]+sums[row1][col1];
    }
};

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
 */
</code></pre>

<p><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/description/">题目详细链接</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reshape the Matrix]]></title>
    <link href="https://lockxmonk.github.io/15119406678576.html"/>
    <updated>2017-11-29T15:31:07+08:00</updated>
    <id>https://lockxmonk.github.io/15119406678576.html</id>
    <content type="html"><![CDATA[
<p>In MATLAB, there is a very useful function called &#39;reshape&#39;, which can reshape a matrix into a new one with different size but keep its original data.</p>

<p>You&#39;re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.</p>

<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.</p>

<p>If the &#39;reshape&#39; operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>

<p><img src="media/15119406678576/15119406900999.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) {
        int sumNum = nums.size() * nums[0].size();
        int r1 = nums.size();
        int c1 = nums[0].size();
        if (sumNum != r*c) {
            return nums;
        }
        vector&lt;vector&lt;int&gt;&gt; result = vector&lt;vector&lt;int&gt;&gt;(r,vector&lt;int&gt;(c,0));
        int j = 0;
        for (int i =0; i&lt;r*c; i++) {
            result[i/c][i%c] = nums[i/c1][i%c1];
        }
        
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Degree of an Array]]></title>
    <link href="https://lockxmonk.github.io/15114255869932.html"/>
    <updated>2017-11-23T16:26:26+08:00</updated>
    <id>https://lockxmonk.github.io/15114255869932.html</id>
    <content type="html"><![CDATA[
<p>Given a non-empty array of non-negative integers <code>nums</code>, the degree of this array is defined as the maximum frequency of any one of its elements.</p>

<p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p>

<p><img src="media/15114255869932/15114256313220.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {
        
        if (nums.size()&lt;2) {
            return nums.size();
        }
        unordered_map&lt;int, int&gt;startIndex , number;
        int len = nums.size();
        int fre = 0;
        for (int i=0; i&lt;nums.size(); i++) {
            if (startIndex.count(nums[i])==0) {
                startIndex[nums[i]]=i;
            }
            number[nums[i]]++;
            if (number[nums[i]]==fre) {
                len = min(i-startIndex[nums[i]]+1, len);
            }
            if (number[nums[i]]&gt;fre) {
                len = i - startIndex[nums[i]] + 1;
                fre = number[nums[i]];
            }
        }
        
        return len;
    }
};
</code></pre>

<p>该算法主要使用了两个<code>hash_map</code>:<br/>
一个来记录数字所出现的次数，另一个记录数字最开始出现的位置。一旦有一个数字的频数超过了当前的<code>len</code>，则更新<code>len</code>，若两个数字出现的频率相等则取长度最小的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find Pivot Index]]></title>
    <link href="https://lockxmonk.github.io/15114222067093.html"/>
    <updated>2017-11-23T15:30:06+08:00</updated>
    <id>https://lockxmonk.github.io/15114222067093.html</id>
    <content type="html"><![CDATA[
<p>Given an array of integers <code>nums</code>, write a method that returns the &quot;pivot&quot; index of this array.</p>

<p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p>

<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>

<p><img src="media/15114222067093/15114222397308.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int pivotIndex(vector&lt;int&gt;&amp; nums) {
        
        if(nums.empty()) return -1;
        
        int sum = 0;
        for(int i=0;i&lt;nums.size();i++) sum+=nums[i];
    
        int leftSum = 0;
        for(int j=0;j&lt;nums.size();j++)
        {
            if (leftSum == sum - nums[j] -leftSum) {
                return j;
        }
            leftSum += nums[j];
        }
        
        return -1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Time to Buy and Sell Stock II]]></title>
    <link href="https://lockxmonk.github.io/15114072257756.html"/>
    <updated>2017-11-23T11:20:25+08:00</updated>
    <id>https://lockxmonk.github.io/15114072257756.html</id>
    <content type="html"><![CDATA[
<p>Say you have an array for which the \(i^{th}\) element is the price of a given stock on day i.</p>

<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>

<pre><code class="language-c++">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int result = 0;
        for(int i = 1;i&lt;prices.size();i++)
        {
            result += max(prices[i]-prices[i-1] , 0);
        }
        return result;
    }
};

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Time to Buy and Sell Stock]]></title>
    <link href="https://lockxmonk.github.io/15114062990936.html"/>
    <updated>2017-11-23T11:04:59+08:00</updated>
    <id>https://lockxmonk.github.io/15114062990936.html</id>
    <content type="html"><![CDATA[
<p>Say you have an array for which the \(i^{th}\) element is the price of a given stock on day i.</p>

<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>

<p><img src="media/15114062990936/15114063447573.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int minPrice=INT_MAX;
        int maxProfit = 0;
        
        for (int i=0; i&lt;prices.size(); i++) {
            minPrice = min(prices[i], minPrice);
            maxProfit = max(maxProfit, prices[i]-minPrice);
        }
        
        return maxProfit;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Array Partition I]]></title>
    <link href="https://lockxmonk.github.io/15114035796843.html"/>
    <updated>2017-11-23T10:19:39+08:00</updated>
    <id>https://lockxmonk.github.io/15114035796843.html</id>
    <content type="html"><![CDATA[
<p>Given an array of <strong>2n</strong> integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>

<p><img src="media/15114035796843/15114036022226.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int arrayPairSum(vector&lt;int&gt;&amp; nums) {
        
        sort(nums.begin(),nums.end());
        int result=0;
        for (int i=0; i&lt;nums.size(); i+=2) {
            result+=nums[i];
        }
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3Sum]]></title>
    <link href="https://lockxmonk.github.io/15114026353930.html"/>
    <updated>2017-11-23T10:03:55+08:00</updated>
    <id>https://lockxmonk.github.io/15114026353930.html</id>
    <content type="html"><![CDATA[
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>

<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>

<p><img src="media/15114026353930/15114026868536.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(),nums.end());
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; tmpResult;
        
        int p,q,tmp;
        for(int i = 0 ;i&lt;nums.size();i++)
        {
            if(i!=0&amp;&amp;nums[i]==nums[i-1]) continue;
            int currentNum = nums[i];
            p = i+1;
            q = nums.size()-1;
            
            while(p&lt;q)
            {
                if(p!=i+1&amp;&amp;nums[p]==nums[p-1])
                {
                    p++;
                    continue;
                }
                tmp = nums[q]+nums[p];
                if(tmp==-currentNum)
                {
                    tmpResult.push_back(currentNum);
                    tmpResult.push_back(nums[q]);
                    tmpResult.push_back(nums[p]);
                    result.push_back(tmpResult);
                    tmpResult.clear();
                    p++;
                    q--;
                }else if (tmp&gt;-currentNum)
                {
                    q--;
                }else p++;
            }
        }
        
        return result;
    }
};
</code></pre>

<p><strong>two real problems .</strong></p>

<ul>
<li><p>how to find the sum?<br/>
change it to a 2 sum problem. when you have one value, the sum of the other two is -value.<br/>
2 sum problem has a O(n) solution. so the final is O(n<sup>2).</sup></p></li>
<li><p>how to remove the duplicate?<br/>
for same values, we only use the first one and pass the rest.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arranging Coins]]></title>
    <link href="https://lockxmonk.github.io/15113375347657.html"/>
    <updated>2017-11-22T15:58:54+08:00</updated>
    <id>https://lockxmonk.github.io/15113375347657.html</id>
    <content type="html"><![CDATA[
<p>You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.</p>

<p>Given n, find the total number of full staircase rows that can be formed.</p>

<p>n is a non-negative integer and fits within the range of a 32-bit signed integer.</p>

<p><img src="media/15113375347657/15113375557158.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int arrangeCoins(int n) {
        return floor(-0.5+sqrt((double)2*n+0.25));
    }
};
</code></pre>

<p>这道题的主要考虑<code>1+2+3+...+x&lt;=n</code>下，使x左边等式最接近n，并且不超过。</p>

<p>推导为：</p>

<pre><code>-&gt; 1+2+3+...+x = n
-&gt; (1+x)x/2 = n
-&gt; x^2+x = 2n
-&gt; x^2+x+1/4 = 2n +1/4
-&gt; (x+1/2)^2 = 2n +1/4
-&gt; (x+0.5) = sqrt(2n+0.25)
-&gt; x = -0.5 + sqrt(2n+0.25)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add Binary]]></title>
    <link href="https://lockxmonk.github.io/15113344881540.html"/>
    <updated>2017-11-22T15:08:08+08:00</updated>
    <id>https://lockxmonk.github.io/15113344881540.html</id>
    <content type="html"><![CDATA[
<p>Given two binary strings, return their sum (also a binary string).</p>

<p>For example,<br/>
a = <code>&quot;11&quot;</code><br/>
b = <code>&quot;1&quot;</code><br/>
Return <code>&quot;100&quot;</code>.</p>

<pre><code class="language-c++">class Solution {
public:
    string addBinary(string a, string b) {
        int fw = 0;
        string result = &quot;&quot;;
        for(int i = a.size()-1,j=b.size()-1;i&gt;=0||j&gt;=0;i--,j--){
            int ag = i&gt;=0?a[i]-&#39;0&#39;:0;
            int bg = j&gt;=0?b[j]-&#39;0&#39;:0;
            int tmp = (ag+bg+fw)%2;
            fw = (ag+bg+fw)/2;
            
            result = char(tmp+&#39;0&#39;)+result;
        }
        if(fw==1){
            result = &#39;1&#39;+result;
        }
        
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1-bit and 2-bit Characters]]></title>
    <link href="https://lockxmonk.github.io/15113344372070.html"/>
    <updated>2017-11-22T15:07:17+08:00</updated>
    <id>https://lockxmonk.github.io/15113344372070.html</id>
    <content type="html"><![CDATA[
<p>We have two special characters. The first character can be represented by one bit <code>0</code>. The second character can be represented by two bits (<code>10 or 11</code>).</p>

<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.<br/>
<img src="media/15113344372070/15113344696565.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    bool isOneBitCharacter(vector&lt;int&gt;&amp; bits) {
        int i = 0;
        int b = 0;
        while(i&lt;bits.size()){            
            if(bits[i]==1)
            {
                i=i+2;
                b=0;
            }else{
                i++;
                b=1;
            }
        };
        if(b==0){
            return 0;
        }else {
            return 1; 
        }
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add Digits]]></title>
    <link href="https://lockxmonk.github.io/15113342915297.html"/>
    <updated>2017-11-22T15:04:51+08:00</updated>
    <id>https://lockxmonk.github.io/15113342915297.html</id>
    <content type="html"><![CDATA[
<p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>

<p>For example:</p>

<p>Given <code>num = 38</code>, the process is like: <code>3 + 8 = 11</code>, <code>1 + 1 = 2</code>. Since <code>2</code> has only one digit, return it.</p>

<p>Follow up:<br/>
Could you do it without any loop/recursion in O(1) runtime?</p>

<pre><code class="language-c++">class Solution {
public:
    int addDigits(int num) {
        // while(num/10&gt;0){
        //     int sum = 0;
        //     while(num&gt;0){
        //         sum +=num%10;
        //         num /=10;
        //     }
        //     num = sum;
        // }
        return 1+ (num-1)%9;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add Strings]]></title>
    <link href="https://lockxmonk.github.io/15113342227318.html"/>
    <updated>2017-11-22T15:03:42+08:00</updated>
    <id>https://lockxmonk.github.io/15113342227318.html</id>
    <content type="html"><![CDATA[
<p>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p>

<p>Note:</p>

<p>The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.<br/>
Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.<br/>
Both <code>num1</code> and <code>num2</code> does not contain any leading zero.<br/>
You must not use any built-in BigInteger library or convert the inputs to integer directly.</p>

<pre><code class="language-c++">class Solution {
public:
    string addStrings(string num1, string num2) {
        int fw = 0;
        string result =&quot;&quot;;
        for(int i = num1.size()-1,j = num2.size()-1;i&gt;=0||j&gt;=0;i--,j--){
            int n1 = i&gt;=0 ? num1[i]-&#39;0&#39;:0;
            int n2 = j&gt;=0 ? num2[j]-&#39;0&#39;:0;
            int tmp = (n1+n2+fw)%10;
            fw = (n1+n2+fw)/10;
            result = char(tmp+&#39;0&#39;) + result;
        }
        if(fw){
            result = char(fw +&#39;0&#39;)+ result;
        }
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking的简单使用]]></title>
    <link href="https://lockxmonk.github.io/15109904843500.html"/>
    <updated>2017-11-18T15:34:44+08:00</updated>
    <id>https://lockxmonk.github.io/15109904843500.html</id>
    <content type="html"><![CDATA[
<p>最近看学习一些项目代码到了使用<code>AFNetworking</code>的项目，所以去学习了一下，这里简单的总结一下，<code>AFNetworking</code>的使用方法。</p>

<h2 id="toc_0">AFNetworking简介</h2>

<p><code>AFNetworking</code>是一个很受大众欢迎的网络框架，可以帮助管理和处理网络任务请求，包括下载、上传、<code>get</code>、<code>post</code>请求等。</p>

<h2 id="toc_1">安装</h2>

<p><code>AFNetworking</code>的安装可以使用<code>CocoaPods</code>在文件中加入：</p>

<pre><code class="language-objc">pod &#39;AFNetworking&#39;
</code></pre>

<p>并执行 <code>pod install</code>就可以了。有一点要注意的是最新版本为<code>3.1</code>这个版本删除了基于<code>NSURLConnectionOperation</code>的<code>AFHTTPRequestOperationManager</code>的支持。转而使用基于<code>NSURLSession</code>封装的<code>AFHTTPSessionManager</code>。</p>

<h2 id="toc_2">网络监听</h2>

<p><code>AFNetworking</code>提供了一个监听网络状态的方法，来实时的判断当前网络是否良好。具体代码如下：</p>

<pre><code class="language-objc">// 如果要检测网络状态的变化,必须用检测管理器的单例的startMonitoring
    /**
     AFNetworkReachabilityStatusUnknown          = -1,  // 未知
     AFNetworkReachabilityStatusNotReachable     = 0,   // 无连接
     AFNetworkReachabilityStatusReachableViaWWAN = 1,   // 3G 花钱
     AFNetworkReachabilityStatusReachableViaWiFi = 2,   // 局域网络,不花钱
     */
    [[AFNetworkReachabilityManager sharedManager] startMonitoring];
    [[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
        debugLog(@&quot;%ld&quot;,(long)status);
    }];
</code></pre>

<p>根据当前网络状态会输出所对应的状态数值。</p>

<h2 id="toc_3">下载</h2>

<pre><code class="language-objc">    //session的默认配置
    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    //根据配置创建管理者
    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];
    NSURL *url = [NSURL URLWithString:@&quot;http://smartdsp.xmu.edu.cn/memberpdf/fuxueyang/cvpr2017/cvpr2017.pdf&quot;];
    //根据url创建请求对象
    NSURLRequest *request = [NSURLRequest requestWithURL:url];
    //创建下载任务
    NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {
        //设置下载路径
        NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
        //返回文件存放在本地的地址
        return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];
    } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) {
        //下载完成后调用方法
        debugLog(@&quot;File download to:%@ , %@&quot;,filePath,error);
    }];
    //开始下载任务
    [downloadTask resume];
</code></pre>

<h2 id="toc_4">get请求</h2>

<pre><code class="language-objc">    NSString *urlString = @&quot;https://www.weifar.com/api/ExamQuestion/id&quot;;
    NSDictionary *parameters = @{@&quot;id&quot;:@6};
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    //根据上述参数和请求地址来发送请求
    [manager GET:urlString parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) {
        debugLog(@&quot;%@&quot;,downloadProgress);
    } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        //成功获取数据后，进行处理
        if (responseObject) {
            NSArray *a = responseObject[@&quot;Questions&quot;];
            NSDictionary *dic = a[0];
            NSString *str = dic[@&quot;BlockDescription&quot;];
            debugLog(@&quot;%@&quot;,str);
        }
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        //请求失败，打印错误
        debugLog(@&quot;%@&quot;,error);
    }];
</code></pre>

<h2 id="toc_5">总结</h2>

<p>以上就是<code>AFNetworking</code>的基本使用，还有其他的一些功能由于没有合适的接口可以进行操作，暂且先搁置下。具体的操作可以参考官方的<code>AFNetworking</code><a href="http://cocoadocs.org/docsets/AFNetworking/3.1.0/index.html">API文档</a>,</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FMDB的使用方法]]></title>
    <link href="https://lockxmonk.github.io/15109022752813.html"/>
    <updated>2017-11-17T15:04:35+08:00</updated>
    <id>https://lockxmonk.github.io/15109022752813.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">FMDB简介</a>
</li>
<li>
<a href="#toc_1">使用方法</a>
<ul>
<li>
<a href="#toc_2">引入相关文件</a>
</li>
<li>
<a href="#toc_3">建立数据库</a>
</li>
<li>
<a href="#toc_4">打开数据库</a>
</li>
<li>
<a href="#toc_5">执行更新（update）操作</a>
</li>
<li>
<a href="#toc_6">执行查询操作</a>
</li>
<li>
<a href="#toc_7">数据参数</a>
</li>
<li>
<a href="#toc_8">线程安全</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_9">总结</a>


<p>最近再看其它大牛写的项目代码，发现许多用到了<code>FMDB</code>，所以去了解了一下。</p>

<h2 id="toc_0">FMDB简介</h2>

<p>FMDB是一个第三方的开源库，我们可以通过<code>cocopods</code>搜索并整合到项目里面，FMDB其实就是对<code>SQLite</code>的<code>API</code>进行了封装，加上了面向对象的思想，让我们不必使用繁琐的<code>C</code>语言<code>API</code>函数，比起直接操作<code>SQLite</code>更加方便。</p>

<p>并且<code>FMDB</code> 同时兼容 <code>ARC</code> 和非 <code>ARC</code> 工程，会自动根据工程配置来调整相关的内存管理代码。</p>

<h2 id="toc_1">使用方法</h2>

<p>本文使用方法，均参考<code>FMDB</code>的<code>github</code>项目文档<a href="https://github.com/ccgus/fmdb">https://github.com/ccgus/fmdb</a></p>

<h3 id="toc_2">引入相关文件</h3>

<p>因为是对<code>sqlite</code>的封装所以我们在项目中需要引入它的库。<br/>
<img src="media/15109022752813/15109026776351.jpg" alt=""/></p>

<p>之后在文件中导入它的头文件：</p>

<pre><code class="language-objc">#import &quot;FMDB.h&quot;
</code></pre>

<h3 id="toc_3">建立数据库</h3>

<p>建立数据库只有简单的一句代码，如果当前路径不存在所需的数据库则会自动创建，若存在则会获取到。当路径为字符（<code>@“”</code>）时，一个空的数据库将被创建在临时的位置，数据库关闭时候将被自动删除。路径为<code>NULL</code>时空数据库会被放在内存中，关闭时也将自动被删除。具体信息可以参见：<a href="http://www.sqlite.org/inmemorydb.html">http://www.sqlite.org/inmemorydb.html</a></p>

<pre><code class="language-objc">#define PATH_OF_DOCUMENT    [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]

_path = [PATH_OF_DOCUMENT stringByAppendingPathComponent:@&quot;test.db&quot;];
//创建数据库
FMDatabase *db = [FMDatabase databaseWithPath:_path];
</code></pre>

<h3 id="toc_4">打开数据库</h3>

<p>在对数据库进行交互时，必须要先打开它。如果打开失败，可能是权限不足或者资源不足。</p>

<pre><code class="language-objc">if (![db open]) {
    // [db release];   // uncomment this line in manual referencing code; in ARC, this is not necessary/permitted
    db = nil;
    return;
}
</code></pre>

<h3 id="toc_5">执行更新（update）操作</h3>

<p>FMDB中除了<code>select</code>为查询（<code>query</code>）以为都为更新操作。</p>

<p>例如我们执行一个<strong>插入</strong>操作的完整步骤为：</p>

<pre><code class="language-objc">    static int idx = 1;
    FMDatabase *db = [FMDatabase databaseWithPath:_path];
    if ([db open]) {
        NSString * sql = @&quot;insert into User (name, password) values(?, ?) &quot;;
        NSString *name = [NSString stringWithFormat:@&quot;lzh%d&quot;,idx++];
        BOOL result = [db executeUpdate:sql,name,@&quot;op&quot;];
        if (!result) {
            debugLog(@&quot;error to insert data&quot;);
        }else{
            debugLog(@&quot;succ to insert data&quot;);
        }
        [db close];
    }
</code></pre>

<p><strong>查询</strong>操作：</p>

<pre><code class="language-objc">    FMDatabase *db = [FMDatabase databaseWithPath:_path];
    if ([db open]) {
        NSString *sql =@&quot;select * from User&quot;;
        FMResultSet *result = [db executeQuery:sql];
        while ([result next]) {
            int userId = [result intForColumn:@&quot;id&quot;];
            NSString *name = [result stringForColumn:@&quot;name&quot;];
            NSString *pass = [result stringForColumn:@&quot;password&quot;];
            debugLog(@&quot;user id = %d, name = %@, pass = %@&quot;, userId, name, pass);
        }
        [db close];
    }
</code></pre>

<p><strong>删除</strong>操作：</p>

<pre><code class="language-objc">    static int idx = 1;
    FMDatabase *db =[FMDatabase databaseWithPath:_path];
    if ([db open]) {
        NSString *sql = @&quot;delete from User where id = ?&quot;;
        BOOL result = [db executeUpdate:sql , @(idx++)];
        if (!result) {
            debugLog(@&quot;error to delete db data&quot;);
        } else {
            debugLog(@&quot;succ to deleta db data&quot;);
        }
        [db close];
    }
</code></pre>

<p>我们可以看到执行<code>sql</code>语句的时候用的都是<code>executeUpdate：</code>方法。</p>

<h3 id="toc_6">执行查询操作</h3>

<p>查询操作与上面的有点区别，我们需要用<code>FMResultSet</code>来存储我们的查询结果，并调用它的<code>next：</code>方法来对数据进行逐行操作：</p>

<pre><code class="language-objc">    FMDatabase *db = [FMDatabase databaseWithPath:_path];
    if ([db open]) {
        NSString *sql =@&quot;select * from User&quot;;
        FMResultSet *result = [db executeQuery:sql];
        while ([result next]) {
            int userId = [result intForColumn:@&quot;id&quot;];
            NSString *name = [result stringForColumn:@&quot;name&quot;];
            NSString *pass = [result stringForColumn:@&quot;password&quot;];
            debugLog(@&quot;user id = %d, name = %@, pass = %@&quot;, userId, name, pass);
        }
        [db close];
    }
</code></pre>

<p>上面代码可以发现执行<code>sql</code>语句变为<code>executeQuery:</code>方法，该方法会将结果返回为<code>FMResultSet</code>类型，之后我们需要调用<code>stringForColumn:</code>对结果进行解析。<br/>
<code>FMDB</code>提供如下多个方法来获取不同类型的数据：</p>

<pre><code class="language-objc">intForColumn:
longForColumn:
longLongIntForColumn:
boolForColumn:
doubleForColumn:
stringForColumn:
dateForColumn:
dataForColumn:
dataNoCopyForColumn:
UTF8StringForColumn:
objectForColumn:
</code></pre>

<p>也可以按照列的索引对数据进行获取，<code>{type}ForColumnIndex:</code></p>

<h3 id="toc_7">数据参数</h3>

<p>我们可以在<code>sql</code>语句中，用<code>？</code>表示执行语句的参数，然后在 <code>executeUpdate：</code>方法来将<code>?</code>所指代的具体参数传入，例如上面的代码：</p>

<pre><code class="language-objc">    NSString * sql = @&quot;insert into User (name, password) values(?, ?) &quot;;
    NSString *name = [NSString stringWithFormat:@&quot;lzh%d&quot;,idx++];
    BOOL result = [db executeUpdate:sql,name,@&quot;op&quot;];
</code></pre>

<h3 id="toc_8">线程安全</h3>

<p><code>FMDatabase</code>这个类是线程不安全的，如果在多个线程同时使用一个<code>FMDatabase</code>实例，会造成数据混乱问题。所以，提供了一个<code>FMDatabaseQueue</code>并且使用它来对多个线程间进行交互，<code>FMDatabaseQueue</code>对象将通过接入多个线程进行同步和整合。</p>

<p>使用的方法也很简单：</p>

<p>首先创建一个数据库<code>path</code>来初始化<code>FMDatabaseQueue</code>，然后就可以将一个闭包 (block) 传入 <code>inDatabase</code> 方法中。</p>

<pre><code class="language-objc">
FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];

[queue inDatabase:^(FMDatabase *db) {
    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @1];
    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @2];
    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @3];

    FMResultSet *rs = [db executeQuery:@&quot;select * from foo&quot;];
    while ([rs next]) {
        …
    }
}];
</code></pre>

<p>按照上面的方法我们可以创建多个线程来异步的对数据库进行操作：</p>

<pre><code class="language-objc">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:_path];
    dispatch_queue_t q1 = dispatch_queue_create(&quot;queue1&quot;, NULL);
    dispatch_queue_t q2 = dispatch_queue_create(&quot;queue2&quot;, NULL);
    
    dispatch_async(q1, ^{
        for (int i =1; i&lt;100; ++i) {
            [queue inDatabase:^(FMDatabase *db){
                NSString *sql = @&quot;insert into User (name, password) values(?, ?)&quot;;
                NSString *name = [NSString stringWithFormat:@&quot;queue1 %d&quot;, i];
                BOOL result = [db executeUpdate:sql,name,@&quot;opop&quot;];
                if (!result) {
                    debugLog(@&quot;error to add db data: %@&quot;, name);
                } else {
                    debugLog(@&quot;succ to add db data: %@&quot;, name);
                }
            }];
        }
    });
    dispatch_async(q2,^{
        for (int i = 0; i &lt; 100; ++i) {
            [queue inDatabase:^(FMDatabase *db) {
                NSString * sql = @&quot;insert into user (name, password) values(?, ?) &quot;;
                NSString * name = [NSString stringWithFormat:@&quot;queue2 %d&quot;, i];
                BOOL result = [db executeUpdate:sql, name, @&quot;opop22&quot;];
                if (!result) {
                    debugLog(@&quot;error to add db data: %@&quot;, name);
                } else {
                    debugLog(@&quot;succ to add db data: %@&quot;, name);
                }
            }];
        }
    });
</code></pre>

<p>执行后可以发现数据库中的部分表数据如下：<br/>
<img src="media/15109022752813/15109055831966.jpg" alt=""/></p>

<p>两个线程可以异步执行互不干扰。</p>

<p>上面数据库的显示 使用的是<code>Navicat</code>，也有其它的数据库管理软件可以显示。</p>

<h1 id="toc_9">总结</h1>

<p><code>FMDB</code>是一个在<code>iOS</code>上简化<code>sqlite API</code>的第三方库，对<code>sqlite</code>进行了很有好的封装，便于维护与增加效率。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[贪心算法（构造霍夫曼树）]]></title>
    <link href="https://lockxmonk.github.io/15097619961308.html"/>
    <updated>2017-11-04T10:19:56+08:00</updated>
    <id>https://lockxmonk.github.io/15097619961308.html</id>
    <content type="html"><![CDATA[
<p>霍夫曼树的构造是使用了变长编码来减少数据所占空间，一般我们只考虑<strong>前缀码</strong>，即没有任何码字是其它码字的前缀。</p>

<p>我们的构造过程如下所示：</p>

<p><img src="media/15097619961308/15097621720916.jpg" alt=""/></p>

<p>这里我们根据上述表示，我们每次总是“贪心”的选择两个最小的值来求和，并插入队列中。所以我们可以构造一个最小优先队列来存储各字母的频率。算法代码如下：</p>

<pre><code class="language-c++">//
//  main.cpp
//  HUFFMAN
//
//  Created by LZH on 2017/11/4.
//  Copyright © 2017年 LZH. All rights reserved.
//

#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

typedef struct BitNode
{
    int frep;
    struct BitNode *left;
    struct BitNode *right;
}Node;

//定义比较结构
struct cmp1{
    bool operator ()(int &amp;a,int &amp;b){
        return a&gt;b;//最小值优先
    }
};
//构造霍夫曼树
void HUFFMAN(int c, priority_queue&lt;int, vector&lt;int&gt;, cmp1&gt; &amp;que1)
{
    int n = c;
    for (int i=0; i&lt;n-1; i++) {
        Node *newNodeZ = (Node*)malloc(sizeof(Node));
        Node *newNodeX = (Node*)malloc(sizeof(Node));
        Node *newNodeY = (Node*)malloc(sizeof(Node));
        newNodeX-&gt;frep = que1.top();
        que1.pop();
        newNodeY-&gt;frep = que1.top();
        que1.pop();
        newNodeZ-&gt;left = newNodeX;
        newNodeZ-&gt;right = newNodeY;
        
        newNodeZ-&gt;frep =newNodeX-&gt;frep + newNodeY-&gt;frep;
        que1.push(newNodeZ-&gt;frep);
    }
}

int main() {
//    priority_queue&lt;int&gt; que; //构造优先队列
    int b[6] = {9,5,12,13,16,45};
//    vector&lt;int&gt; a(b,b+6);
    priority_queue&lt;int , vector&lt;int&gt;, cmp1 &gt;que1; //最小优先队列
    for (int i=0; i&lt;6; i++) {
        que1.push(b[i]);
    }
    HUFFMAN(6, que1);
    while (!que1.empty()) {
        cout&lt;&lt;que1.top()&lt;&lt;&#39; &#39;;
        que1.pop();
    }
    return 0;
}

</code></pre>

<p>最后输出为100，返回了编码树的根节点。<br/>
<img src="media/15097619961308/15097623765624.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[贪心算法（活动选择问题）]]></title>
    <link href="https://lockxmonk.github.io/15096800741665.html"/>
    <updated>2017-11-03T11:34:34+08:00</updated>
    <id>https://lockxmonk.github.io/15096800741665.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15096800741665/15096801101097.jpg" alt=""/></p>

<p>这个问题是一个典型的可以运用贪心算法的题目，我们在初始的选择一个活动之后，应该将之后的资源被其他任务尽量多的占用。所以我们应该第一个选择活动最快结束的活动，因为它剩下的资源可以被它之后开始的任务尽量多的使用。所以我们可以运用一种递归形式或者迭代算法来表达这个形式：</p>

<pre><code class="language-c++">//
//  main.cpp
//  Greedy_Activity_Selector
//
//  Created by LZH on 2017/11/3.
//  Copyright © 2017年 LZH. All rights reserved.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
void print(int n)
{
    cout&lt;&lt;n&lt;&lt;&#39; &#39;;
}

/**
 迭代形式函数

 @param s 活动开始时间数组
 @param f 活动结束时间数组
 @param result  用于存储结果
 */
void GREED_ACTIVITY_SELECTOR(vector&lt;int&gt; s , vector&lt;int&gt; f , vector&lt;int&gt; &amp;result)
{
    int n = s.size();
    result.push_back(1);
    int k=1;
    for (int m=2; m&lt;=n; m++) {
        if (s[m]&gt;=f[k]) {
            result.push_back(m);
            k = m;
        }
    }
}

/**
 尾递归形式函数

 @param s 活动开始时间数组
 @param f 活动结束时间数组
 @param k 从活动k开始计算
 @param n 共有n个活动
 @param result 用于存储结果
 */
void RECURSIVE_ACTIVITY_SELECTOR(vector&lt;int&gt; s,vector&lt;int&gt; f, int k, int n, vector&lt;int&gt; &amp;result)
{
    int m = k+1;
    while (m&lt;=n &amp;&amp; s[m]&lt;=f[k]) {
        m++;
    }
    if (m&lt;=n) {
        result.push_back(m);
        RECURSIVE_ACTIVITY_SELECTOR(s, f, m, n ,result);
    }
}

int main() {
    int a[12] ={0,1,3,0,5,3,5,6,8,8,2,12};
    int b[12] ={0,4,5,6,7,9,9,10,11,12,14,16};
    vector&lt;int&gt; s(a,a+12);
    vector&lt;int&gt; f(b,b+12);
    vector&lt;int&gt; result;
    RECURSIVE_ACTIVITY_SELECTOR(s, f, 0, 11, result);
    GREED_ACTIVITY_SELECTOR(s, f, result);
    for_each(result.begin(),result.end(),print);
    return 0;
}

</code></pre>

<p>其中递归形式的流程如下图所示：<br/>
<img src="media/15096800741665/15096804218816.jpg" alt=""/></p>

<p>但两种算法运行时间类似都为\(\Theta(n)\)</p>

<h2 id="toc_0">与动态规划的不同</h2>

<p>贪心算法通过做出局部最优来构造全局最优解。换句话说，直接做出在当前问题下看起来最优的选择，而不必考虑子问题的解。</p>

<p><strong><font color=red>在动态规划中，每个步骤都要进行一次选择，但选择通常依赖于子问题的解</font></strong>，因此，我们通常以自底向上的方式来求解动态规划问题，先求解较小的子问题，然后是较大的子问题。但是在贪心算法中，我们总是做出在当时看起来最佳的选择，然后求解剩下的唯一子问题。<strong><font color=red>贪心算法进行选择时可能依赖之前做出的选择，但不依赖于任何将来的选择或者是子问题的解。</font></strong>所以贪心算法在进行第一次选择时不求解任何子问题，自顶向下进行逐步选择，将给定的子问题实例变小。</p>

<p>两者最典型的区别，可以用<code>分数背包</code>和<code>0-1背包</code>问题来举例，这里不做细说。</p>

]]></content>
  </entry>
  
</feed>
