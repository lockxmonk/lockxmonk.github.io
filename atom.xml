<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2017-11-23T11:29:18+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Degree of an Array]]></title>
    <link href="https://lockxmonk.github.io/15114255869932.html"/>
    <updated>2017-11-23T16:26:26+08:00</updated>
    <id>https://lockxmonk.github.io/15114255869932.html</id>
    <content type="html"><![CDATA[
<p>Given a non-empty array of non-negative integers <code>nums</code>, the degree of this array is defined as the maximum frequency of any one of its elements.</p>

<p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p>

<p><img src="media/15114255869932/15114256313220.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {
        
        if (nums.size()&lt;2) {
            return nums.size();
        }
        unordered_map&lt;int, int&gt;startIndex , number;
        int len = nums.size();
        int fre = 0;
        for (int i=0; i&lt;nums.size(); i++) {
            if (startIndex.count(nums[i])==0) {
                startIndex[nums[i]]=i;
            }
            number[nums[i]]++;
            if (number[nums[i]]==fre) {
                len = min(i-startIndex[nums[i]]+1, len);
            }
            if (number[nums[i]]&gt;fre) {
                len = i - startIndex[nums[i]] + 1;
                fre = number[nums[i]];
            }
        }
        
        return len;
    }
};
</code></pre>

<p>该算法主要使用了两个<code>hash_map</code>:<br/>
一个来记录数字所出现的次数，另一个记录数字最开始出现的位置。一旦有一个数字的频数超过了当前的<code>len</code>，则更新<code>len</code>，若两个数字出现的频率相等则取长度最小的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find Pivot Index]]></title>
    <link href="https://lockxmonk.github.io/15114222067093.html"/>
    <updated>2017-11-23T15:30:06+08:00</updated>
    <id>https://lockxmonk.github.io/15114222067093.html</id>
    <content type="html"><![CDATA[
<p>Given an array of integers <code>nums</code>, write a method that returns the &quot;pivot&quot; index of this array.</p>

<p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p>

<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>

<p><img src="media/15114222067093/15114222397308.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int pivotIndex(vector&lt;int&gt;&amp; nums) {
        
        if(nums.empty()) return -1;
        
        int sum = 0;
        for(int i=0;i&lt;nums.size();i++) sum+=nums[i];
    
        int leftSum = 0;
        for(int j=0;j&lt;nums.size();j++)
        {
            if (leftSum == sum - nums[j] -leftSum) {
                return j;
        }
            leftSum += nums[j];
        }
        
        return -1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Time to Buy and Sell Stock II]]></title>
    <link href="https://lockxmonk.github.io/15114072257756.html"/>
    <updated>2017-11-23T11:20:25+08:00</updated>
    <id>https://lockxmonk.github.io/15114072257756.html</id>
    <content type="html"><![CDATA[
<p>Say you have an array for which the \(i^{th}\) element is the price of a given stock on day i.</p>

<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>

<pre><code class="language-c++">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int result = 0;
        for(int i = 1;i&lt;prices.size();i++)
        {
            result += max(prices[i]-prices[i-1] , 0);
        }
        return result;
    }
};

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Time to Buy and Sell Stock]]></title>
    <link href="https://lockxmonk.github.io/15114062990936.html"/>
    <updated>2017-11-23T11:04:59+08:00</updated>
    <id>https://lockxmonk.github.io/15114062990936.html</id>
    <content type="html"><![CDATA[
<p>Say you have an array for which the \(i^{th}\) element is the price of a given stock on day i.</p>

<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>

<p><img src="media/15114062990936/15114063447573.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int minPrice=INT_MAX;
        int maxProfit = 0;
        
        for (int i=0; i&lt;prices.size(); i++) {
            minPrice = min(prices[i], minPrice);
            maxProfit = max(maxProfit, prices[i]-minPrice);
        }
        
        return maxProfit;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Array Partition I]]></title>
    <link href="https://lockxmonk.github.io/15114035796843.html"/>
    <updated>2017-11-23T10:19:39+08:00</updated>
    <id>https://lockxmonk.github.io/15114035796843.html</id>
    <content type="html"><![CDATA[
<p>Given an array of <strong>2n</strong> integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>

<p><img src="media/15114035796843/15114036022226.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int arrayPairSum(vector&lt;int&gt;&amp; nums) {
        
        sort(nums.begin(),nums.end());
        int result=0;
        for (int i=0; i&lt;nums.size(); i+=2) {
            result+=nums[i];
        }
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3Sum]]></title>
    <link href="https://lockxmonk.github.io/15114026353930.html"/>
    <updated>2017-11-23T10:03:55+08:00</updated>
    <id>https://lockxmonk.github.io/15114026353930.html</id>
    <content type="html"><![CDATA[
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>

<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>

<p><img src="media/15114026353930/15114026868536.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(),nums.end());
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; tmpResult;
        
        int p,q,tmp;
        for(int i = 0 ;i&lt;nums.size();i++)
        {
            if(i!=0&amp;&amp;nums[i]==nums[i-1]) continue;
            int currentNum = nums[i];
            p = i+1;
            q = nums.size()-1;
            
            while(p&lt;q)
            {
                if(p!=i+1&amp;&amp;nums[p]==nums[p-1])
                {
                    p++;
                    continue;
                }
                tmp = nums[q]+nums[p];
                if(tmp==-currentNum)
                {
                    tmpResult.push_back(currentNum);
                    tmpResult.push_back(nums[q]);
                    tmpResult.push_back(nums[p]);
                    result.push_back(tmpResult);
                    tmpResult.clear();
                    p++;
                    q--;
                }else if (tmp&gt;-currentNum)
                {
                    q--;
                }else p++;
            }
        }
        
        return result;
    }
};
</code></pre>

<p><strong>two real problems .</strong></p>

<ul>
<li><p>how to find the sum?<br/>
change it to a 2 sum problem. when you have one value, the sum of the other two is -value.<br/>
2 sum problem has a O(n) solution. so the final is O(n<sup>2).</sup></p></li>
<li><p>how to remove the duplicate?<br/>
for same values, we only use the first one and pass the rest.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arranging Coins]]></title>
    <link href="https://lockxmonk.github.io/15113375347657.html"/>
    <updated>2017-11-22T15:58:54+08:00</updated>
    <id>https://lockxmonk.github.io/15113375347657.html</id>
    <content type="html"><![CDATA[
<p>You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.</p>

<p>Given n, find the total number of full staircase rows that can be formed.</p>

<p>n is a non-negative integer and fits within the range of a 32-bit signed integer.</p>

<p><img src="media/15113375347657/15113375557158.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int arrangeCoins(int n) {
        return floor(-0.5+sqrt((double)2*n+0.25));
    }
};
</code></pre>

<p>这道题的主要考虑<code>1+2+3+...+x&lt;=n</code>下，使x左边等式最接近n，并且不超过。</p>

<p>推导为：</p>

<pre><code>-&gt; 1+2+3+...+x = n
-&gt; (1+x)x/2 = n
-&gt; x^2+x = 2n
-&gt; x^2+x+1/4 = 2n +1/4
-&gt; (x+1/2)^2 = 2n +1/4
-&gt; (x+0.5) = sqrt(2n+0.25)
-&gt; x = -0.5 + sqrt(2n+0.25)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add Binary]]></title>
    <link href="https://lockxmonk.github.io/15113344881540.html"/>
    <updated>2017-11-22T15:08:08+08:00</updated>
    <id>https://lockxmonk.github.io/15113344881540.html</id>
    <content type="html"><![CDATA[
<p>Given two binary strings, return their sum (also a binary string).</p>

<p>For example,<br/>
a = <code>&quot;11&quot;</code><br/>
b = <code>&quot;1&quot;</code><br/>
Return <code>&quot;100&quot;</code>.</p>

<pre><code class="language-c++">class Solution {
public:
    string addBinary(string a, string b) {
        int fw = 0;
        string result = &quot;&quot;;
        for(int i = a.size()-1,j=b.size()-1;i&gt;=0||j&gt;=0;i--,j--){
            int ag = i&gt;=0?a[i]-&#39;0&#39;:0;
            int bg = j&gt;=0?b[j]-&#39;0&#39;:0;
            int tmp = (ag+bg+fw)%2;
            fw = (ag+bg+fw)/2;
            
            result = char(tmp+&#39;0&#39;)+result;
        }
        if(fw==1){
            result = &#39;1&#39;+result;
        }
        
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[1-bit and 2-bit Characters]]></title>
    <link href="https://lockxmonk.github.io/15113344372070.html"/>
    <updated>2017-11-22T15:07:17+08:00</updated>
    <id>https://lockxmonk.github.io/15113344372070.html</id>
    <content type="html"><![CDATA[
<p>We have two special characters. The first character can be represented by one bit <code>0</code>. The second character can be represented by two bits (<code>10 or 11</code>).</p>

<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.<br/>
<img src="media/15113344372070/15113344696565.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    bool isOneBitCharacter(vector&lt;int&gt;&amp; bits) {
        int i = 0;
        int b = 0;
        while(i&lt;bits.size()){            
            if(bits[i]==1)
            {
                i=i+2;
                b=0;
            }else{
                i++;
                b=1;
            }
        };
        if(b==0){
            return 0;
        }else {
            return 1; 
        }
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add Digits]]></title>
    <link href="https://lockxmonk.github.io/15113342915297.html"/>
    <updated>2017-11-22T15:04:51+08:00</updated>
    <id>https://lockxmonk.github.io/15113342915297.html</id>
    <content type="html"><![CDATA[
<p>Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.</p>

<p>For example:</p>

<p>Given <code>num = 38</code>, the process is like: <code>3 + 8 = 11</code>, <code>1 + 1 = 2</code>. Since <code>2</code> has only one digit, return it.</p>

<p>Follow up:<br/>
Could you do it without any loop/recursion in O(1) runtime?</p>

<pre><code class="language-c++">class Solution {
public:
    int addDigits(int num) {
        // while(num/10&gt;0){
        //     int sum = 0;
        //     while(num&gt;0){
        //         sum +=num%10;
        //         num /=10;
        //     }
        //     num = sum;
        // }
        return 1+ (num-1)%9;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add Strings]]></title>
    <link href="https://lockxmonk.github.io/15113342227318.html"/>
    <updated>2017-11-22T15:03:42+08:00</updated>
    <id>https://lockxmonk.github.io/15113342227318.html</id>
    <content type="html"><![CDATA[
<p>Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.</p>

<p>Note:</p>

<p>The length of both <code>num1</code> and <code>num2</code> is &lt; 5100.<br/>
Both <code>num1</code> and <code>num2</code> contains only digits <code>0-9</code>.<br/>
Both <code>num1</code> and <code>num2</code> does not contain any leading zero.<br/>
You must not use any built-in BigInteger library or convert the inputs to integer directly.</p>

<pre><code class="language-c++">class Solution {
public:
    string addStrings(string num1, string num2) {
        int fw = 0;
        string result =&quot;&quot;;
        for(int i = num1.size()-1,j = num2.size()-1;i&gt;=0||j&gt;=0;i--,j--){
            int n1 = i&gt;=0 ? num1[i]-&#39;0&#39;:0;
            int n2 = j&gt;=0 ? num2[j]-&#39;0&#39;:0;
            int tmp = (n1+n2+fw)%10;
            fw = (n1+n2+fw)/10;
            result = char(tmp+&#39;0&#39;) + result;
        }
        if(fw){
            result = char(fw +&#39;0&#39;)+ result;
        }
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AFNetworking的简单使用]]></title>
    <link href="https://lockxmonk.github.io/15109904843500.html"/>
    <updated>2017-11-18T15:34:44+08:00</updated>
    <id>https://lockxmonk.github.io/15109904843500.html</id>
    <content type="html"><![CDATA[
<p>最近看学习一些项目代码到了使用<code>AFNetworking</code>的项目，所以去学习了一下，这里简单的总结一下，<code>AFNetworking</code>的使用方法。</p>

<h2 id="toc_0">AFNetworking简介</h2>

<p><code>AFNetworking</code>是一个很受大众欢迎的网络框架，可以帮助管理和处理网络任务请求，包括下载、上传、<code>get</code>、<code>post</code>请求等。</p>

<h2 id="toc_1">安装</h2>

<p><code>AFNetworking</code>的安装可以使用<code>CocoaPods</code>在文件中加入：</p>

<pre><code class="language-objc">pod &#39;AFNetworking&#39;
</code></pre>

<p>并执行 <code>pod install</code>就可以了。有一点要注意的是最新版本为<code>3.1</code>这个版本删除了基于<code>NSURLConnectionOperation</code>的<code>AFHTTPRequestOperationManager</code>的支持。转而使用基于<code>NSURLSession</code>封装的<code>AFHTTPSessionManager</code>。</p>

<h2 id="toc_2">网络监听</h2>

<p><code>AFNetworking</code>提供了一个监听网络状态的方法，来实时的判断当前网络是否良好。具体代码如下：</p>

<pre><code class="language-objc">// 如果要检测网络状态的变化,必须用检测管理器的单例的startMonitoring
    /**
     AFNetworkReachabilityStatusUnknown          = -1,  // 未知
     AFNetworkReachabilityStatusNotReachable     = 0,   // 无连接
     AFNetworkReachabilityStatusReachableViaWWAN = 1,   // 3G 花钱
     AFNetworkReachabilityStatusReachableViaWiFi = 2,   // 局域网络,不花钱
     */
    [[AFNetworkReachabilityManager sharedManager] startMonitoring];
    [[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) {
        debugLog(@&quot;%ld&quot;,(long)status);
    }];
</code></pre>

<p>根据当前网络状态会输出所对应的状态数值。</p>

<h2 id="toc_3">下载</h2>

<pre><code class="language-objc">    //session的默认配置
    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
    //根据配置创建管理者
    AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];
    NSURL *url = [NSURL URLWithString:@&quot;http://smartdsp.xmu.edu.cn/memberpdf/fuxueyang/cvpr2017/cvpr2017.pdf&quot;];
    //根据url创建请求对象
    NSURLRequest *request = [NSURLRequest requestWithURL:url];
    //创建下载任务
    NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {
        //设置下载路径
        NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil];
        //返回文件存放在本地的地址
        return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];
    } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) {
        //下载完成后调用方法
        debugLog(@&quot;File download to:%@ , %@&quot;,filePath,error);
    }];
    //开始下载任务
    [downloadTask resume];
</code></pre>

<h2 id="toc_4">get请求</h2>

<pre><code class="language-objc">    NSString *urlString = @&quot;https://www.weifar.com/api/ExamQuestion/id&quot;;
    NSDictionary *parameters = @{@&quot;id&quot;:@6};
    AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];
    //根据上述参数和请求地址来发送请求
    [manager GET:urlString parameters:parameters progress:^(NSProgress * _Nonnull downloadProgress) {
        debugLog(@&quot;%@&quot;,downloadProgress);
    } success:^(NSURLSessionDataTask * _Nonnull task, id  _Nullable responseObject) {
        //成功获取数据后，进行处理
        if (responseObject) {
            NSArray *a = responseObject[@&quot;Questions&quot;];
            NSDictionary *dic = a[0];
            NSString *str = dic[@&quot;BlockDescription&quot;];
            debugLog(@&quot;%@&quot;,str);
        }
    } failure:^(NSURLSessionDataTask * _Nullable task, NSError * _Nonnull error) {
        //请求失败，打印错误
        debugLog(@&quot;%@&quot;,error);
    }];
</code></pre>

<h2 id="toc_5">总结</h2>

<p>以上就是<code>AFNetworking</code>的基本使用，还有其他的一些功能由于没有合适的接口可以进行操作，暂且先搁置下。具体的操作可以参考官方的<code>AFNetworking</code><a href="http://cocoadocs.org/docsets/AFNetworking/3.1.0/index.html">API文档</a>,</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[FMDB的使用方法]]></title>
    <link href="https://lockxmonk.github.io/15109022752813.html"/>
    <updated>2017-11-17T15:04:35+08:00</updated>
    <id>https://lockxmonk.github.io/15109022752813.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">FMDB简介</a>
</li>
<li>
<a href="#toc_1">使用方法</a>
<ul>
<li>
<a href="#toc_2">引入相关文件</a>
</li>
<li>
<a href="#toc_3">建立数据库</a>
</li>
<li>
<a href="#toc_4">打开数据库</a>
</li>
<li>
<a href="#toc_5">执行更新（update）操作</a>
</li>
<li>
<a href="#toc_6">执行查询操作</a>
</li>
<li>
<a href="#toc_7">数据参数</a>
</li>
<li>
<a href="#toc_8">线程安全</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_9">总结</a>


<p>最近再看其它大牛写的项目代码，发现许多用到了<code>FMDB</code>，所以去了解了一下。</p>

<h2 id="toc_0">FMDB简介</h2>

<p>FMDB是一个第三方的开源库，我们可以通过<code>cocopods</code>搜索并整合到项目里面，FMDB其实就是对<code>SQLite</code>的<code>API</code>进行了封装，加上了面向对象的思想，让我们不必使用繁琐的<code>C</code>语言<code>API</code>函数，比起直接操作<code>SQLite</code>更加方便。</p>

<p>并且<code>FMDB</code> 同时兼容 <code>ARC</code> 和非 <code>ARC</code> 工程，会自动根据工程配置来调整相关的内存管理代码。</p>

<h2 id="toc_1">使用方法</h2>

<p>本文使用方法，均参考<code>FMDB</code>的<code>github</code>项目文档<a href="https://github.com/ccgus/fmdb">https://github.com/ccgus/fmdb</a></p>

<h3 id="toc_2">引入相关文件</h3>

<p>因为是对<code>sqlite</code>的封装所以我们在项目中需要引入它的库。<br/>
<img src="media/15109022752813/15109026776351.jpg" alt=""/></p>

<p>之后在文件中导入它的头文件：</p>

<pre><code class="language-objc">#import &quot;FMDB.h&quot;
</code></pre>

<h3 id="toc_3">建立数据库</h3>

<p>建立数据库只有简单的一句代码，如果当前路径不存在所需的数据库则会自动创建，若存在则会获取到。当路径为字符（<code>@“”</code>）时，一个空的数据库将被创建在临时的位置，数据库关闭时候将被自动删除。路径为<code>NULL</code>时空数据库会被放在内存中，关闭时也将自动被删除。具体信息可以参见：<a href="http://www.sqlite.org/inmemorydb.html">http://www.sqlite.org/inmemorydb.html</a></p>

<pre><code class="language-objc">#define PATH_OF_DOCUMENT    [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0]

_path = [PATH_OF_DOCUMENT stringByAppendingPathComponent:@&quot;test.db&quot;];
//创建数据库
FMDatabase *db = [FMDatabase databaseWithPath:_path];
</code></pre>

<h3 id="toc_4">打开数据库</h3>

<p>在对数据库进行交互时，必须要先打开它。如果打开失败，可能是权限不足或者资源不足。</p>

<pre><code class="language-objc">if (![db open]) {
    // [db release];   // uncomment this line in manual referencing code; in ARC, this is not necessary/permitted
    db = nil;
    return;
}
</code></pre>

<h3 id="toc_5">执行更新（update）操作</h3>

<p>FMDB中除了<code>select</code>为查询（<code>query</code>）以为都为更新操作。</p>

<p>例如我们执行一个<strong>插入</strong>操作的完整步骤为：</p>

<pre><code class="language-objc">    static int idx = 1;
    FMDatabase *db = [FMDatabase databaseWithPath:_path];
    if ([db open]) {
        NSString * sql = @&quot;insert into User (name, password) values(?, ?) &quot;;
        NSString *name = [NSString stringWithFormat:@&quot;lzh%d&quot;,idx++];
        BOOL result = [db executeUpdate:sql,name,@&quot;op&quot;];
        if (!result) {
            debugLog(@&quot;error to insert data&quot;);
        }else{
            debugLog(@&quot;succ to insert data&quot;);
        }
        [db close];
    }
</code></pre>

<p><strong>查询</strong>操作：</p>

<pre><code class="language-objc">    FMDatabase *db = [FMDatabase databaseWithPath:_path];
    if ([db open]) {
        NSString *sql =@&quot;select * from User&quot;;
        FMResultSet *result = [db executeQuery:sql];
        while ([result next]) {
            int userId = [result intForColumn:@&quot;id&quot;];
            NSString *name = [result stringForColumn:@&quot;name&quot;];
            NSString *pass = [result stringForColumn:@&quot;password&quot;];
            debugLog(@&quot;user id = %d, name = %@, pass = %@&quot;, userId, name, pass);
        }
        [db close];
    }
</code></pre>

<p><strong>删除</strong>操作：</p>

<pre><code class="language-objc">    static int idx = 1;
    FMDatabase *db =[FMDatabase databaseWithPath:_path];
    if ([db open]) {
        NSString *sql = @&quot;delete from User where id = ?&quot;;
        BOOL result = [db executeUpdate:sql , @(idx++)];
        if (!result) {
            debugLog(@&quot;error to delete db data&quot;);
        } else {
            debugLog(@&quot;succ to deleta db data&quot;);
        }
        [db close];
    }
</code></pre>

<p>我们可以看到执行<code>sql</code>语句的时候用的都是<code>executeUpdate：</code>方法。</p>

<h3 id="toc_6">执行查询操作</h3>

<p>查询操作与上面的有点区别，我们需要用<code>FMResultSet</code>来存储我们的查询结果，并调用它的<code>next：</code>方法来对数据进行逐行操作：</p>

<pre><code class="language-objc">    FMDatabase *db = [FMDatabase databaseWithPath:_path];
    if ([db open]) {
        NSString *sql =@&quot;select * from User&quot;;
        FMResultSet *result = [db executeQuery:sql];
        while ([result next]) {
            int userId = [result intForColumn:@&quot;id&quot;];
            NSString *name = [result stringForColumn:@&quot;name&quot;];
            NSString *pass = [result stringForColumn:@&quot;password&quot;];
            debugLog(@&quot;user id = %d, name = %@, pass = %@&quot;, userId, name, pass);
        }
        [db close];
    }
</code></pre>

<p>上面代码可以发现执行<code>sql</code>语句变为<code>executeQuery:</code>方法，该方法会将结果返回为<code>FMResultSet</code>类型，之后我们需要调用<code>stringForColumn:</code>对结果进行解析。<br/>
<code>FMDB</code>提供如下多个方法来获取不同类型的数据：</p>

<pre><code class="language-objc">intForColumn:
longForColumn:
longLongIntForColumn:
boolForColumn:
doubleForColumn:
stringForColumn:
dateForColumn:
dataForColumn:
dataNoCopyForColumn:
UTF8StringForColumn:
objectForColumn:
</code></pre>

<p>也可以按照列的索引对数据进行获取，<code>{type}ForColumnIndex:</code></p>

<h3 id="toc_7">数据参数</h3>

<p>我们可以在<code>sql</code>语句中，用<code>？</code>表示执行语句的参数，然后在 <code>executeUpdate：</code>方法来将<code>?</code>所指代的具体参数传入，例如上面的代码：</p>

<pre><code class="language-objc">    NSString * sql = @&quot;insert into User (name, password) values(?, ?) &quot;;
    NSString *name = [NSString stringWithFormat:@&quot;lzh%d&quot;,idx++];
    BOOL result = [db executeUpdate:sql,name,@&quot;op&quot;];
</code></pre>

<h3 id="toc_8">线程安全</h3>

<p><code>FMDatabase</code>这个类是线程不安全的，如果在多个线程同时使用一个<code>FMDatabase</code>实例，会造成数据混乱问题。所以，提供了一个<code>FMDatabaseQueue</code>并且使用它来对多个线程间进行交互，<code>FMDatabaseQueue</code>对象将通过接入多个线程进行同步和整合。</p>

<p>使用的方法也很简单：</p>

<p>首先创建一个数据库<code>path</code>来初始化<code>FMDatabaseQueue</code>，然后就可以将一个闭包 (block) 传入 <code>inDatabase</code> 方法中。</p>

<pre><code class="language-objc">
FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:aPath];

[queue inDatabase:^(FMDatabase *db) {
    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @1];
    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @2];
    [db executeUpdate:@&quot;INSERT INTO myTable VALUES (?)&quot;, @3];

    FMResultSet *rs = [db executeQuery:@&quot;select * from foo&quot;];
    while ([rs next]) {
        …
    }
}];
</code></pre>

<p>按照上面的方法我们可以创建多个线程来异步的对数据库进行操作：</p>

<pre><code class="language-objc">FMDatabaseQueue *queue = [FMDatabaseQueue databaseQueueWithPath:_path];
    dispatch_queue_t q1 = dispatch_queue_create(&quot;queue1&quot;, NULL);
    dispatch_queue_t q2 = dispatch_queue_create(&quot;queue2&quot;, NULL);
    
    dispatch_async(q1, ^{
        for (int i =1; i&lt;100; ++i) {
            [queue inDatabase:^(FMDatabase *db){
                NSString *sql = @&quot;insert into User (name, password) values(?, ?)&quot;;
                NSString *name = [NSString stringWithFormat:@&quot;queue1 %d&quot;, i];
                BOOL result = [db executeUpdate:sql,name,@&quot;opop&quot;];
                if (!result) {
                    debugLog(@&quot;error to add db data: %@&quot;, name);
                } else {
                    debugLog(@&quot;succ to add db data: %@&quot;, name);
                }
            }];
        }
    });
    dispatch_async(q2,^{
        for (int i = 0; i &lt; 100; ++i) {
            [queue inDatabase:^(FMDatabase *db) {
                NSString * sql = @&quot;insert into user (name, password) values(?, ?) &quot;;
                NSString * name = [NSString stringWithFormat:@&quot;queue2 %d&quot;, i];
                BOOL result = [db executeUpdate:sql, name, @&quot;opop22&quot;];
                if (!result) {
                    debugLog(@&quot;error to add db data: %@&quot;, name);
                } else {
                    debugLog(@&quot;succ to add db data: %@&quot;, name);
                }
            }];
        }
    });
</code></pre>

<p>执行后可以发现数据库中的部分表数据如下：<br/>
<img src="media/15109022752813/15109055831966.jpg" alt=""/></p>

<p>两个线程可以异步执行互不干扰。</p>

<p>上面数据库的显示 使用的是<code>Navicat</code>，也有其它的数据库管理软件可以显示。</p>

<h1 id="toc_9">总结</h1>

<p><code>FMDB</code>是一个在<code>iOS</code>上简化<code>sqlite API</code>的第三方库，对<code>sqlite</code>进行了很有好的封装，便于维护与增加效率。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[贪心算法（构造霍夫曼树）]]></title>
    <link href="https://lockxmonk.github.io/15097619961308.html"/>
    <updated>2017-11-04T10:19:56+08:00</updated>
    <id>https://lockxmonk.github.io/15097619961308.html</id>
    <content type="html"><![CDATA[
<p>霍夫曼树的构造是使用了变长编码来减少数据所占空间，一般我们只考虑<strong>前缀码</strong>，即没有任何码字是其它码字的前缀。</p>

<p>我们的构造过程如下所示：</p>

<p><img src="media/15097619961308/15097621720916.jpg" alt=""/></p>

<p>这里我们根据上述表示，我们每次总是“贪心”的选择两个最小的值来求和，并插入队列中。所以我们可以构造一个最小优先队列来存储各字母的频率。算法代码如下：</p>

<pre><code class="language-c++">//
//  main.cpp
//  HUFFMAN
//
//  Created by LZH on 2017/11/4.
//  Copyright © 2017年 LZH. All rights reserved.
//

#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;vector&gt;
using namespace std;

typedef struct BitNode
{
    int frep;
    struct BitNode *left;
    struct BitNode *right;
}Node;

//定义比较结构
struct cmp1{
    bool operator ()(int &amp;a,int &amp;b){
        return a&gt;b;//最小值优先
    }
};
//构造霍夫曼树
void HUFFMAN(int c, priority_queue&lt;int, vector&lt;int&gt;, cmp1&gt; &amp;que1)
{
    int n = c;
    for (int i=0; i&lt;n-1; i++) {
        Node *newNodeZ = (Node*)malloc(sizeof(Node));
        Node *newNodeX = (Node*)malloc(sizeof(Node));
        Node *newNodeY = (Node*)malloc(sizeof(Node));
        newNodeX-&gt;frep = que1.top();
        que1.pop();
        newNodeY-&gt;frep = que1.top();
        que1.pop();
        newNodeZ-&gt;left = newNodeX;
        newNodeZ-&gt;right = newNodeY;
        
        newNodeZ-&gt;frep =newNodeX-&gt;frep + newNodeY-&gt;frep;
        que1.push(newNodeZ-&gt;frep);
    }
}

int main() {
//    priority_queue&lt;int&gt; que; //构造优先队列
    int b[6] = {9,5,12,13,16,45};
//    vector&lt;int&gt; a(b,b+6);
    priority_queue&lt;int , vector&lt;int&gt;, cmp1 &gt;que1; //最小优先队列
    for (int i=0; i&lt;6; i++) {
        que1.push(b[i]);
    }
    HUFFMAN(6, que1);
    while (!que1.empty()) {
        cout&lt;&lt;que1.top()&lt;&lt;&#39; &#39;;
        que1.pop();
    }
    return 0;
}

</code></pre>

<p>最后输出为100，返回了编码树的根节点。<br/>
<img src="media/15097619961308/15097623765624.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[贪心算法（活动选择问题）]]></title>
    <link href="https://lockxmonk.github.io/15096800741665.html"/>
    <updated>2017-11-03T11:34:34+08:00</updated>
    <id>https://lockxmonk.github.io/15096800741665.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15096800741665/15096801101097.jpg" alt=""/></p>

<p>这个问题是一个典型的可以运用贪心算法的题目，我们在初始的选择一个活动之后，应该将之后的资源被其他任务尽量多的占用。所以我们应该第一个选择活动最快结束的活动，因为它剩下的资源可以被它之后开始的任务尽量多的使用。所以我们可以运用一种递归形式或者迭代算法来表达这个形式：</p>

<pre><code class="language-c++">//
//  main.cpp
//  Greedy_Activity_Selector
//
//  Created by LZH on 2017/11/3.
//  Copyright © 2017年 LZH. All rights reserved.
//

#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
void print(int n)
{
    cout&lt;&lt;n&lt;&lt;&#39; &#39;;
}

/**
 迭代形式函数

 @param s 活动开始时间数组
 @param f 活动结束时间数组
 @param result  用于存储结果
 */
void GREED_ACTIVITY_SELECTOR(vector&lt;int&gt; s , vector&lt;int&gt; f , vector&lt;int&gt; &amp;result)
{
    int n = s.size();
    result.push_back(1);
    int k=1;
    for (int m=2; m&lt;=n; m++) {
        if (s[m]&gt;=f[k]) {
            result.push_back(m);
            k = m;
        }
    }
}

/**
 尾递归形式函数

 @param s 活动开始时间数组
 @param f 活动结束时间数组
 @param k 从活动k开始计算
 @param n 共有n个活动
 @param result 用于存储结果
 */
void RECURSIVE_ACTIVITY_SELECTOR(vector&lt;int&gt; s,vector&lt;int&gt; f, int k, int n, vector&lt;int&gt; &amp;result)
{
    int m = k+1;
    while (m&lt;=n &amp;&amp; s[m]&lt;=f[k]) {
        m++;
    }
    if (m&lt;=n) {
        result.push_back(m);
        RECURSIVE_ACTIVITY_SELECTOR(s, f, m, n ,result);
    }
}

int main() {
    int a[12] ={0,1,3,0,5,3,5,6,8,8,2,12};
    int b[12] ={0,4,5,6,7,9,9,10,11,12,14,16};
    vector&lt;int&gt; s(a,a+12);
    vector&lt;int&gt; f(b,b+12);
    vector&lt;int&gt; result;
    RECURSIVE_ACTIVITY_SELECTOR(s, f, 0, 11, result);
    GREED_ACTIVITY_SELECTOR(s, f, result);
    for_each(result.begin(),result.end(),print);
    return 0;
}

</code></pre>

<p>其中递归形式的流程如下图所示：<br/>
<img src="media/15096800741665/15096804218816.jpg" alt=""/></p>

<p>但两种算法运行时间类似都为\(\Theta(n)\)</p>

<h2 id="toc_0">与动态规划的不同</h2>

<p>贪心算法通过做出局部最优来构造全局最优解。换句话说，直接做出在当前问题下看起来最优的选择，而不必考虑子问题的解。</p>

<p><strong><font color=red>在动态规划中，每个步骤都要进行一次选择，但选择通常依赖于子问题的解</font></strong>，因此，我们通常以自底向上的方式来求解动态规划问题，先求解较小的子问题，然后是较大的子问题。但是在贪心算法中，我们总是做出在当时看起来最佳的选择，然后求解剩下的唯一子问题。<strong><font color=red>贪心算法进行选择时可能依赖之前做出的选择，但不依赖于任何将来的选择或者是子问题的解。</font></strong>所以贪心算法在进行第一次选择时不求解任何子问题，自顶向下进行逐步选择，将给定的子问题实例变小。</p>

<p>两者最典型的区别，可以用<code>分数背包</code>和<code>0-1背包</code>问题来举例，这里不做细说。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见iOS面试题基础篇]]></title>
    <link href="https://lockxmonk.github.io/15090074391982.html"/>
    <updated>2017-10-26T16:43:59+08:00</updated>
    <id>https://lockxmonk.github.io/15090074391982.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[常见iOS面试题（智力题）]]></title>
    <link href="https://lockxmonk.github.io/15090066726855.html"/>
    <updated>2017-10-26T16:31:12+08:00</updated>
    <id>https://lockxmonk.github.io/15090066726855.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">智力题</a>
<ul>
<li>
<a href="#toc_1">四个人夜间要过一座桥，每人走路速度不一样，过桥需要时间分别是1，2，5，10分钟。现在只有一只手电筒在过桥时必须带，同时只能两人过，如何安排能够让四人最快速度过桥？</a>
</li>
<li>
<a href="#toc_2">有25匹马赛跑，每次只能跑5匹，最快能赛几次找出跑得最快的3匹马？</a>
</li>
<li>
<a href="#toc_3">如果你变成硬币那么小，然后被扔进一个搅拌机里，你将如何脱身？</a>
</li>
<li>
<a href="#toc_4">五个强盗抢到100个金币来分赃，强盗1提出分配方案，为了防止他分配不公，强盗们达成一致：他的方案必须有所有人（包括1号自己）的半数以上（注意，必须大于百分之五十）通过才可执行。否则，他将被杀死，再由2号强盗提出分配方案，2号的方案也要所有剩下的人（包括他自己）的半数以上通过。否则他也将被杀死，依次类推。假设这五个强盗都贪婪成性、残忍无比、绝顶聪明而又一诺千金，都想自己得到最多，都想看到别人死去而自己活。请问，1号强盗要怎样分配才能使自己活着而得到的黄金最多？为什么？</a>
</li>
</ul>
</li>
</ul>


<h2 id="toc_0">智力题</h2>

<h3 id="toc_1">四个人夜间要过一座桥，每人走路速度不一样，过桥需要时间分别是1，2，5，10分钟。现在只有一只手电筒在过桥时必须带，同时只能两人过，如何安排能够让四人最快速度过桥？</h3>

<pre><code class="language-c">答：1和2 先过。1返回，5和10先过，2返回，1和2一起过。一共时间=2+1+10+2+2=17分钟
</code></pre>

<h3 id="toc_2">有25匹马赛跑，每次只能跑5匹，最快能赛几次找出跑得最快的3匹马？</h3>

<pre><code class="language-c">答案是7次。

1. 首先将25匹马分成5组a、b、c、d、e进行比赛。比赛的次数就是5次。得到每组的第一名，分别编号a1,b1,c1,d1,e1。

2. 然后我们将每组的第一名进行比赛，得出结果。假设a1&gt;b1&gt;c1&gt;d1&gt;e1。（大于号表示a1比b1快，1表示第一名）。在这个地方我们可以推断出，a1是所有马中最快的，所以它是第一名。d1,e1不可能是前三的马，同时这两匹马所在的组也不可能是前三的马。所以排除这两组马，还剩三组15匹马。现在需要找出第二快和第三快的马。

3. 第二名和第三名的马在刚才的比赛中有以下几种分布情况：

　　全部在a组（最快的马所在的组），那么它是a2和a3.

　　全部在b组，那么它们就是b1和b2。

　　一匹在a组一匹在b组，那么它们是a2和b1.无论是第三名在a组还是第二名在a组都是这两匹。

　　一匹在a组一匹在c组，那么它们是a2和c1。

　　一匹在b组一匹在c组，那么它们是b1和c1。

　　所以我们把a2,a3,b1,b2,c1拿出来再进行一场比赛。取前两名就是最终的结果。
</code></pre>

<h3 id="toc_3">如果你变成硬币那么小，然后被扔进一个搅拌机里，你将如何脱身？</h3>

<pre><code class="language-c">这是Google的面试题，原题大概是：
你被缩小到一枚硬币大小，密度不变质量减小，被扔进一个搅拌机里，搅拌机60秒后开始转动，你会怎么办？

答案是：直接跳出来就可以了
</code></pre>

<h3 id="toc_4">五个强盗抢到100个金币来分赃，强盗1提出分配方案，为了防止他分配不公，强盗们达成一致：他的方案必须有所有人（包括1号自己）的半数以上（注意，必须大于百分之五十）通过才可执行。否则，他将被杀死，再由2号强盗提出分配方案，2号的方案也要所有剩下的人（包括他自己）的半数以上通过。否则他也将被杀死，依次类推。假设这五个强盗都贪婪成性、残忍无比、绝顶聪明而又一诺千金，都想自己得到最多，都想看到别人死去而自己活。请问，1号强盗要怎样分配才能使自己活着而得到的黄金最多？为什么？</h3>

<blockquote>
<p>显然，5号是最不合作的，因为他没有被扔下海的风险，从直觉上说，每扔下去一个，潜在的对手就少一个；4号正好相反，他生存的机会完全取决于前面还有人活着，因此此人似乎值得争取；3号对前两个的命运完全不同情，他只需要4号支持就可以了；2号则需要3票才能活，那么，你…… 　　思路对头，但是太笼统了，不要忘了我们的假设前提：每个人都十足理性，都不可能犯逻辑错误。所以，你应该按照严格的逻辑思维去推想他们的决定。让我们从后往前推理：5号不用说了，他的策略最简单：巴不得把所有人都送去喂鲨鱼(但要注意：这并不意味着他要对每个人投反对票，他也要考虑其他人方案通过的情况)。来看4号：如果1～3号强盗都喂了鲨鱼，只剩4号和5号的话，5号一定投反对票让4号喂鲨鱼，以独吞全部金币。所以，4号惟有支持3号才能保命。</p>

<p>3号知道这个策略，就会提(100，0，0)的分配方案，对4号、5号一毛不拔而将全部金币归为己有，因为他知道4号一无所获但还是会投赞成票，再加上自己一票他的方案即可通过。不过，2号推知到3号的方案，就会提出(98，0，l，1)的方案，即放弃3号，而给予4号和5号各1枚金币。由于该方案对于4号和5号来说比在3号分配时更为有利，他们将支持他而不希望他出局而由3号来分配。这样，2号将拿走98枚金币。不过，2号的方案会被l号所洞悉，l号并将提出(97，0，1，2，0)或(97，0，1，0，2)的方案，即放弃2号，而给3号1枚金币，同时给4号或5号2枚金币。由于l号的这一方案对于3号和4号(或5号)来说，相比2号分配时更优，他们将投l号的赞成票，再加上1号自己的票，1号的方案可获通过，97枚金币可轻松落入腰包。这无疑是1号能够获取最大收益的方案了！</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[最长公共子序列(动态规划)]]></title>
    <link href="https://lockxmonk.github.io/15088085969493.html"/>
    <updated>2017-10-24T09:29:56+08:00</updated>
    <id>https://lockxmonk.github.io/15088085969493.html</id>
    <content type="html"><![CDATA[
<p><strong>最长公共子序列问题（LCS）</strong>给定两个序列\(X=&lt;{x_1,x_2,...x_m}&gt;和Y=&lt;y_1,y_2,...y_n&gt;\),求X和Y长度最长的公共子序列。总共分三个步骤：</p>

<h2 id="toc_0">步骤一：刻画最长公共子序列的特征</h2>

<p><img src="media/15088085969493/15088091467243.jpg" alt=""/></p>

<h2 id="toc_1">步骤二：一个递归解</h2>

<p><img src="media/15088085969493/15088095444692.jpg" alt=""/></p>

<h2 id="toc_2">步骤三：计算LCS的长度</h2>

<p><img src="media/15088085969493/15088132625221.jpg" alt=""/></p>

<p>上述过程我们有如下图来表示：<br/>
<img src="media/15088085969493/15088133360817.jpg" alt=""/></p>

<h2 id="toc_3">步骤4 构造LCS</h2>

<p><img src="media/15088085969493/15088133035826.jpg" alt=""/></p>

<p>这里我们用C++来构造这个算法：</p>

<pre><code class="language-c++">//
//  main.cpp
//
//  Created by LZH on 2017/10/30.
//  Copyright © 2017年 梁中豪. All rights reserved.
//


#include &lt;iostream&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
using namespace std;

//计算LCS的长度
void LCS_LENGTH(char *X ,char *Y ,int **b ,int **c ,int &amp;m ,int &amp;n)
{
    //    int m = sizeof(X)/sizeof(char);
    //    int n = sizeof(Y)/sizeof(char);
    
    //    int b[m][n];
    //    int c[m][n];
    
    for (int i=1; i&lt;m; i++) {
        for (int j=1; j&lt;n; j++) {
            if (X[i]==Y[j]) {
                c[i][j] = c[i-1][j-1]+1;
                b[i][j] = 1;
            }
            else if (c[i-1][j]&gt;=c[i][j-1])
            {
                c[i][j] = c[i-1][j];
                b[i][j] = 2;
            }
            else
            {
                c[i][j] = c[i][j-1];
                b[i][j] = 3;
            }
        }
    }
}

void PRINT_LCS(int **b,char *X,int i,int j)
{
    if (i==0 || j==0) {
        return;
    }
    if (b[i][j]==1) {
        PRINT_LCS(b, X, i-1, j-1);
        cout &lt;&lt; X[i] &lt;&lt;endl;
    }
    else if (b[i][j]==2)
    {
        PRINT_LCS(b, X, i-1, j);
    }
    else
    {
        PRINT_LCS(b, X, i, j-1);
    }
}

int main()
{
    char X[8] = {&#39;x&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;B&#39;,&#39;D&#39;,&#39;A&#39;,&#39;B&#39;};
    char Y[7] = {&#39;y&#39;,&#39;B&#39;,&#39;D&#39;,&#39;C&#39;,&#39;A&#39;,&#39;B&#39;,&#39;A&#39;};
    int m = sizeof(X)/sizeof(char);
    int n = sizeof(Y)/sizeof(char);
    int **b =new int*[m];
    for (int i = 0; i&lt;m; i++) {
        b[i] = new int[n];
    }
    
    int **c = new int*[m];
    for (int i = 0; i&lt;m; i++) {
        c[i] = new int[n];
    }
    LCS_LENGTH(X,Y,b,c,m,n);
    PRINT_LCS(b,X,m-1,n-1);
    return 0;
}

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动态规划]]></title>
    <link href="https://lockxmonk.github.io/15087194946164.html"/>
    <updated>2017-10-23T08:44:54+08:00</updated>
    <id>https://lockxmonk.github.io/15087194946164.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">钢条切割问题</a>
<ul>
<li>
<a href="#toc_1">分治法</a>
</li>
<li>
<a href="#toc_2">动态规划</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_3">总结</a>


<p>动态规划与分治法很类似，都是通过组合子问题的解来求解原问题。但是不同的是动态规划应用于子问题重叠的情况,即不同的子问题也具有公共的子子问题。分治法在这种情况下，会反复的求解那些公共子子问题。而动态规划算法对每个子子问题只求解一遍，将其保存在一个表格中，避免每次都计算。</p>

<h2 id="toc_0">钢条切割问题</h2>

<p>我们第一个动态规划问题是钢条切割问题。<br/>
<img src="media/15087194946164/15087197999988.jpg" alt=""/></p>

<h3 id="toc_1">分治法</h3>

<p>我们来先看一下简答的分治法：</p>

<pre><code class="language-objc">//
//  main.m
//  CUT-ROD

#import &lt;Foundation/Foundation.h&gt;

@interface CUT_ROD:NSObject;

-(NSInteger)CUT_ROD:(NSArray*)P length:(NSInteger)n;

@end

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        NSArray *c = @[@1,@5,@8,@9,@10,@17,@17,@20,@24,@30];
        CUT_ROD *a = [CUT_ROD new];
        NSInteger result = [a CUT_ROD:c length:10];
        NSLog(@&quot;result is %ld&quot;,result);
    }
    return 0;
}

@implementation CUT_ROD
//简单的分治法,会重复计算子子结果
-(NSInteger)CUT_ROD:(NSArray *)P length:(NSInteger)n{
    if (n==0) {
        return 0;
    }
    NSInteger q = -1;
    for (NSInteger i=0; i&lt;n; i++) {
        q = q&gt;([P[i] integerValue]+[self CUT_ROD:P length:n-i-1]) ? q:([P[i] integerValue]+[self CUT_ROD:P length:n-i-1]);
    }
    return q;
}

@end

</code></pre>

<p>上述代码使用递归来实现的，但是每次都要递归的重复来计算相同的子子问题，如图所示：<br/>
<img src="media/15087194946164/15087246470673.jpg" alt=""/></p>

<p>所以我们就在想，只要把求解得到的子子问题答案记录下，等到下次要用的时候直接调用它，就可以省下大量的时间。所以我们下面采用动态规划来写一遍。</p>

<h3 id="toc_2">动态规划</h3>

<p><strong><font color=red>动态规划是一个典型的时空权衡的例子，付出额外的内存空间来降低计算时间。</font></strong></p>

<p>第一种方法：带备忘的自顶向下算法</p>

<pre><code class="language-objc">//动态规划 带备忘的自顶向下
-(NSInteger)MEMOIZED_CUT_ROD:(NSArray *)P length:(NSInteger)n{
    NSMutableArray *logArr =[[NSMutableArray alloc] initWithCapacity:11];
    for (int i = 0; i&lt;=10; i++) {
        [logArr addObject:@(-1)];
    }
    return [self MEMOIZED_CUT_ROD_AUX:P length:n log:logArr];
}
-(NSInteger)MEMOIZED_CUT_ROD_AUX:(NSArray*)p length:(NSInteger)n log:(NSMutableArray*)r{
    NSInteger q;
    if ([r[n] integerValue]&gt;=0) {
        return [r[n] integerValue];
    }
    if (n==0) {
        q = 0;
    }else{
        q = -1;
        for (NSInteger i = 0; i&lt;n; i++) {
            q = q&gt;[p[i] integerValue] + [self MEMOIZED_CUT_ROD_AUX:p length:n-i-1 log:r] ? q : [p[i] integerValue] + [self MEMOIZED_CUT_ROD_AUX:p length:n-i-1 log:r];
        }
    }
    [r replaceObjectAtIndex:n withObject:@(q)];
    return q;
}
</code></pre>

<p><code>MEMOIZED_CUT_ROD</code>方法引入<code>r</code>数组，记录每个长度的最优收益值，下面的方法将记录的值存入<code>r</code>数组中，并调用存入<code>r</code>的子子问题所得到收益值。</p>

<p>第二个方法，字底向上版本，这个版本更为简单：</p>

<pre><code class="language-objc">-(NSInteger)BOTTOM_UP_CUT_ROD:(NSArray *)P length:(NSInteger)n{
    NSMutableArray *arrLog = [[NSMutableArray alloc] initWithCapacity:11];
    for (int i = 0; i&lt;=10; i++) {
        [arrLog addObject:@(0)];
    }
    NSInteger q = -1;
    for (int j=0; j&lt;n; j++) {
        q = -1;
        for (int i=0; i&lt;=j; i++) {
            NSLog(@&quot;%li&quot;,q);
            q = q &gt; ([P[i] integerValue] + [arrLog[j-i] integerValue]) ? q : ([P[i] integerValue] + [arrLog[j-i] integerValue]);
            NSLog(@&quot;%li&quot;,q);
        }
        [arrLog replaceObjectAtIndex:j+1 withObject:@(q)];
    }
    return [arrLog[n] integerValue];
}
</code></pre>

<p>依次来求解长度从1到n的最大收益。</p>

<h1 id="toc_3">总结</h1>

<p>当我们思考一个动态规划的问题时，最好弄清涉及的子问题与他们的依赖关系。如上图的依赖图为：<br/>
<img src="media/15087194946164/15087412491634.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用RAC的基本操作]]></title>
    <link href="https://lockxmonk.github.io/15083737124086.html"/>
    <updated>2017-10-19T08:41:52+08:00</updated>
    <id>https://lockxmonk.github.io/15083737124086.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">开始</a>
<ul>
<li>
<a href="#toc_1">类型转换</a>
</li>
<li>
<a href="#toc_2">创建有效的状态信号</a>
</li>
<li>
<a href="#toc_3">聚合信号</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">响应式的登录</a>
<ul>
<li>
<a href="#toc_5">创建信号</a>
</li>
<li>
<a href="#toc_6">添加附加操作（Adding side-effects）</a>
</li>
</ul>
</li>
</ul>


<p>作为一个iOS开发者，你写的每一行代码几乎都是在相应某个事件，例如按钮的点击，收到网络消息，属性的变化（通过KVO）或者用户位置的变化（通过CoreLocation）。但是这些事件都用不同的方式来处理，比如action、delegate、KVO、callback等。<code>ReactiveCocoa</code>为事件定义了一个标准接口，从而可以使用一些基本工具来更容易的连接、过滤和组合。</p>

<p>这里我们来创建一个简单的登录功能界面，当输入的<code>name</code>与<code>password</code>符合我们的预期就输出<code>success</code>。</p>

<h2 id="toc_0">开始</h2>

<p>首先我们创建一个工程起名为<code>FirstRAC</code>，并在里面创建<code>podfile</code>文件：</p>

<pre><code class="language-objc">source &#39;https://github.com/CocoaPods/Specs.git&#39;

platform :ios, ‘8.0’
use_frameworks!

target &#39;FirstRAC’ do

    pod &#39;Masonry&#39;
    pod &#39;ReactiveObjC&#39;, &#39;~&gt; 3.0.0&#39;

end
</code></pre>

<p>首先我们创建一个<code>button</code>，两个<code>Label</code>和<code>textField</code>如下图所示：<br/>
<img src="media/15083737124086/15083741205915.jpg" alt=""/></p>

<p>这里我们的界面布局使用<code>Masonry</code>来进行约束。</p>

<p>界面元素的属性声明为：</p>

<pre><code class="language-objc">@property(nonatomic,strong) UIView *login;
@property(nonatomic,strong) UILabel *nameLabel;
@property(nonatomic,strong) UILabel *passLabel;
@property(nonatomic,strong) UITextField *name;
@property(nonatomic,strong) UITextField *pass;
@property(nonatomic,strong) UIButton *sign;
</code></pre>

<p>元素的约束以及创建为：</p>

<pre><code class="language-objc">self.login = [[UIView alloc] initWithFrame:CGRectZero];
    
    _name = [[UITextField alloc] init];
    _name.borderStyle = UIFontWeightBold;
    _name.font = [UIFont systemFontOfSize:15];
    _name.placeholder = @&quot;Enter Name&quot;;
    [_login addSubview:_name];
    
    _pass = [[UITextField alloc] init];
    _pass.borderStyle = UIFontWeightBold;
    _pass.font = [UIFont systemFontOfSize:15];
    _pass.placeholder = @&quot;Enter Pass&quot;;
    [_login addSubview:_pass];
    
    _nameLabel = [[UILabel alloc] init];
    _nameLabel.backgroundColor = UIColor.whiteColor;
    _nameLabel.font = [UIFont systemFontOfSize:14.0];
    _nameLabel.lineBreakMode = NSLineBreakByTruncatingTail;
    _nameLabel.text = @&quot;Name&quot;;
    [_login addSubview:_nameLabel];
    
    _passLabel = [[UILabel alloc] init];
    _passLabel.backgroundColor = UIColor.whiteColor;
    _passLabel.font = [UIFont systemFontOfSize:14.0];
    _passLabel.lineBreakMode = NSLineBreakByTruncatingTail;
    _passLabel.text = @&quot;Pass&quot;;
    [_login addSubview:_passLabel];
    
    _sign = [UIButton buttonWithType:UIButtonTypeRoundedRect];
    _sign.layer.borderWidth = 3;
//    _sign.layer.borderColor = [UIColor blueColor].CGColor;
    _sign.titleLabel.textColor = [UIColor redColor];
//    _sign.backgroundColor = [UIColor greenColor];
    [_sign setTitle:@&quot;Sign&quot; forState:UIControlStateNormal];
    [_sign setTitle:@&quot;Push&quot; forState:UIControlStateHighlighted];
    [_sign setTitleColor:UIColor.blackColor forState:UIControlStateNormal];
    _sign.showsTouchWhenHighlighted = YES;
//    [_sign addTarget:self action:@selector(buttonClick:) forControlEvents:UIControlEventTouchUpInside];
    [_login addSubview:_sign];
    [self.view addSubview:_login];

    [_login mas_makeConstraints:^(MASConstraintMaker *make){
        make.left.right.and.bottom.equalTo(self.view);
        make.top.equalTo(self.mas_topLayoutGuide).offset(@50);
    }];
    [_nameLabel mas_makeConstraints:^(MASConstraintMaker *make){
        make.top.equalTo(_login.top);
        make.height.equalTo(@20);
        make.left.equalTo(_login.left).with.offset(20);
    }];
    [_passLabel mas_makeConstraints:^(MASConstraintMaker *make){
        make.top.equalTo(_nameLabel.bottom).with.offset(10);
        make.centerX.equalTo(_nameLabel.centerX);
        make.height.equalTo(@20);
    }];
    [_name mas_makeConstraints:^(MASConstraintMaker *make){
        make.left.equalTo(_nameLabel.right).with.offset(5);
        make.centerY.equalTo(_nameLabel.centerY);
        make.height.equalTo(@20);
    }];
    [_pass mas_makeConstraints:^(MASConstraintMaker *make){
        make.left.equalTo(_passLabel.right).with.offset(5);
        make.centerY.equalTo(_passLabel.centerY);
        make.height.equalTo(@20);
    }];
    [_sign mas_makeConstraints:^(MASConstraintMaker *make){
        make.height.equalTo(@50);
        make.width.equalTo(@100);
        make.top.equalTo(_pass.bottom).offset(@50);
        make.centerX.equalTo(self.view.centerX);
    }];

</code></pre>

<p>之后我们运用<code>RAC</code>为界面的元素添加各种事件，首先我们可以简单的为<code>name</code>的<code>textField</code>来订阅事件：</p>

<pre><code class="language-objc">[[self.name.rac_textSignal
     filter:^BOOL(id value){
         NSString *text = value;
         return text.length&gt;3;
     }]
     subscribeNext:^(id x){
        NSLog(@&quot;%@&quot;,x);
    }];
</code></pre>

<p>该事件对输入的文本进行过滤，将输入文本的长度大于3的文本转化成信号，传递给下一个订阅事件；下一个订阅者输出文本内容。</p>

<p><font color=red>RACSignal有很多方法可以来订阅不同的事件类型。每个方法都需要至少一个block，当事件发生时就会执行block中的逻辑。在上面的例子中可以看到每次next事件发生时，<br/>
subscribeNext:方法提供的block都会执行。<br/><br/>
ReactiveCocoa框架使用category来为很多基本UIKit控件添加signal。这样你就能给控件添加订阅了，text field的<code>rac_textSignal</code>就是这么来的。</font></p>

<h3 id="toc_1">类型转换</h3>

<p>我们运行下面代码就会发现：</p>

<pre><code class="language-objc">[[[self.pass.rac_textSignal
       map:^id(NSString *text){
           return @(text.length);
       }]
      filter:^BOOL(NSNumber *length){
          return [length integerValue]&gt;3;
      }]
     subscribeNext:^(id x){
         NSLog(@&quot;%@&quot;,x);
     }];
</code></pre>

<p>编译运行，你会发现<code>log</code>输出变成了文本的长度而不是内容。这是因为：<font color=red>新加的map操作通过block改变了事件的数据。map从上一个next事件接收数据，通过执行block把返回值传给下一个next事件。在上面的代码中，map以NSString为输入，取字符串的长度，返回一个NSNumber。</font></p>

<p>如下图所示：<br/>
<img src="media/15083737124086/15083747539689.png" alt=""/></p>

<p>能看到<code>map</code>操作之后的步骤收到的都是<code>NSNumber</code>实例。你可以使用<code>map</code>操作来把接收的数据转换成想要的类型，只要它是个对象。</p>

<h3 id="toc_2">创建有效的状态信号</h3>

<p>首先我们创建两个信号;</p>

<pre><code class="language-objc">RACSignal *validUsernameSignal =[self.name.rac_textSignal
                                     map:^id(NSString *text){
                                         return @([self isValidUsername:text]);
                                     }];
RACSignal *validPasswordSignal = [self.pass.rac_textSignal
                                      map:^id(NSString *text){
                                          return @([self isValidPassword:text]);
                                      }];

- (BOOL)isValidUsername:(NSString *)username {
    return username.length &gt; 3;
}

- (BOOL)isValidPassword:(NSString *)password {
    return password.length &gt; 3;
}
</code></pre>

<p>可以看到，上面的代码对每个输入框的<code>rac_textSignal</code>应用了一个map转换。输出是一个用<code>NSNumber</code>封装的布尔值。</p>

<p>下一步是转换这些信号，从而能为输入框设置不同的背景颜色。基本上就是，你订阅这些信号，然后用接收到的值来更新输入框的背景颜色。下面有一种方法很方便：</p>

<pre><code class="language-objc">    RAC(self.name , backgroundColor) = [validUsernameSignal
                                        map:^id(NSNumber *nameValid){
                                            return [nameValid boolValue] ? [UIColor clearColor]:[UIColor yellowColor];
                                        }];
    RAC(self.pass , backgroundColor) = [validPasswordSignal
                                        map:^id(NSNumber *nameValid){
                                            return [nameValid boolValue] ? [UIColor clearColor]:[UIColor yellowColor];
                                        }];
</code></pre>

<p><strong><font color=red>RAC宏允许直接把信号的输出应用到对象的属性上。RAC宏有两个参数，第一个是需要设置属性值的对象，第二个是属性名。每次信号产生一个next事件，传递过来的值都会应用到该属性上。</font></strong></p>

<p><img src="media/15083737124086/15083750523260.png" alt=""/></p>

<h3 id="toc_3">聚合信号</h3>

<p>目前在应用中，登录按钮只有当用户名和密码输入框的输入都有效时才工作。现在要把这里改成响应式的。</p>

<p>现在的代码中已经有可以产生用户名和密码输入框是否有效的信号了——<code>validUsernameSignal</code>和<code>validPasswordSignal</code>了。现在需要做的就是聚合这两个信号来决定登录按钮是否可用。</p>

<p>把下面的代码添加到<code>viewDidLoad</code>的末尾：</p>

<pre><code class="language-objc">RACSignal *signUpActiveSignal = [RACSignal combineLatest:@[validUsernameSignal,validPasswordSignal] reduce:^id(NSNumber *usernameValid, NSNumber *passwordValid){
        return @([usernameValid boolValue]&amp;&amp;[passwordValid boolValue]);
    }];
</code></pre>

<p><strong><font color=red>上面的代码使用combineLatest:reduce:方法把validUsernameSignal和validPasswordSignal产生的最新的值聚合在一起，并生成一个新的信号。每次这两个源信号的任何一个产生新值时，reduce block都会执行，block的返回值会发给下一个信号。</font></strong></p>

<p><em>注意：RACsignal的这个方法可以聚合任意数量的信号，reduce block的参数和每个源信号相关。ReactiveCocoa有一个工具类RACBlockTrampoline，它在内部处理reduce block的可变参数。实际上在ReactiveCocoa的实现中有很多隐藏的技巧，值得你去看看。</em></p>

<p>现在我们的逻辑变为：<img src="media/15083737124086/15083753306027.png" alt=""/></p>

<p>上图展示了一些重要的概念，你可以使用<code>ReactiveCocoa</code>来完成一些重量级的任务。   </p>

<ul>
<li><p>分割——信号可以有很多<code>subscriber</code>，也就是作为很多后续步骤的源。注意上图中那个用来表示用户名和密码有效性的布尔信号，它被分割成多个，用于不同的地方。</p></li>
<li><p>聚合——多个信号可以聚合成一个新的信号，在上面的例子中，两个布尔信号聚合成了一个。实际上你可以聚合并产生任何类型的信号。</p></li>
</ul>

<p><strong><mark>这些改动的结果就是，代码中没有用来表示两个输入框有效状态的私有属性了。这就是用响应式编程的一个关键区别，你不需要使用实例变量来追踪瞬时状态。</mark></strong></p>

<h2 id="toc_4">响应式的登录</h2>

<p>应用目前使用上面图中展示的响应式管道来管理输入框和按钮的状态。但是按钮按下的处理用的还是<code>action</code>，所以下一步就是把剩下的逻辑都替换成响应式的。</p>

<p>你已经知道了<code>ReactiveCocoa</code>框架是如何给基本<code>UIKit</code>控件添加属性和方法的了。目前你已经使用了<code>rac_textSignal</code>，它会在文本发生变化时产生信号。为了处理按钮的事件，现在需要用到<code>ReactiveCocoa</code>为<code>UIKit</code>添加的另一个方法，<mark><code>rac_signalForControlEvents</code></mark>。</p>

<p>现在回到<code>ViewController.m</code>中，把下面的代码添加到<code>viewDidLoad</code>的末尾：</p>

<pre><code class="language-objc">[[self.signInButton
   rac_signalForControlEvents:UIControlEventTouchUpInside]
   subscribeNext:^(id x) {
     NSLog(@&quot;button clicked&quot;);
   }];
</code></pre>

<p>上面的代码从按钮的<code>UIControlEventTouchUpInside</code>事件创建了一个信号，然后添加了一个订阅，在每次事件发生时都会输出<code>log</code>。<br/>
你就会发现每次点击按钮后，就会响应输出事件，输出<code>button clicked</code>。</p>

<p>现在按钮有了点击事件的信号，下一步就是把它和登录流程连接起来。。那么问题就来了，打开<code>RWSignInService.h</code>，看一下接口：</p>

<pre><code class="language-objc">//RWSignInService.h
#import &lt;Foundation/Foundation.h&gt;

typedef void (^RWSignInResponse)(BOOL);

@interface RWSignInService : NSObject
- (void)signInWithUsername:(NSString *)username
                 password:(NSString *)password
                 complete:(RWSignInResponse)completeBlock;
@end

//RWSignInService.m
#import &quot;RWSignInService.h&quot;

@implementation RWSignInService

- (void)signInWithUsername:(NSString *)username password:(NSString *)password complete:(RWSignInResponse)completeBlock {
    
    [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:YES];
    double delayInSeconds = 2.0;
    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * NSEC_PER_SEC));
    dispatch_after(popTime, dispatch_get_main_queue(), ^(void){
        [[UIApplication sharedApplication] setNetworkActivityIndicatorVisible:NO];
        BOOL success = [username isEqualToString:@&quot;user&quot;] &amp;&amp; [password isEqualToString:@&quot;password&quot;];
        completeBlock(success);
    });
}

@end
</code></pre>

<p>这个<code>service</code>有3个参数，用户名、密码和一个完成回调<code>block</code>。这个<code>block</code>会在登录成功或失败时执行。你可以在按钮点击事件的<code>subscribeNext: blcok</code>里直接调用这个方法。</p>

<p><em>注意：本教程为了简便使用了一个假的service，所以它不依赖任何外部API。但你现在的确遇到了一个问题，如何使用这些不是用信号表示的API呢？</em></p>

<h3 id="toc_5">创建信号</h3>

<p><mark>幸运的是，把已有的异步API用信号的方式来表示相当简单。</mark>，还是在<code>ViewController.m</code>中，添加下面的方法：</p>

<pre><code class="language-objc">-(RACSignal *)signInSignal{
    return [RACSignal createSignal:^RACDisposable *(id subscriber){
        [self.signInService signInWithUsername:self.name.text password:self.pass.text complete:^(BOOL success){
            [subscriber sendNext:@(success)];
            [subscriber sendCompleted];
        }];
        return nil;
    }];
}
</code></pre>

<p>上面的方法创建了一个信号，使用用户名和密码登录。现在分解来看一下。</p>

<p>上面的代码使用<code>RACSignal</code>的<code>createSignal:</code>方法来创建信号。方法的入参是一个<code>block</code>，这个<code>block</code>描述了这个信号。当这个信号有<code>subscriber</code>时，<code>block</code>里的代码就会执行。</p>

<p><code>block</code>的入参是一个<code>subscriber</code>实例，它遵循<code>RACSubscriber</code>协议，协议里有一些方法来产生事件，你可以发送任意数量的<code>next</code>事件，或者用<code>error\complete</code>事件来终止。本例中，信号发送了一个<code>next</code>事件来表示登录是否成功，随后是一个<code>complete</code>事件。</p>

<p>这个<code>block</code>的返回值是一个<code>RACDisposable</code>对象，它允许你在一个订阅被取消时执行一些清理工作。当前的信号不需要执行清理操作，所以返回<code>nil</code>就可以了。</p>

<p>可以看到，把一个异步<code>API</code>用信号封装是多简单！</p>

<p>现在就来使用这个新的信号。把之前添加在<code>viewDidLoad</code>中的代码更新成下面这样的：</p>

<pre><code class="language-objc">[[[self.signInButton
   rac_signalForControlEvents:UIControlEventTouchUpInside]
   map:^id(id x){
     return[self signInSignal];
   }]
   subscribeNext:^(id x){
     NSLog(@&quot;Sign in result: %@&quot;, x);
   }];

</code></pre>

<p>上面的代码使用<code>map</code>方法，把按钮点击信号转换成了登录信号。<code>subscriber</code>输出<code>log</code>.</p>

<p>编译运行，点击登录按钮，查看<code>Xcode</code>的控制台后发现输出的是一个信号实例，没错，你已经给<code>subscribeNext:</code>的<code>block</code>传入了一个信号，但传入的不是登录结果的信号。<br/>
<img src="media/15083737124086/15083764662317.png" alt=""/></p>

<p>当点击按钮时，<code>rac_signalForControlEvents</code>发送了一个<code>next</code>事件（事件的data是UIButton）。<code>map</code>操作创建并返回了登录信号，这意味着后续步骤都会收到一个<code>RACSignal</code>。这就是你在<code>subscribeNext:</code>这步看到的。</p>

<p>上面问题的解决方法，有时候叫做信号中的信号，换句话说就是一个外部信号里面还有一个内部信号。你可以在外部信号的<code>subscribeNext:block</code>里订阅内部信号。不过这样嵌套太混乱啦，还好<code>ReactiveCocoa</code>已经解决了这个问题。</p>

<p>解决的方法很简单，只需要把<code>map</code>操作改成<code>flattenMap</code>就可以了：</p>

<pre><code class="language-objc">[[[self.signInButton
   rac_signalForControlEvents:UIControlEventTouchUpInside]
   flattenMap:^id(id x){
     return[self signInSignal];
   }]
   subscribeNext:^(id x){
     NSLog(@&quot;Sign in result: %@&quot;, x);
   }];
</code></pre>

<p>这个操作把按钮点击事件转换为登录信号，同时还从内部信号发送事件到外部信号。</p>

<p>到这里我们的大部分内容就结束了。最后就是在<code>subscribeNext</code>步骤里添加登录成功后的逻辑。把代码更新成下面的：</p>

<pre><code class="language-objc">[[[self.sign rac_signalForControlEvents:UIControlEventTouchUpInside]
     flattenMap:^id(id x){
         return [self signInSignal];
     }]
     subscribeNext:^(NSNumber*signedIn){
         BOOL success =[signedIn boolValue];
         if(success){
             NSLog(@&quot;Success!!!&quot;);
         }
     }];
</code></pre>

<p>但是，你注意到这个应用现在有一些用户体验上的小问题了吗？当登录service正在校验用户名和密码时，登录按钮应该是不可点击的。这会防止用户多次执行登录操作。</p>

<p>这个逻辑应该怎么添加呢？改变按钮的可用状态并不是转换（map）、过滤（filter）或者其他已经学过的概念。其实这个就叫做“副作用”，换句话说就是在一个<code>next</code>事件发生时执行的逻辑，而该逻辑并不改变事件本身。</p>

<h3 id="toc_6">添加附加操作（Adding side-effects）</h3>

<p>把代码更新成下面的：</p>

<pre><code class="language-objc">[[[[self.sign rac_signalForControlEvents:UIControlEventTouchUpInside]
       doNext:^(id x){
           self.sign.enabled = NO;
       }]
     flattenMap:^id(id x){
         return [self signInSignal];
     }]
     subscribeNext:^(NSNumber*signedIn){
         BOOL success =[signedIn boolValue];
         if(success){
             NSLog(@&quot;Success!!!&quot;);
         }
     }];
</code></pre>

<p>你可以看到<code>doNext:</code>是直接跟在按钮点击事件的后面。而且<code>doNext: block</code>并没有返回值。因为它是附加操作，并不改变事件本身。</p>

<p>上面的<code>doNext: block</code>把按钮置为不可点击，隐藏登录失败提示。然后在<code>subscribeNext: block</code>里重新把按钮置为可点击，并根据登录结果来决定是否显示失败提示。</p>

<p>之前的管道图就更新成下面这样的：<br/>
<img src="media/15083737124086/15083777066162.png" alt=""/></p>

<p>现在所有的工作都已经完成了，这个应用已经是响应式的啦!!</p>

]]></content>
  </entry>
  
</feed>
