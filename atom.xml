<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2017-12-11T16:49:21+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Longest Palindromic Substring]]></title>
    <link href="https://lockxmonk.github.io/15130621165951.html"/>
    <updated>2017-12-12T15:01:56+08:00</updated>
    <id>https://lockxmonk.github.io/15130621165951.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15130621165951/15130621284508.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return &quot;&quot;;
        if (s.size() == 1) return s;
        int min_start = 0, max_len = 1;
        for (int i = 0; i &lt; s.size();) {
            if (s.size() - i &lt;= max_len / 2) break;
            int j = i, k = i;
            while (k &lt; s.size()-1 &amp;&amp; s[k+1] == s[k]) ++k; // Skip duplicate characters.
            i = k+1;
            while (k &lt; s.size()-1 &amp;&amp; j &gt; 0 &amp;&amp; s[k + 1] == s[j - 1]) { ++k; --j; } // Expand.
            int new_len = k - j + 1;
            if (new_len &gt; max_len) { min_start = j; max_len = new_len; }
        }
        return s.substr(min_start, max_len);
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Palindrome Pairs]]></title>
    <link href="https://lockxmonk.github.io/15130603513802.html"/>
    <updated>2017-12-12T14:32:31+08:00</updated>
    <id>https://lockxmonk.github.io/15130603513802.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15130603513802/15130603727154.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    bool isPalindrome(string s) {
        if (s.size() &lt;= 1) return true;
        int i = 0;
        int j = s.size() - 1;
        while (i &lt; j) {
            if (s[i++] != s[j--]) return false;
        }

        return true;
    }

    vector&lt;vector&lt;int&gt;&gt; palindromePairs(vector&lt;string&gt;&amp; words) {
        vector&lt;vector&lt;int&gt;&gt; res;
        if (!words.size()) return res;
        unordered_map&lt;string, int&gt; word_idx;
        for (int i = 0; i &lt; words.size(); ++i) {
            word_idx[words[i]] = i;
        }
        vector&lt;int&gt; slu(2);
        for (int i = 0; i &lt; words.size(); ++i) {
            int len = words[i].length();
            for (int l = 0; l &lt;= len; ++l) {
                string left = words[i].substr(0, l);
                string right = words[i].substr(l);
                string rleft = left;
                string rright = right;
                reverse(rleft.begin(), rleft.end());
                reverse(rright.begin(), rright.end());
                if (word_idx.find(rleft) != word_idx.end()) {
                    if (word_idx[rleft] != i &amp;&amp; isPalindrome(right)) {
                        res.push_back({i,word_idx[rleft]});
                    }

                }
                if (l != 0 &amp;&amp; word_idx.find(rright) != word_idx.end()) {
                    if (word_idx[rright] != i &amp;&amp; isPalindrome(left)) {
                        res.push_back({word_idx[rright],i});
                    }

                }

            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intersection of Two Arrays II]]></title>
    <link href="https://lockxmonk.github.io/15130426368802.html"/>
    <updated>2017-12-12T09:37:16+08:00</updated>
    <id>https://lockxmonk.github.io/15130426368802.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15130426368802/15130427333668.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
        unordered_map&lt;int, int&gt; map;
        vector&lt;int&gt; res;
        for(auto num1:nums1){
            map[num1]++;
        }

        for(auto num2:nums2){
            if (map[num2]&gt;0) {
                map[num2]--;
                res.push_back(num2);
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sort Characters By Frequency]]></title>
    <link href="https://lockxmonk.github.io/15129821006078.html"/>
    <updated>2017-12-11T16:48:20+08:00</updated>
    <id>https://lockxmonk.github.io/15129821006078.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129821006078/15129821362536.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string frequencySort(string s) {
        unordered_map&lt;char, int&gt; map;
        for (int i =0; i&lt;s.length(); i++) {
            map[s[i]]++;
        }

        sort(s.begin(), s.end(), [&amp;map](char a ,char b){
            return map[a]&gt;map[b] || (map[a] == map[b] &amp;&amp; a &gt; b);
        });
        
        return s;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[First Unique Character in a String]]></title>
    <link href="https://lockxmonk.github.io/15129806433168.html"/>
    <updated>2017-12-11T16:24:03+08:00</updated>
    <id>https://lockxmonk.github.io/15129806433168.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129806433168/15129806517273.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int firstUniqChar(string s) {
        unordered_map&lt;char, int&gt; map;
        for (int i =0; i&lt;s.length(); i++) {
            map[s[i]]++;
        }
        for (int i =0; i&lt;s.length(); i++) {
            if (map[s[i]]==1) {
                return i;
            }
        }
        return -1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Minimum Moves to Equal Array Elements II]]></title>
    <link href="https://lockxmonk.github.io/15129796221707.html"/>
    <updated>2017-12-11T16:07:02+08:00</updated>
    <id>https://lockxmonk.github.io/15129796221707.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129796221707/15129796318879.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int minMoves2(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        if(n &lt;= 1) return 0;
        sort(nums.begin(), nums.end());
        int mid = nums.size()/2 ,res = 0;
        for(int i = 0; i &lt; mid; ++i)
        {
            res+=nums[mid]-nums[i];
        }
        for (int j = n-1; j&gt;mid; j--) {
            res+=nums[j]-nums[mid];
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Minimum Moves to Equal Array Elements]]></title>
    <link href="https://lockxmonk.github.io/15129788527282.html"/>
    <updated>2017-12-11T15:54:12+08:00</updated>
    <id>https://lockxmonk.github.io/15129788527282.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129788527282/15129788644532.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int minMoves(vector&lt;int&gt;&amp; nums) {
        int n = nums.size();
        if(n &lt;= 1)
            return 0;
        int mn = nums[0];   //mn为最小数字
        int sum = nums[0];
        for(int i = 1; i &lt; n; ++i)
        {
            mn = min(mn,nums[i]);
            sum += nums[i];
        }
        return sum - mn*n;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Range Addition II]]></title>
    <link href="https://lockxmonk.github.io/15129760305793.html"/>
    <updated>2017-12-11T15:07:10+08:00</updated>
    <id>https://lockxmonk.github.io/15129760305793.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129760305793/15129772098038.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int maxCount(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; ops) {
        for (auto tmp:ops) {
            m = min(m, tmp[0]);
            n = min(n, tmp[1]);
        }
        return m*n;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beauty Contest（旋转卡壳）]]></title>
    <link href="https://lockxmonk.github.io/15129738955534.html"/>
    <updated>2017-12-11T14:31:35+08:00</updated>
    <id>https://lockxmonk.github.io/15129738955534.html</id>
    <content type="html"><![CDATA[
<p>Description<br/>
Bessie, Farmer John&#39;s prize cow, has just won first place in a bovine beauty contest, earning the title &#39;Miss Cow World&#39;. As a result, Bessie will make a tour of N (2 &lt;= N &lt;= 50,000) farms around the world in order to spread goodwill between farmers and their cows. For simplicity, the world will be represented as a two-dimensional plane, where each farm is located at a pair of integer coordinates (x,y), each having a value in the range -10,000 ... 10,000. No two farms share the same pair of coordinates.</p>

<p>Even though Bessie travels directly in a straight line between pairs of farms, the distance between some farms can be quite large, so she wants to bring a suitcase full of hay with her so she has enough food to eat on each leg of her journey. Since Bessie refills her suitcase at every farm she visits, she wants to determine the maximum possible distance she might need to travel so she knows the size of suitcase she must bring.Help Bessie by computing the maximum distance among all pairs of farms.</p>

<p>Input<br/>
 Line 1: A single integer, N</p>

<p>Lines 2..N+1: Two space-separated integers x and y specifying coordinate of each farm</p>

<p>Output<br/>
Line 1: A single integer that is the squared distance between the pair of farms that are farthest apart from each other.</p>

<p>Sample Input</p>

<p>4<br/>
0 0<br/>
0 1<br/>
1 1<br/>
1 0</p>

<p>Sample Output</p>

<p>2</p>

<h2 id="toc_0">算法思想</h2>

<h3 id="toc_1">流程：</h3>

<ol>
<li><p>求凸包：最远点对一定在凸包上（可以反证法证之），所以找出凸包后在其上找最远点对就可以少考虑很多点。求凸包可用<code>andrew</code>算法，它是基于<code>graham</code>算法，且更快更稳定。不同于<code>graham</code>算法的逆时针排序，<code>andrew</code>算法采用了点的水平排序，然后分别求下凸包以及上凸包，这样下来整个的凸包便求好了。而且该算法可以解决凸包中有重合点、共线点等问题<img src="media/15129738955534/15129741482264.jpg" alt=""/></p></li>
<li><p>旋转卡壳<br/>
就是两个平行线正好把凸包卡住，其中卡着的点称为对踵点对.<br/>
<img src="media/15129738955534/15129741907694.jpg" alt=""/></p></li>
</ol>

<p>那么怎么才能找到最远点对呢？<br/>
<img src="media/15129738955534/15129742545712.jpg" alt=""/></p>

<p>对于上图中的6个三角形的公共底边，可知当三角形的顶点在凸包上按逆时针旋转时，三角形的面积先由小变大再由大变小，即成单峰函数变化。所以在峰值时对应的凸包顶点距底边对应的两个对踵点的距离比其他情况大，这样，枚举每一个边并找到其面积单峰函数峰值对应的顶点，同时更新最大距离，旋转一趟下来便可以得到最后的结果。求面积单峰函数的峰值也很简单，就是通过叉积比较两个三角形的大小，当后者的面积比前者小时便找到了峰值，然后求距离更新最大值即可。</p>

<pre><code class="language-c++">    #include &lt;cstdio&gt;  
    #include &lt;vector&gt;  
    #include &lt;algorithm&gt;  
    #include &lt;cstring&gt;  
    using namespace std;  
    const int maxn = 50000 + 10;  
    typedef int type_xy;  
      
    struct P  
    {  
        type_xy x, y;  
        P() {}  
        P(type_xy x, type_xy y) : x(x), y(y) {}  
        P operator + (P p){ return P(x + p.x, y + p.y); }  
        P operator - (P p){ return P(x - p.x, y - p.y); }  
        P operator * (type_xy d){ return P(x*d, y*d); }  
        bool operator &lt; (const P&amp; a) const  
        {  
            if (x != a.x) return x &lt; a.x;  
            else return y &lt; a.y;  
        }  
        type_xy dot(P p) { return x*p.x + y*p.y; }  
        type_xy det(P p) { return x*p.y - y*p.x; }  
    };  
      
    int N;  
    P ps[maxn];  
      
    //字典序比较  
    bool cmp_x(const P&amp; p, const P&amp; q)  
    {  
        if (p.x != q.x)  
            return p.x &lt; q.x;  
        return p.y &lt; q.y;  
    }  
      
    //求凸包  
    vector&lt;P&gt; convex_hull(P* ps, int n)  
    {  
        sort(ps, ps + n, cmp_x);  
        int k = 0;          //凸包的顶点数  
        vector&lt;P&gt; qs(n * 2);        //构造中的凸包  
        //构造凸包的下侧  
        for (int i = 0; i &lt; n; i++){  
            while (k &gt; 1 &amp;&amp; (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) &lt;= 0)  
                k--;  
            qs[k++] = ps[i];  
        }  
        //构造凸包的上侧  
        for (int i = n - 2, t = k; i &gt;= 0; i--){  
            while (k &gt; t &amp;&amp; (qs[k - 1] - qs[k - 2]).det(ps[i] - qs[k - 1]) &lt;= 0)  
                k--;  
            qs[k++] = ps[i];  
        }  
        qs.resize(k - 1);  
        return qs;  
    }  
      
    //距离的平方  
    double dist(P p, P q)  
    {  
        return (p - q).dot(p - q);  
    }  
      
      
    void solve()  
    {  
        vector&lt;P&gt; qs = convex_hull(ps, N);  
        int n = qs.size();  
        if (n == 2){         //特别处理凸包退化的情况  
            printf(&quot;%.0f\n&quot;, dist(qs[0], qs[1]));  
            return;  
        }  
        int i = 0, j = 0;           //某个方向上的对踵点对  
        //求出x轴方向上的对踵点对  
        for (int k = 0; k &lt; n; k++){  
            if (!cmp_x(qs[i], qs[k]))  
                i = k;  
            if (cmp_x(qs[j], qs[k]))  
                j = k;  
        }  
        double res = 0;  
        int si = i, sj = j;  
        while (i != sj || j != si){     //将方向逐步旋转180度  
            res = max(res, dist(qs[i], qs[j]));  
            //判断先转到边i-(i+1)的法线方向还是边j-(j+1)的法线方向  
            if ((qs[(i + 1) % n] - qs[i]).det(qs[(j + 1) % n] - qs[j]) &lt; 0)  
                i = (i + 1) % n;        //先转到边i-(i+1)的法线方向  
            else  
                j = (j + 1) % n;        //先转到边j-(j+1)的法线方向  
        }  
        printf(&quot;%.0f\n&quot;, res);  
    }  
      
    int main()  
    {  
        while (scanf(&quot;%d&quot;, &amp;N) != EOF){  
            for (int i = 0; i &lt; N; i++){  
                scanf(&quot;%d%d&quot;, &amp;ps[i].x, &amp;ps[i].y);  
            }  
            solve();  
        }  
        return 0;  
    }  
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Excel Sheet Column Title]]></title>
    <link href="https://lockxmonk.github.io/15129633578167.html"/>
    <updated>2017-12-11T11:35:57+08:00</updated>
    <id>https://lockxmonk.github.io/15129633578167.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129633578167/15129633692969.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string convertToTitle(int n) {
        string res = &quot;&quot;;
        while (n!=0) {
            res = char(&#39;A&#39;+(--n)%26)+res;
            n=n/26;
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Excel Sheet Column Number]]></title>
    <link href="https://lockxmonk.github.io/15129586256568.html"/>
    <updated>2017-12-11T10:17:05+08:00</updated>
    <id>https://lockxmonk.github.io/15129586256568.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129586256568/15129586339253.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int titleToNumber(string s) {
        int res = 0;
        for (int i=0; i&lt;s.length(); i++) {
            res = res * 26 + (s[i] - &#39;A&#39; + 1);
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flood Fill]]></title>
    <link href="https://lockxmonk.github.io/15129573661731.html"/>
    <updated>2017-12-11T09:56:06+08:00</updated>
    <id>https://lockxmonk.github.io/15129573661731.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129573661731/15129573748798.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    void fillColor(vector&lt;vector&lt;int&gt;&gt;&amp; image,int sr, int sc ,int tmp){
        if (sr&gt;0&amp;&amp;image[sr-1][sc]==tmp) {
            image[sr-1][sc]=image[sr][sc];
            fillColor(image, sr-1, sc, tmp);
        }
        if (sr&lt;image.size()-1&amp;&amp;image[sr+1][sc]==tmp) {
            image[sr+1][sc]=image[sr][sc];
            fillColor(image, sr+1, sc, tmp);
        }
        if (sc&gt;0&amp;&amp;image[sr][sc-1]==tmp) {
            image[sr][sc-1]=image[sr][sc];
            fillColor(image, sr, sc-1, tmp);
        }
        if (sc&lt;image[0].size()-1&amp;&amp;image[sr][sc+1]==tmp) {
            image[sr][sc+1]=image[sr][sc];
            fillColor(image, sr, sc+1, tmp);
        }
    }

    vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) {
        int tmp = image[sr][sc];
        if (tmp == newColor) {
            return image;
        }
        image[sr][sc] = newColor;
        fillColor(image, sr, sc, tmp);
        return image;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Construct the Rectangle]]></title>
    <link href="https://lockxmonk.github.io/15129554975886.html"/>
    <updated>2017-12-11T09:24:57+08:00</updated>
    <id>https://lockxmonk.github.io/15129554975886.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15129554975886/15129555123983.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; constructRectangle(int area) {
        for(int mid = sqrt(area); mid&gt;0; mid--)
            if (!(area%mid))
                return {area/mid, mid};
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Relative Ranks]]></title>
    <link href="https://lockxmonk.github.io/15128072112005.html"/>
    <updated>2017-12-09T16:13:31+08:00</updated>
    <id>https://lockxmonk.github.io/15128072112005.html</id>
    <content type="html"><![CDATA[
<p>Given scores of <strong>N</strong> athletes, find their relative ranks and the people with the top three highest scores, who will be awarded medals: &quot;Gold Medal&quot;, &quot;Silver Medal&quot; and &quot;Bronze Medal&quot;.</p>

<p><img src="media/15128072112005/15128073582183.jpg" alt=""/></p>

<p><code>pair</code>的用法和优先队列的使用</p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; findRelativeRanks(vector&lt;int&gt;&amp; nums) {
        priority_queue&lt;pair&lt;int,int&gt; &gt; pq;
        for(int i=0;i&lt;nums.size();i++)
        {
            pq.push(make_pair(nums[i],i));
        }
        vector&lt;string&gt; res(nums.size(),&quot;&quot;);
        int count = 1;
        for(int i=0; i&lt;nums.size();i++)
        {
            if(count==1) {res[pq.top().second] = &quot;Gold Medal&quot;; count++;}
            else if(count==2) {res[pq.top().second] = &quot;Silver Medal&quot;; count++;}
            else if(count==3) {res[pq.top().second] = &quot;Bronze Medal&quot;; count++;}
            else {res[pq.top().second] = to_string(count); count++;}
            pq.pop();
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Valid Anagram]]></title>
    <link href="https://lockxmonk.github.io/15128043838038.html"/>
    <updated>2017-12-09T15:26:23+08:00</updated>
    <id>https://lockxmonk.github.io/15128043838038.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15128043838038/15128043943990.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    bool isAnagram(string s, string t) {
        if (s.length() != t.length()) return false;
        unordered_map&lt;char, int&gt; map;
        for (int i =0; i&lt;s.length(); i++) {
            map[s[i]]++;
            map[t[i]]--;
        }
        for(auto s:map){
            if(s.second&lt;0) return 0;
        }
        return 1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Assign Cookies]]></title>
    <link href="https://lockxmonk.github.io/15128026901484.html"/>
    <updated>2017-12-09T14:58:10+08:00</updated>
    <id>https://lockxmonk.github.io/15128026901484.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15128026901484/15128027017206.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findContentChildren(vector&lt;int&gt;&amp; g, vector&lt;int&gt;&amp; s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        int logG=0;
        for (int i=0; i&lt;s.size(); i++) {
            if (g[logG]&lt;=s[i]&amp;&amp;logG&lt;g.size()) {
                logG++;
            }
        }
        return logG;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ransom Note]]></title>
    <link href="https://lockxmonk.github.io/15128009688279.html"/>
    <updated>2017-12-09T14:29:28+08:00</updated>
    <id>https://lockxmonk.github.io/15128009688279.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15128009688279/15128009813033.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        unordered_map&lt;char, int&gt; map;
        for (int i = 0; i&lt;magazine.length(); i++) {
            map[magazine[i]]++;
        }
        for (int j = 0; j&lt;ransomNote.length(); j++) {
            if(--map[ransomNote[j]]&lt;0) return 0;
        }
        return 1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reverse String II]]></title>
    <link href="https://lockxmonk.github.io/15127898937133.html"/>
    <updated>2017-12-09T11:24:53+08:00</updated>
    <id>https://lockxmonk.github.io/15127898937133.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127898937133/15127899074799.jpg" alt=""/></p>

<p>运用内置的<code>reverse</code>函数</p>

<pre><code class="language-c++">class Solution {
public:
    string reverseStr(string s, int k) {
        for (int i = 0; i&lt;s.length(); i+=2*k) {
            reverse(s.begin()+i, min(s.begin()+i+k, s.end()));
        }
        return s;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Base 7]]></title>
    <link href="https://lockxmonk.github.io/15127884486398.html"/>
    <updated>2017-12-09T11:00:48+08:00</updated>
    <id>https://lockxmonk.github.io/15127884486398.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127884486398/15127884572899.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    string convertToBase7(int num) {
        int x = abs(num); string res;
        do {
          res = to_string(x%7)+res;
        } while (x/=7);
        
        return (num&gt;=0? &quot;&quot; : &quot;-&quot;) + res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[License Key Formatting]]></title>
    <link href="https://lockxmonk.github.io/15127864249320.html"/>
    <updated>2017-12-09T10:27:04+08:00</updated>
    <id>https://lockxmonk.github.io/15127864249320.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127864249320/15127864500019.jpg" alt=""/></p>

<p>第一版：</p>

<pre><code class="language-c++">    int log = 0;
    string ele=&quot;&quot;;
    string re=&quot;&quot;;
    for (int i = S.length()-1; i&gt;=0; i--) {
        if (S[i]!=&#39;-&#39;) {
            log++;
            S[i]=toupper(S[i]);
            ele = S[i]+ele;
        }
        if (log==K||i==0) {
            if (i==0) {
                re = ele+re;
            }else{
                re = &#39;-&#39;+ele+re;
            }
            log = 0;
            ele = &quot;&quot;;
        }
    }
    return re[0]==&#39;-&#39;?re.substr(1,re.length()-1):re;
</code></pre>

<p>第二版：运用栈</p>

<pre><code class="language-c++">class Solution {
public:
    string licenseKeyFormatting(string S, int K) {
        stack&lt;string&gt; st;
        string line;
        for(int i=S.length()-1;i&gt;=0;i--){
            if(S[i]==&#39;-&#39;) continue;
            
            if(line.length()&lt;K){
                if(S[i]&gt;=&#39;a&#39; &amp;&amp; S[i]&lt;=&#39;z&#39;) line.insert(0, 1, S[i]-&#39;a&#39;+&#39;A&#39;);
                else line.insert(0, 1, S[i]);
                
                if(line.length()==K){
                    st.push(line);
                    line=&quot;&quot;;
                }
            }
        }
        if(st.empty()) return line;
        
        if(line.length() == 0){
            line += st.top();
            st.pop();
        }
        while(!st.empty()){
            line+=&#39;-&#39;;
            line+=st.top();
            st.pop();
        }
        return line;
    }
};
</code></pre>

]]></content>
  </entry>
  
</feed>
