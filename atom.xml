<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2017-12-01T18:48:29+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Judge Route Circle]]></title>
    <link href="https://lockxmonk.github.io/15122038176626.html"/>
    <updated>2017-12-02T16:36:57+08:00</updated>
    <id>https://lockxmonk.github.io/15122038176626.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15122038176626/15122038286763.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    bool judgeCircle(string moves) {
        int UD = 0 ,LR = 0;
        for(char a:moves){
            if (a==&#39;U&#39;) {
                UD++;
            }else if (a==&#39;D&#39;){
                UD--;
            }else if (a==&#39;L&#39;){
                LR++;
            }else if (a==&#39;R&#39;){
                LR--;
            }
        }
        return (UD==0&amp;&amp;LR==0) ? 1:0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Self Dividing Numbers]]></title>
    <link href="https://lockxmonk.github.io/15122027653799.html"/>
    <updated>2017-12-02T16:19:25+08:00</updated>
    <id>https://lockxmonk.github.io/15122027653799.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15122027653799/15122027840243.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; selfDividingNumbers(int left, int right) {
        vector&lt;int&gt; v;
        for (int i = left; i &lt;= right; ++i) {
            int j= i;
            bool ok = 1;
            while (j) {
                int d= (j%10);
                if (d == 0 || i % d) ok = 0;
                j/=10;
            }
            if (ok) v.push_back(i);
        }
        return v;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Non-decreasing Array]]></title>
    <link href="https://lockxmonk.github.io/15122009526780.html"/>
    <updated>2017-12-02T15:49:12+08:00</updated>
    <id>https://lockxmonk.github.io/15122009526780.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15122009526780/15122009632510.jpg" alt=""/></p>

<p><strong>用到了<code>is_sorted</code>来判断是否升序排列</strong></p>

<pre><code class="language-c++">class Solution {
public:
    bool checkPossibility(vector&lt;int&gt;&amp; nums) {
        for (int i=0; i &lt; nums.size()-1; i++){
            if (nums[i] &gt; nums[i+1]){
                
                int temp = nums[i];
                //
                // &quot;erase&quot; nums[i], then check if nums is sorted without nums[i]
                //
                nums[i] = nums[i+1];
                if (is_sorted(nums.begin(), nums.end())) { return true; }
                
                //
                // &quot;erase&quot; nums[i+1], then check if nums is sorted without nums[i+1]
                //
                nums[i+1] = nums[i] = temp;
                if (is_sorted(nums.begin(), nums.end())) { return true; }
                
                //
                // nums is NOT sorted (without nums[i] XOR without nums[i+1])
                //
                return false;
            }
        }
        return true;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Third Maximum Number]]></title>
    <link href="https://lockxmonk.github.io/15121974728141.html"/>
    <updated>2017-12-02T14:51:12+08:00</updated>
    <id>https://lockxmonk.github.io/15121974728141.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15121974728141/15121974890265.jpg" alt=""/></p>

<p><strong>利用set的自动排序和去除重复元素来解决问题。</strong></p>

<pre><code class="language-c++">class Solution {
public:
    int thirdMax(vector&lt;int&gt;&amp; nums) {
        set&lt;int&gt; result;
        for (int num:nums) {
            result.insert(num);
            if (result.size()&gt;3) {
                result.erase(result.begin());
            }
        }
        return result.size()&lt;3? *result.rbegin():*result.begin();
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[K-diff Pairs in an Array]]></title>
    <link href="https://lockxmonk.github.io/15121892650067.html"/>
    <updated>2017-12-02T12:34:25+08:00</updated>
    <id>https://lockxmonk.github.io/15121892650067.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15121892650067/15121892810535.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findPairs(vector&lt;int&gt;&amp; nums, int k) {
        if (k&lt;0) {
            return 0;
        }
        unordered_set&lt;int&gt; result;  //用集合避免重复
        unordered_map&lt;int, int&gt; hash;   //hash表来映射所需数值
        for (int i = 0; i&lt;nums.size(); i++) {
            if (hash.count(nums[i]+k)) {
                result.insert(nums[i]+k);
            }
            if (hash.count(nums[i]-k)) {
                result.insert(nums[i]);
            }
            hash[nums[i]] += 1;
        }
        return result.size();
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Shortest Unsorted Continuous Subarray]]></title>
    <link href="https://lockxmonk.github.io/15121252648085.html"/>
    <updated>2017-12-01T18:47:44+08:00</updated>
    <id>https://lockxmonk.github.io/15121252648085.html</id>
    <content type="html"><![CDATA[
<p>Given an integer array, you need to find one <strong>continuous</strong> subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.</p>

<p>You need to find the <strong>shortest</strong> such subarray and output its length.</p>

<p><img src="media/15121252648085/15121252900217.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findUnsortedSubarray(vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; sortNums = nums;
        sort(sortNums.begin(), sortNums.end());
        int str = 0,end = nums.size()-1;
        while (nums[str]==sortNums[str]) {
            if (str==end) {
                return 0;
            }
            str++;
        }
        while (nums[end]==sortNums[end]) {
            end--;
        }
        return end-str+1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Can Place Flowers]]></title>
    <link href="https://lockxmonk.github.io/15121123646545.html"/>
    <updated>2017-12-01T15:12:44+08:00</updated>
    <id>https://lockxmonk.github.io/15121123646545.html</id>
    <content type="html"><![CDATA[
<p>Suppose you have a long flowerbed in which some of the plots are planted and some are not. However, flowers cannot be planted in adjacent plots - they would compete for water and both would die.</p>

<p>Given a flowerbed (represented as an array containing 0 and 1, where 0 means empty and 1 means not empty), and a number n, return if n new flowers can be planted in it without violating the no-adjacent-flowers rule.</p>

<p><img src="media/15121123646545/15121188914337.jpg" alt=""/></p>

<p><strong>第一种：3格的滑动窗口</strong></p>

<pre><code class="language-c++">class Solution {
public:
    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) {
        int str = 0 ,end = 2;
        int tol = 0;
        if (flowerbed.size()==1&amp;&amp;flowerbed[0]==0) {
            tol++;
        }else if(flowerbed[0]==0&amp;&amp;flowerbed[1]==0) {
            flowerbed[0]=1;
            tol++;
        }
        
        while (end&lt;=flowerbed.size()-1) {
            if (!(flowerbed[str]||flowerbed[str+1]||flowerbed[end])) {
                flowerbed[str+1] = 1;
                tol++;
            }
            str++;
            end++;
        }
        if (flowerbed.size()&gt;=3&amp;&amp;flowerbed[flowerbed.size()-1]==0&amp;&amp;flowerbed[flowerbed.size()-2]==0) {
            tol++;
        }
        return tol&gt;=n?1:0;
    }
};
</code></pre>

<p>第二种：</p>

<pre><code class="language-c++">class Solution {
public:
    bool canPlaceFlowers(vector&lt;int&gt;&amp; flowerbed, int n) {
        for (int i = 0; i &lt; flowerbed.size(); i++) {
            if (!flowerbed[i] &amp;&amp; (i == 0 || !flowerbed[i - 1]) &amp;&amp; (i == flowerbed.size() - 1 || !flowerbed[i + 1])) {
                flowerbed[i] = 1;
                n--;
            }
        }
        return n &lt;= 0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Contains Duplicate II]]></title>
    <link href="https://lockxmonk.github.io/15121120473287.html"/>
    <updated>2017-12-01T15:07:27+08:00</updated>
    <id>https://lockxmonk.github.io/15121120473287.html</id>
    <content type="html"><![CDATA[
<p>Given an array of integers and an integer <code>k</code>, find out whether there are two distinct indices <code>i</code> and <code>j</code> in the array such that <code>nums[i] = nums[j]</code> and the absolute difference between <code>i</code> and <code>j</code> is at most <code>k</code>.</p>

<p>判断数组中是否有重复的元素，并且下标之差不超过<code>k</code>。</p>

<pre><code class="language-c++">class Solution {
public:
    bool containsNearbyDuplicate(vector&lt;int&gt;&amp; nums, int k) {
        unordered_map&lt;int, int&gt; hash;
        for (int i=0; i&lt;nums.size(); i++) {
            if (hash.find(nums[i])!=hash.end()&amp;&amp;i-hash[nums[i]]&lt;=k) {
                return 1;
            }else{
                hash[nums[i]] = i;
            }
        }
        return 0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Sum]]></title>
    <link href="https://lockxmonk.github.io/15121110105671.html"/>
    <updated>2017-12-01T14:50:10+08:00</updated>
    <id>https://lockxmonk.github.io/15121110105671.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15121110105671/15121110244234.jpg" alt=""/></p>

<p><strong>运用hash表</strong></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        unordered_map&lt;int, int&gt; hash;
        vector&lt;int&gt; result;
        for (int i=0; i&lt;nums.size(); i++) {
            int numToFind = target - nums[i];
            if (hash.find(numToFind)!=hash.end()) {
                result.push_back(hash[numToFind]);
                result.push_back(i);
            }
            hash[nums[i]] = i;
        }
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maximum Average Subarray I]]></title>
    <link href="https://lockxmonk.github.io/15120990794732.html"/>
    <updated>2017-12-01T11:31:19+08:00</updated>
    <id>https://lockxmonk.github.io/15120990794732.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15120990794732/15120991082558.jpg" alt=""/></p>

<p><strong>解决方法：滑动窗口方案</strong></p>

<pre><code class="language-c++">class Solution {
public:
    double findMaxAverage(vector&lt;int&gt;&amp; nums, int k) {
        double r = INT_MIN;
        double sum = 0;
        for (int i = 0; i&lt;nums.size(); i++) {
            if (i&lt;k) {
                sum+=nums[i];
            }else{
                r = max(sum, r);
                sum +=nums[i]-nums[i-k];
            }
        }
        r = max(sum, r);
        return r/double(k);
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pascal's Triangle]]></title>
    <link href="https://lockxmonk.github.io/15120964350892.html"/>
    <updated>2017-12-01T10:47:15+08:00</updated>
    <id>https://lockxmonk.github.io/15120964350892.html</id>
    <content type="html"><![CDATA[
<p>Given numRows, generate the first numRows of Pascal&#39;s triangle.</p>

<p>For example, given numRows = 5,<br/>
Return<img src="media/15120964350892/15120964567125.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt;result(numRows);
        for (int i = 0; i&lt;numRows; i++) {
            result[i].resize(i+1);
            result[i][0] = result[i][i] = 1;
        
            for (int j = 1; j&lt;i; j++) {
                result[i][j] = result[i-1][j-1]+result[i-1][j];
            }
        }
        return result;
        
     }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Search Insert Position]]></title>
    <link href="https://lockxmonk.github.io/15120931328273.html"/>
    <updated>2017-12-01T09:52:12+08:00</updated>
    <id>https://lockxmonk.github.io/15120931328273.html</id>
    <content type="html"><![CDATA[
<p>Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>

<p>You may assume no duplicates in the array.<br/>
<img src="media/15120931328273/15120931550538.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int searchInsert(vector&lt;int&gt;&amp; nums, int target) {
        int result = 0;
        for (int i =0; i&lt;nums.size(); i++) {
            if (nums[i]&gt;=target) {
                return i;
            }
        }
        return nums.size();
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Maximum Subarray]]></title>
    <link href="https://lockxmonk.github.io/15120924554362.html"/>
    <updated>2017-12-01T09:40:55+08:00</updated>
    <id>https://lockxmonk.github.io/15120924554362.html</id>
    <content type="html"><![CDATA[
<p>Find the contiguous subarray within an array (containing at least one number) which has the largest sum.</p>

<p>For example, given the array<code>[-2,1,-3,4,-1,2,1,-5,4]</code>,<br/>
the contiguous subarray <code>[4,-1,2,1]</code> has the largest sum = <code>6</code>.</p>

<p>第一种解法：分治法</p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; findCrossSubArray(vector&lt;int&gt;&amp; nums, int mid, int low ,int high){
        int sum = 0;
        int leftSum = INT_MIN;
        int maxLeft = 0;
        for (int i = mid; i&gt;=low; i--) {
            sum = sum+nums[i];
            if (sum&gt;leftSum) {
                leftSum = sum;
                maxLeft = i;
            }
        }
        sum = 0;
        int rightSum = INT_MIN;
        int maxRight = 0;
        for (int j=mid+1; j&lt;=high; j++) {
            sum = sum+nums[j];
            if (sum&gt;rightSum) {
                rightSum = sum;
                maxRight = j;
            }
        }
        
        return {{maxLeft,maxRight,leftSum+rightSum}};
    }

    vector&lt;int&gt; findMaxSubArray(vector&lt;int&gt;&amp; nums,int low ,int high)
    {
        if (low==high) {
            return {{low,high,nums[low]}};
        }else{
            int mid = (low+high)/2;
            vector&lt;int&gt; leftSum = findMaxSubArray(nums, low, mid);
            vector&lt;int&gt; rightSum = findMaxSubArray(nums, mid+1, high);
            vector&lt;int&gt; crossSum = findCrossSubArray(nums, mid, low, high);
            if (leftSum[2]&gt;=rightSum[2]&amp;&amp;leftSum[2]&gt;=crossSum[2]) {
                return leftSum;
            }else if(rightSum[2]&gt;=leftSum[2]&amp;&amp;rightSum[2]&gt;=crossSum[2])
            {
                return rightSum;
            }
            else return crossSum;
        }
    
    }


    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int len = nums.size()-1;
        vector&lt;int&gt; result = findMaxSubArray(nums, 0, len);
        return result[2];
    }
};
</code></pre>

<p>第二种解法：</p>

<pre><code class="language-c++">class Solution {
public:
    int maxSubArray(vector&lt;int&gt;&amp; nums) {
        int ans=nums[0],i,j,sum=0;
        for(i=0;i&lt;nums.size();i++){
            sum+=nums[i];
            ans=max(sum,ans);
            sum=max(sum,0);
        }
        return ans;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Longest Continuous Increasing Subsequence]]></title>
    <link href="https://lockxmonk.github.io/15120510835546.html"/>
    <updated>2017-11-30T22:11:23+08:00</updated>
    <id>https://lockxmonk.github.io/15120510835546.html</id>
    <content type="html"><![CDATA[
<p>Given an unsorted array of integers, find the length of longest <code>continuous</code> increasing subsequence.</p>

<p><img src="media/15120510835546/15120511118059.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findLengthOfLCIS(vector&lt;int&gt;&amp; nums) {
        int tmp = 1;
        int result = 1;
        if (nums.size()==1) {
            return tmp;
        }
        if (nums.empty()) {
            return 0;
        }
        nums.push_back(INT_MIN);
        for (int i =1; i&lt;nums.size(); i++) {
            if (nums[i]&gt;nums[i-1]) {
                tmp++;
            }else{
                result = max(tmp, result);
                tmp = 1;
            }
        }
        return result; 
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Missing Number]]></title>
    <link href="https://lockxmonk.github.io/15120333911660.html"/>
    <updated>2017-11-30T17:16:31+08:00</updated>
    <id>https://lockxmonk.github.io/15120333911660.html</id>
    <content type="html"><![CDATA[
<p>Given an array containing n distinct numbers taken from <code>0, 1, 2, ..., n</code>, find the one that is missing from the array.</p>

<p>For example,<br/>
Given <code>nums = [0, 1, 3]</code> return <code>2</code>.</p>

<p>Note:<br/>
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>

<pre><code class="language-c++">class Solution {
public:
    int missingNumber(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        if (len==1) {
            return nums[0]==1?0:1;
        }
        sort(nums.begin(), nums.end());
        if (nums[0]!=0) {
            return 0;
        }
        for (int i=1; i&lt;len; i++) {
            if (i==0&amp;&amp;nums[i]!=0) {
                return 0;
            }
            if (nums[i]!=nums[i-1]+1) {
                return nums[i]-1;
            }
        }
        return nums[len-1]+1;
    }
};
</code></pre>

<p>第二种解法：<br/>
```c++<br/>
class Solution {<br/>
public:<br/>
    int missingNumber(vector<int>&amp; nums) {<br/>
        int result = nums.size();<br/>
        int i=0;</p>

<pre><code>    for(int num:nums){
        result ^= num;
        result ^= i;
        i++;
    }

    return result;
}
</code></pre>

<p>};<br/>
```</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Given an integer array, find three numbers whose product is maximum and output the maximum product.]]></title>
    <link href="https://lockxmonk.github.io/15120258790187.html"/>
    <updated>2017-11-30T15:11:19+08:00</updated>
    <id>https://lockxmonk.github.io/15120258790187.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15120258790187/15120319341000.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int maximumProduct(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        int len = nums.size();
        int tmp1 = nums[len-1]*nums[len-2]*nums[len-3];
        int tmp2 = nums[len-1]*nums[0]*nums[1];
        return max(tmp1, tmp2);
    }
};
</code></pre>

<p>主要考虑含有负数的情况。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Sum II - Input array is sorted]]></title>
    <link href="https://lockxmonk.github.io/15120258181532.html"/>
    <updated>2017-11-30T15:10:18+08:00</updated>
    <id>https://lockxmonk.github.io/15120258181532.html</id>
    <content type="html"><![CDATA[
<p>Given an array of integers that is already <strong><em>sorted in ascending order</em></strong>, find two numbers such that they add up to a specific target number.</p>

<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>

<p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>

<p><img src="media/15120258181532/15120258628279.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        int str = 0;
        int end = numbers.size()-1;
        while (numbers[str]+numbers[end]!=target) {
            if (numbers[str]+numbers[end]&gt;target) {
                end--;
            }else{
                str++;
            }
        }
        return vector&lt;int&gt;({str+1,end+1});
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Summary Ranges]]></title>
    <link href="https://lockxmonk.github.io/15120236843494.html"/>
    <updated>2017-11-30T14:34:44+08:00</updated>
    <id>https://lockxmonk.github.io/15120236843494.html</id>
    <content type="html"><![CDATA[
<p>Given a sorted integer array without duplicates, return the summary of its ranges.求数组中，连续数字的区间。</p>

<p><img src="media/15120236843494/15120237048289.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) {
        
        vector&lt;string&gt; result;
        if(nums.size()==0) return result;
        
        int end = nums[0]+1;
        int total = 0;
        if (nums.size()==1) {
            result.push_back(to_string(nums[0]));
            return result;
        }
        nums.push_back(INT_MAX); //充当哨兵
        for (int i=1; i&lt;nums.size(); i++) {
            if (nums[i]==end) {
                end++;
                total++;
                continue;
            }else{
                end = nums[i]+1;
                if (total==0) {
                    result.push_back(to_string(nums[i-1]));
                }else{
                    string tmp = to_string(nums[i-1-total])+&quot;-&gt;&quot;+to_string(nums[i-1]);
                    result.push_back(tmp);
                }
                total = 0;
            }
        }
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Majority Element]]></title>
    <link href="https://lockxmonk.github.io/15120100977395.html"/>
    <updated>2017-11-30T10:48:17+08:00</updated>
    <id>https://lockxmonk.github.io/15120100977395.html</id>
    <content type="html"><![CDATA[
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than <code>⌊ n/2 ⌋</code> times.</p>

<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>

<pre><code class="language-c++">class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        int total = 1;
        int tmp = 1;
        int result = nums[0];
        if (nums.size()==1) {
            return result;
        }
        nums.push_back(INT_MAX); //在最后增加一个边界哨兵
        for (int i=1; i&lt;=nums.size(); i++) {
            if (nums[i]==nums[i-1]) {
                tmp++;
            }else{
                result = tmp&gt;total ? nums[i-1]:result;
                total = max(tmp, total);
                tmp = 1;
            }
        }
        
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates from Sorted Array]]></title>
    <link href="https://lockxmonk.github.io/15120074710373.html"/>
    <updated>2017-11-30T10:04:31+08:00</updated>
    <id>https://lockxmonk.github.io/15120074710373.html</id>
    <content type="html"><![CDATA[
<p>Given a sorted array, remove the duplicates <code>in-place</code> such that each element appear only once and return the new length.</p>

<p>Do not allocate extra space for another array, you must do this by modifying the input array <code>in-place</code> with O(1) extra memory.</p>

<p><img src="media/15120074710373/15120081165110.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int tmp = INT_MIN;
        int log = 0;
        for (int i =0; i&lt;nums.size(); i++) {
            if (tmp!=nums[i]) {
                tmp = nums[i];
            }else{
                log++;
            }
            nums[i-log] = nums[i];
        }
        
        return nums.size()-log;
    }
};
</code></pre>

<p><img src="media/15120074710373/15120082747602.jpg" alt=""/></p>

]]></content>
  </entry>
  
</feed>
