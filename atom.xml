<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2017-11-29T23:58:18+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Given an integer array, find three numbers whose product is maximum and output the maximum product.]]></title>
    <link href="https://lockxmonk.github.io/15120258790187.html"/>
    <updated>2017-11-30T15:11:19+08:00</updated>
    <id>https://lockxmonk.github.io/15120258790187.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15120258790187/15120319341000.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int maximumProduct(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        int len = nums.size();
        int tmp1 = nums[len-1]*nums[len-2]*nums[len-3];
        int tmp2 = nums[len-1]*nums[0]*nums[1];
        return max(tmp1, tmp2);
    }
};
</code></pre>

<p>主要考虑含有负数的情况。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Two Sum II - Input array is sorted]]></title>
    <link href="https://lockxmonk.github.io/15120258181532.html"/>
    <updated>2017-11-30T15:10:18+08:00</updated>
    <id>https://lockxmonk.github.io/15120258181532.html</id>
    <content type="html"><![CDATA[
<p>Given an array of integers that is already <strong><em>sorted in ascending order</em></strong>, find two numbers such that they add up to a specific target number.</p>

<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>

<p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>

<p><img src="media/15120258181532/15120258628279.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) {
        int str = 0;
        int end = numbers.size()-1;
        while (numbers[str]+numbers[end]!=target) {
            if (numbers[str]+numbers[end]&gt;target) {
                end--;
            }else{
                str++;
            }
        }
        return vector&lt;int&gt;({str+1,end+1});
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Summary Ranges]]></title>
    <link href="https://lockxmonk.github.io/15120236843494.html"/>
    <updated>2017-11-30T14:34:44+08:00</updated>
    <id>https://lockxmonk.github.io/15120236843494.html</id>
    <content type="html"><![CDATA[
<p>Given a sorted integer array without duplicates, return the summary of its ranges.求数组中，连续数字的区间。</p>

<p><img src="media/15120236843494/15120237048289.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; summaryRanges(vector&lt;int&gt;&amp; nums) {
        
        vector&lt;string&gt; result;
        if(nums.size()==0) return result;
        
        int end = nums[0]+1;
        int total = 0;
        if (nums.size()==1) {
            result.push_back(to_string(nums[0]));
            return result;
        }
        nums.push_back(INT_MAX); //充当哨兵
        for (int i=1; i&lt;nums.size(); i++) {
            if (nums[i]==end) {
                end++;
                total++;
                continue;
            }else{
                end = nums[i]+1;
                if (total==0) {
                    result.push_back(to_string(nums[i-1]));
                }else{
                    string tmp = to_string(nums[i-1-total])+&quot;-&gt;&quot;+to_string(nums[i-1]);
                    result.push_back(tmp);
                }
                total = 0;
            }
        }
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Majority Element]]></title>
    <link href="https://lockxmonk.github.io/15120100977395.html"/>
    <updated>2017-11-30T10:48:17+08:00</updated>
    <id>https://lockxmonk.github.io/15120100977395.html</id>
    <content type="html"><![CDATA[
<p>Given an array of size n, find the majority element. The majority element is the element that appears more than <code>⌊ n/2 ⌋</code> times.</p>

<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>

<pre><code class="language-c++">class Solution {
public:
    int majorityElement(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        int total = 1;
        int tmp = 1;
        int result = nums[0];
        if (nums.size()==1) {
            return result;
        }
        nums.push_back(INT_MAX); //在最后增加一个边界哨兵
        for (int i=1; i&lt;=nums.size(); i++) {
            if (nums[i]==nums[i-1]) {
                tmp++;
            }else{
                result = tmp&gt;total ? nums[i-1]:result;
                total = max(tmp, total);
                tmp = 1;
            }
        }
        
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Duplicates from Sorted Array]]></title>
    <link href="https://lockxmonk.github.io/15120074710373.html"/>
    <updated>2017-11-30T10:04:31+08:00</updated>
    <id>https://lockxmonk.github.io/15120074710373.html</id>
    <content type="html"><![CDATA[
<p>Given a sorted array, remove the duplicates <code>in-place</code> such that each element appear only once and return the new length.</p>

<p>Do not allocate extra space for another array, you must do this by modifying the input array <code>in-place</code> with O(1) extra memory.</p>

<p><img src="media/15120074710373/15120081165110.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int removeDuplicates(vector&lt;int&gt;&amp; nums) {
        int tmp = INT_MIN;
        int log = 0;
        for (int i =0; i&lt;nums.size(); i++) {
            if (tmp!=nums[i]) {
                tmp = nums[i];
            }else{
                log++;
            }
            nums[i-log] = nums[i];
        }
        
        return nums.size()-log;
    }
};
</code></pre>

<p><img src="media/15120074710373/15120082747602.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Remove Element]]></title>
    <link href="https://lockxmonk.github.io/15120073985530.html"/>
    <updated>2017-11-30T10:03:18+08:00</updated>
    <id>https://lockxmonk.github.io/15120073985530.html</id>
    <content type="html"><![CDATA[
<p>Given an array and a value, remove all instances of that value <strong>in-place</strong> and return the new length.</p>

<p>Do not allocate extra space for another array, you must do this by modifying the input array <strong>in-place</strong> with O(1) extra memory.</p>

<p>The order of elements can be changed. It doesn&#39;t matter what you leave beyond the new length.</p>

<p><img src="media/15120073985530/15120074297000.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int removeElement(vector&lt;int&gt;&amp; nums, int val) {
        int total = 0;
        for (int i =0; i&lt;nums.size(); i++) {
            if (nums[i]==val) {
                total++;
            }else{
                nums[i-total] = nums[i];
            }
        }
        return nums.size()-total;
    }
};
</code></pre>

<p><img src="media/15120073985530/15120074551545.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Move Zeroes]]></title>
    <link href="https://lockxmonk.github.io/15120064619713.html"/>
    <updated>2017-11-30T09:47:41+08:00</updated>
    <id>https://lockxmonk.github.io/15120064619713.html</id>
    <content type="html"><![CDATA[
<p>Given an array <code>nums</code>, write a function to move all 0&#39;s to the end of it while maintaining the relative order of the non-zero elements.</p>

<p>For example, given <code>nums = [0, 1, 0, 3, 12]</code>, after calling your function, <code>nums</code> should be <code>[1, 3, 12, 0, 0]</code>.</p>

<p><strong>Note:</strong><br/>
1.  You must do this in-place without making a copy of the array.<br/>
2.  Minimize the total number of operations.</p>

<pre><code class="language-c++">class Solution {
public:
    void moveZeroes(vector&lt;int&gt;&amp; nums) {
        int log = 0; //索引0元素位置
        int logNO = 0;  //索引非0应放元素位置
        while (log&lt;nums.size()) {
            if (nums[log]!=0) {
                swap(nums[logNO], nums[log]);
                logNO++;
            }
            log++;
        }
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[☆☆Find All Numbers Disappeared in an Array]]></title>
    <link href="https://lockxmonk.github.io/15119708919827.html"/>
    <updated>2017-11-29T23:54:51+08:00</updated>
    <id>https://lockxmonk.github.io/15119708919827.html</id>
    <content type="html"><![CDATA[
<p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>

<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>

<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>

<p><img src="media/15119708919827/15119710141999.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; findDisappearedNumbers(vector&lt;int&gt;&amp; nums) {
        int len = nums.size();
        for(int i=0; i&lt;len; i++) {
            int m = abs(nums[i])-1;  // index start from 0
            nums[m] = nums[m]&gt;0 ? -nums[m] : nums[m];
        }
        vector&lt;int&gt; res;
        for(int i = 0; i&lt;len; i++) {
            if(nums[i] &gt; 0) res.push_back(i+1);
        }
        return res;
    }
};
</code></pre>

<p>该题用了一个特殊的方法，<strong>取负法</strong>。</p>

<p><strong>含义是：将元素对应的位置取负。简单一句话可能不好理解，我们举个例子。假设在位置k放了元素i，则在取负的过程中i的取值有两种可能：为正，表示当前尚未遇到元素k将该位置取负；为负，表示当前已经有元素k出现，并将元素取负。但是我们不关心k，我们关心元素i。元素i既然出现，我们就看一下位置i：为正，表示这是元素i第一次出现，我们将位置i取负；为负，表示元素i已经出现过一次，我们不做任何操作。不管一个元素出现一次还是两次，只要出现它对应的位置就会被取负。当某个元素不出现的时候，该元素对应的位置始终访问不到，所以还是正值，通过这种方法我们就可以找到哪些元素没有出现。</strong> </p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Max Area of Island]]></title>
    <link href="https://lockxmonk.github.io/15119656914314.html"/>
    <updated>2017-11-29T22:28:11+08:00</updated>
    <id>https://lockxmonk.github.io/15119656914314.html</id>
    <content type="html"><![CDATA[
<p>Given a non-empty 2D array <code>grid</code> of 0&#39;s and 1&#39;s, an island is a group of 1&#39;s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>

<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)<br/>
<img src="media/15119656914314/15119657218724.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int areaNum(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int m ,int n){
        if (m&lt;grid.size()&amp;&amp;m&gt;=0&amp;&amp;n&lt;grid[0].size()&amp;&amp;n&gt;=0&amp;&amp;grid[m][n]==1) {
            //将经过的位置标记为0，避免循环检验
            grid[m][n] = 0;
            return 1+ areaNum(grid, m+1, n)+areaNum(grid, m, n+1)+areaNum(grid, m-1, n)+areaNum(grid, m, n-1);
        }
        return 0;
    }
    
    int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int result = 0;
        for (int i =0; i&lt;grid.size(); i++) {
            for (int j=0; j&lt;grid[0].size(); j++) {
                if (grid[i][j]==1) {
                    result = max(result, areaNum(grid, i, j));
                }
            }
        }
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Max Consecutive Ones]]></title>
    <link href="https://lockxmonk.github.io/15119430001845.html"/>
    <updated>2017-11-29T16:10:00+08:00</updated>
    <id>https://lockxmonk.github.io/15119430001845.html</id>
    <content type="html"><![CDATA[
<p>Given a binary array, find the maximum number of consecutive 1s in this array.<br/>
<img src="media/15119430001845/15119430248541.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findMaxConsecutiveOnes(vector&lt;int&gt;&amp; nums) {
        int sum1 = 0;
        int tmp = 0;
        for (int i=0; i&lt;nums.size(); i++) {
        if (nums[i]==1) {
            tmp++;
        }else{
            tmp = 0;
        }
            sum1 = max(tmp, sum1);
        }
    
        return sum1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Range Sum Query 2D - Immutable]]></title>
    <link href="https://lockxmonk.github.io/15119407096444.html"/>
    <updated>2017-11-29T15:31:49+08:00</updated>
    <id>https://lockxmonk.github.io/15119407096444.html</id>
    <content type="html"><![CDATA[
<p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).<br/>
<img src="media/15119407096444/15119407391245.jpg" alt=""/></p>

<pre><code class="language-c++">class NumMatrix {
private:
    int col,row;
    vector&lt;vector&lt;int&gt;&gt; sums;
public:
    NumMatrix(vector&lt;vector&lt;int&gt;&gt; matrix) {
        row = matrix.size();
        col =row&gt;0 ? matrix[0].size():0;
        sums = vector&lt;vector&lt;int&gt;&gt;(row+1, vector&lt;int&gt;(col+1,0));
        for(int i=1;i&lt;=row;i++)
        {
            for(int j=1;j&lt;=col;j++)
            {
                sums[i][j] = sums[i-1][j]+sums[i][j-1]+matrix[i-1][j-1]-sums[i-1][j-1];
            }
        }
    }
    
    int sumRegion(int row1, int col1, int row2, int col2) {
        return sums[row2+1][col2+1]-sums[row2+1][col1]-sums[row1][col2+1]+sums[row1][col1];
    }
};

/**
 * Your NumMatrix object will be instantiated and called as such:
 * NumMatrix obj = new NumMatrix(matrix);
 * int param_1 = obj.sumRegion(row1,col1,row2,col2);
 */
</code></pre>

<p><a href="https://leetcode.com/problems/range-sum-query-2d-immutable/description/">题目详细链接</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reshape the Matrix]]></title>
    <link href="https://lockxmonk.github.io/15119406678576.html"/>
    <updated>2017-11-29T15:31:07+08:00</updated>
    <id>https://lockxmonk.github.io/15119406678576.html</id>
    <content type="html"><![CDATA[
<p>In MATLAB, there is a very useful function called &#39;reshape&#39;, which can reshape a matrix into a new one with different size but keep its original data.</p>

<p>You&#39;re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively.</p>

<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were.</p>

<p>If the &#39;reshape&#39; operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>

<p><img src="media/15119406678576/15119406900999.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; nums, int r, int c) {
        int sumNum = nums.size() * nums[0].size();
        int r1 = nums.size();
        int c1 = nums[0].size();
        if (sumNum != r*c) {
            return nums;
        }
        vector&lt;vector&lt;int&gt;&gt; result = vector&lt;vector&lt;int&gt;&gt;(r,vector&lt;int&gt;(c,0));
        int j = 0;
        for (int i =0; i&lt;r*c; i++) {
            result[i/c][i%c] = nums[i/c1][i%c1];
        }
        
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Degree of an Array]]></title>
    <link href="https://lockxmonk.github.io/15114255869932.html"/>
    <updated>2017-11-23T16:26:26+08:00</updated>
    <id>https://lockxmonk.github.io/15114255869932.html</id>
    <content type="html"><![CDATA[
<p>Given a non-empty array of non-negative integers <code>nums</code>, the degree of this array is defined as the maximum frequency of any one of its elements.</p>

<p>Your task is to find the smallest possible length of a (contiguous) subarray of <code>nums</code>, that has the same degree as <code>nums</code>.</p>

<p><img src="media/15114255869932/15114256313220.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int findShortestSubArray(vector&lt;int&gt;&amp; nums) {
        
        if (nums.size()&lt;2) {
            return nums.size();
        }
        unordered_map&lt;int, int&gt;startIndex , number;
        int len = nums.size();
        int fre = 0;
        for (int i=0; i&lt;nums.size(); i++) {
            if (startIndex.count(nums[i])==0) {
                startIndex[nums[i]]=i;
            }
            number[nums[i]]++;
            if (number[nums[i]]==fre) {
                len = min(i-startIndex[nums[i]]+1, len);
            }
            if (number[nums[i]]&gt;fre) {
                len = i - startIndex[nums[i]] + 1;
                fre = number[nums[i]];
            }
        }
        
        return len;
    }
};
</code></pre>

<p>该算法主要使用了两个<code>hash_map</code>:<br/>
一个来记录数字所出现的次数，另一个记录数字最开始出现的位置。一旦有一个数字的频数超过了当前的<code>len</code>，则更新<code>len</code>，若两个数字出现的频率相等则取长度最小的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find Pivot Index]]></title>
    <link href="https://lockxmonk.github.io/15114222067093.html"/>
    <updated>2017-11-23T15:30:06+08:00</updated>
    <id>https://lockxmonk.github.io/15114222067093.html</id>
    <content type="html"><![CDATA[
<p>Given an array of integers <code>nums</code>, write a method that returns the &quot;pivot&quot; index of this array.</p>

<p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p>

<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>

<p><img src="media/15114222067093/15114222397308.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int pivotIndex(vector&lt;int&gt;&amp; nums) {
        
        if(nums.empty()) return -1;
        
        int sum = 0;
        for(int i=0;i&lt;nums.size();i++) sum+=nums[i];
    
        int leftSum = 0;
        for(int j=0;j&lt;nums.size();j++)
        {
            if (leftSum == sum - nums[j] -leftSum) {
                return j;
        }
            leftSum += nums[j];
        }
        
        return -1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Time to Buy and Sell Stock II]]></title>
    <link href="https://lockxmonk.github.io/15114072257756.html"/>
    <updated>2017-11-23T11:20:25+08:00</updated>
    <id>https://lockxmonk.github.io/15114072257756.html</id>
    <content type="html"><![CDATA[
<p>Say you have an array for which the \(i^{th}\) element is the price of a given stock on day i.</p>

<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>

<pre><code class="language-c++">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int result = 0;
        for(int i = 1;i&lt;prices.size();i++)
        {
            result += max(prices[i]-prices[i-1] , 0);
        }
        return result;
    }
};

</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Best Time to Buy and Sell Stock]]></title>
    <link href="https://lockxmonk.github.io/15114062990936.html"/>
    <updated>2017-11-23T11:04:59+08:00</updated>
    <id>https://lockxmonk.github.io/15114062990936.html</id>
    <content type="html"><![CDATA[
<p>Say you have an array for which the \(i^{th}\) element is the price of a given stock on day i.</p>

<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>

<p><img src="media/15114062990936/15114063447573.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int maxProfit(vector&lt;int&gt;&amp; prices) {
        int minPrice=INT_MAX;
        int maxProfit = 0;
        
        for (int i=0; i&lt;prices.size(); i++) {
            minPrice = min(prices[i], minPrice);
            maxProfit = max(maxProfit, prices[i]-minPrice);
        }
        
        return maxProfit;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Array Partition I]]></title>
    <link href="https://lockxmonk.github.io/15114035796843.html"/>
    <updated>2017-11-23T10:19:39+08:00</updated>
    <id>https://lockxmonk.github.io/15114035796843.html</id>
    <content type="html"><![CDATA[
<p>Given an array of <strong>2n</strong> integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), ..., (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>

<p><img src="media/15114035796843/15114036022226.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int arrayPairSum(vector&lt;int&gt;&amp; nums) {
        
        sort(nums.begin(),nums.end());
        int result=0;
        for (int i=0; i&lt;nums.size(); i+=2) {
            result+=nums[i];
        }
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[3Sum]]></title>
    <link href="https://lockxmonk.github.io/15114026353930.html"/>
    <updated>2017-11-23T10:03:55+08:00</updated>
    <id>https://lockxmonk.github.io/15114026353930.html</id>
    <content type="html"><![CDATA[
<p>Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</p>

<p><strong>Note:</strong> The solution set must not contain duplicate triplets.</p>

<p><img src="media/15114026353930/15114026868536.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(),nums.end());
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; tmpResult;
        
        int p,q,tmp;
        for(int i = 0 ;i&lt;nums.size();i++)
        {
            if(i!=0&amp;&amp;nums[i]==nums[i-1]) continue;
            int currentNum = nums[i];
            p = i+1;
            q = nums.size()-1;
            
            while(p&lt;q)
            {
                if(p!=i+1&amp;&amp;nums[p]==nums[p-1])
                {
                    p++;
                    continue;
                }
                tmp = nums[q]+nums[p];
                if(tmp==-currentNum)
                {
                    tmpResult.push_back(currentNum);
                    tmpResult.push_back(nums[q]);
                    tmpResult.push_back(nums[p]);
                    result.push_back(tmpResult);
                    tmpResult.clear();
                    p++;
                    q--;
                }else if (tmp&gt;-currentNum)
                {
                    q--;
                }else p++;
            }
        }
        
        return result;
    }
};
</code></pre>

<p><strong>two real problems .</strong></p>

<ul>
<li><p>how to find the sum?<br/>
change it to a 2 sum problem. when you have one value, the sum of the other two is -value.<br/>
2 sum problem has a O(n) solution. so the final is O(n<sup>2).</sup></p></li>
<li><p>how to remove the duplicate?<br/>
for same values, we only use the first one and pass the rest.</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Arranging Coins]]></title>
    <link href="https://lockxmonk.github.io/15113375347657.html"/>
    <updated>2017-11-22T15:58:54+08:00</updated>
    <id>https://lockxmonk.github.io/15113375347657.html</id>
    <content type="html"><![CDATA[
<p>You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.</p>

<p>Given n, find the total number of full staircase rows that can be formed.</p>

<p>n is a non-negative integer and fits within the range of a 32-bit signed integer.</p>

<p><img src="media/15113375347657/15113375557158.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int arrangeCoins(int n) {
        return floor(-0.5+sqrt((double)2*n+0.25));
    }
};
</code></pre>

<p>这道题的主要考虑<code>1+2+3+...+x&lt;=n</code>下，使x左边等式最接近n，并且不超过。</p>

<p>推导为：</p>

<pre><code>-&gt; 1+2+3+...+x = n
-&gt; (1+x)x/2 = n
-&gt; x^2+x = 2n
-&gt; x^2+x+1/4 = 2n +1/4
-&gt; (x+1/2)^2 = 2n +1/4
-&gt; (x+0.5) = sqrt(2n+0.25)
-&gt; x = -0.5 + sqrt(2n+0.25)
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Add Binary]]></title>
    <link href="https://lockxmonk.github.io/15113344881540.html"/>
    <updated>2017-11-22T15:08:08+08:00</updated>
    <id>https://lockxmonk.github.io/15113344881540.html</id>
    <content type="html"><![CDATA[
<p>Given two binary strings, return their sum (also a binary string).</p>

<p>For example,<br/>
a = <code>&quot;11&quot;</code><br/>
b = <code>&quot;1&quot;</code><br/>
Return <code>&quot;100&quot;</code>.</p>

<pre><code class="language-c++">class Solution {
public:
    string addBinary(string a, string b) {
        int fw = 0;
        string result = &quot;&quot;;
        for(int i = a.size()-1,j=b.size()-1;i&gt;=0||j&gt;=0;i--,j--){
            int ag = i&gt;=0?a[i]-&#39;0&#39;:0;
            int bg = j&gt;=0?b[j]-&#39;0&#39;:0;
            int tmp = (ag+bg+fw)%2;
            fw = (ag+bg+fw)/2;
            
            result = char(tmp+&#39;0&#39;)+result;
        }
        if(fw==1){
            result = &#39;1&#39;+result;
        }
        
        return result;
    }
};
</code></pre>

]]></content>
  </entry>
  
</feed>
