<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2017-05-04T10:08:44+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[分布式进程]]></title>
    <link href="https://lockxmonk.github.io/14938608177246.html"/>
    <updated>2017-05-04T09:20:17+08:00</updated>
    <id>https://lockxmonk.github.io/14938608177246.html</id>
    <content type="html"><![CDATA[
<p>在Thread和Process中，应当优选Process，<font color=red><strong>因为Process更稳定，而且，Process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</strong></font></p>

<p><strong>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。</strong><font color=red>一个服务进程可以作为调度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</font></p>

<p>举个例子：如果我们<strong>已经有一个通过<code>Queue</code>通信的多进程程序在同一台机器上运行</strong>，现在，由于处理任务的进程任务繁重，希望把发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p>

<p>原有的<code>Queue</code>可以继续使用，<font color=red>但是，通过<code>managers</code>模块把<code>Queue</code>通过网络暴露出去，就可以让其他机器的进程访问<code>Queue</code>了。</font></p>

<p>我们先看服务进程，服务进程负责启动<code>Queue</code>，把<code>Queue</code>注册到网络上，然后往<code>Queue</code>里面写入任务：</p>

<pre><code class="language-py">#taskmanager.py
#-*- coding: utf-8 -*-

import random,time,Queue
from multiprocessing.managers import BaseManager

#发送任务的队列
task_queue = Queue.Queue()
#接受结果的队列
result_queue = Queue.Queue()

#从BaseManager继承的QueueManager:
class QueueManager(BaseManager):
    pass

#把两个Queue都注册到网络上, callable参数关联了Queue对象:
QueueManager.register(&#39;get_task_queue&#39;,callable=lambda:task_queue)
QueueManager.register(&#39;get_result_queue&#39;,callable=lambda:result_queue)

#绑定端口5000，设置验证码‘abc’：
manager = QueueManager(address=(&#39;&#39;,5000),authkey=&#39;abc&#39;)
#启动Queue
manager.start()
# 获得通过网络访问的Queue对象:
task = manager.get_task_queue()
result = manager.get_result_queue()
#放几个任务进去
for i in range(10):
    n = random.randint(0, 10000)
    print(&#39;Put task %d...&#39; %n)
    task.put(n)

#从result队列读取结果
print(&#39;Try get results...&#39;)
for i in range(10):
    r = result.get(timeout=10)
    print(&#39;Result:%s&#39;%r)
#关闭
manager.shutdown()
</code></pre>

<p>请注意，当我们在一台机器上写多进程程序时，创建的<code>Queue</code>可以直接拿来用，但是，在分布式多进程环境下，添加任务到<code>Queue</code>不可以直接对原始的<code>task_queue</code>进行操作，那样就绕过了<code>QueueManager</code>的封装，必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加。</p>

<p>然后，在另一台机器上启动任务进程（本机上启动也可以）：</p>

<pre><code class="language-py">#taskworker.py
#-*- coding: utf-8 -*-

import time
import sys
import Queue
from multiprocessing.managers import BaseManager

# 创建类似的QueueManager:


class QueueManager(BaseManager):
    pass

# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:
QueueManager.register(&#39;get_task_queue&#39;)
QueueManager.register(&#39;get_result_queue&#39;)

# 连接到服务器，也就是运行taskmanager.py的机器:
server_addr = &#39;127.0.0.1&#39;
print(&#39;Connect to server %s...&#39; % server_addr)

# 端口和验证码注意保持与taskmanager.py设置的完全一致:
m = QueueManager(address=(server_addr, 5000), authkey=&#39;abc&#39;)
# 从网络连接:
m.connect()
# 获取Queue的对象:
task = m.get_task_queue()
result = m.get_result_queue()
# 从task队列取任务,并把结果写入result队列:
for i in range(10):
    try:
        n = task.get(timeout=1)
        print(&#39;run task %d * %d...&#39; % (n, n))
        r = &#39;%d * %d = %d&#39; % (n, n, n * n)
        time.sleep(1)
        result.put(r)
    except Queue.Empty:
        print(&#39;task queue is empty.&#39;)
# 处理结束:
print(&#39;worker exit.&#39;)
</code></pre>

<p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p>

<p>现在，可以试试分布式进程的工作效果了。先启动<code>taskmanager.py</code>服务进程：</p>

<p>启动后：<br/>
<img src="media/14938608177246/14938633989382.jpg" alt=""/><br/>
等待result队列中的值。（目前为空)</p>

<p><code>taskmanager</code>进程发送完任务后，开始等待<code>result</code>队列的结果。现在启动<code>taskworker.py</code>进程：</p>

<p><img src="media/14938608177246/14938634594880.jpg" alt=""/></p>

<p><code>taskworker</code>进程结束，在<code>taskmanager</code>进程中会继续打印出结果：</p>

<p><img src="media/14938608177246/14938634810692.jpg" alt=""/></p>

<p>这个简单的<code>Manager/Worker</code>模型有什么用？<font color=red><strong>其实这就是一个简单但真正的分布式计算</strong></font>，把代码稍加改造，启动多个worker，就可以把任务分布到几台甚至几十台机器上，比如把计算<code>n*n</code>的代码换成发送邮件，就实现了邮件队列的异步发送。</p>

<p>Queue对象存储在哪？注意到<code>taskworker.py</code>中根本没有创建<code>Queue</code>的代码，所以，Queue对象存储在<code>taskmanager.py</code>进程中：</p>

<p><img src="media/14938608177246/14938635737718.jpg" alt=""/></p>

<p>而<code>Queue</code>之所以能通过网络访问，就是通过<code>QueueManager</code>实现的。由于<code>QueueManager</code>管理的不止一个<code>Queue</code>，所以，要给每个<code>Queue</code>的网络调用接口起个名字，比如<code>get_task_queue</code>。</p>

<p><code>authkey</code>有什么用？这是为了保证两台机器正常通信，不被其他机器恶意干扰。如果<code>taskworker.py</code>的<code>authkey</code>和<code>taskmanager.py</code>的<code>authkey</code>不一致，肯定连接不上。</p>

<h2 id="toc_0">小结</h2>

<p>Python的分布式进程接口简单，封装良好，适合需要把繁重任务分布到多台机器的环境下。</p>

<p><font color=red>注意Queue的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</font></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[进程与线程]]></title>
    <link href="https://lockxmonk.github.io/14938589289379.html"/>
    <updated>2017-05-04T08:48:48+08:00</updated>
    <id>https://lockxmonk.github.io/14938589289379.html</id>
    <content type="html"><![CDATA[
<p>我们已经熟悉多线程与多进程。他们各有优点与缺点，这里我们简单的说明一下：</p>

<p>首先，要实现多任务，<font color=red>通常我们会设计Master-Worker模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</font></p>

<p><strong>如果用多进程实现Master-Worker，主进程就是Master，其他进程就是Worker。</strong></p>

<p><strong>如果用多线程实现Master-Worker，主线程就是Master，其他线程就是Worker。</strong></p>

<p>多进程模式最大的优点就是<strong>稳定性高</strong>，因为一个子进程崩溃了，不会影响主进程和其他子进程。（<strong>当然主进程挂了所有进程就全挂了，但是Master进程只负责分配任务，挂掉的概率低</strong>）著名的Apache最早就是采用多进程模式。</p>

<p>多进程模式的<font color=red>缺点是创建进程的代价大</font>，在Unix/Linux系统下，用fork调用还行，在Windows下创建进程开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都会成问题。</p>

<p>多线程模式通常比多进程快一点，但是也快不到哪去，而且，<font color=red>多线程模式致命的缺点就是任何一个线程挂掉都可能直接造成整个进程崩溃，因为所有线程共享进程的内存。</font>在Windows上，如果一个线程执行的代码出了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作系统会强制结束整个进程。</p>

<p>在Windows下，多线程的效率比多进程要高，所以微软的IIS服务器默认采用多线程模式。由于多线程存在稳定性的问题，IIS的稳定性就不如Apache。为了缓解这个问题，IIS和Apache现在又有多进程+多线程的混合模式，真是把问题越搞越复杂。</p>

<h2 id="toc_0">线程切换</h2>

<p>无论是多进程还是多线程，只要数量一多，<strong>效率肯定上不去</strong>，为什么呢？</p>

<p>因为多任务的执行，需要线程或进程的切换，<strong>操作系统在切换时会先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。</strong>这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。</p>

<p><strong>所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果效率急剧下降，所有任务都做不好。</strong></p>

<h2 id="toc_1">计算密集型和IO密集型</h2>

<p>是否采用多任务的第二个考虑是任务的类型。我们可以把任务分为<font color=red><strong>计算密集型和IO密集型。</strong></font></p>

<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。<font color=red><strong>这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</strong></font></p>

<p>计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。<strong>Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</strong></p>

<p>第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。<font color=red><strong>对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</strong></font></p>

<p>IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。<strong>对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</strong></p>

<h2 id="toc_2">异步IO</h2>

<p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程中大部分时间都在等待IO操作，<strong>单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</strong></p>

<blockquote>
<p><strong>使用了异步IO，在发起IO请求到实际使用数据这段时间 内，程序还可以继续做其他事情。</strong></p>
</blockquote>

<p>现代操作系统对IO操作已经做了巨大的改进，最大的特点就是支持异步IO。如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，<strong>Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。</strong>在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常高效。用异步IO编程模型来实现多任务是一个主要的趋势。</p>

<p><font color=red><strong>对应到Python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。我们会在后面学习如何编写协程。</strong></font></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThreadLocal]]></title>
    <link href="https://lockxmonk.github.io/14937814533169.html"/>
    <updated>2017-05-03T11:17:33+08:00</updated>
    <id>https://lockxmonk.github.io/14937814533169.html</id>
    <content type="html"><![CDATA[
<p>在多线程环境下，每个线程都有自己的数据。<strong>一个线程使用自己的局部变量比使用全局变量好，因为局部变量只有线程自己能看见，不会影响其他线程，而全局变量的修改必须加锁。</strong></p>

<p>但是局部变量也有问题，就是在函数调用的时候，传递起来很麻烦：</p>

<pre><code class="language-py">def process_student(name):
    std = Student(name)
    # std是局部变量，但是每个函数都要用它，因此必须传进去：
    do_task_1(std)
    do_task_2(std)

def do_task_1(std):
    do_subtask_1(std)
    do_subtask_2(std)

def do_task_2(std):
    do_subtask_2(std)
    do_subtask_2(std)
</code></pre>

<p>每个函数一层一层调用都这么传参数那还得了？用全局变量？也不行，因为每个线程处理不同的<code>Student</code>对象，不能共享。</p>

<p>如果用一个全局<code>dict</code>存放所有的<code>Student</code>对象，然后以<code>thread</code>自身作为<code>key</code>获得线程对应的<code>Student</code>对象如何？</p>

<pre><code class="language-py">global_dict = {}

def std_thread(name):
    std = Student(name)
    # 把std放到全局变量global_dict中：
    global_dict[threading.current_thread()] = std
    do_task_1()
    do_task_2()

def do_task_1():
    # 不传入std，而是根据当前线程查找：
    std = global_dict[threading.current_thread()]
    ...

def do_task_2():
    # 任何函数都可以查找出当前线程的std变量：
    std = global_dict[threading.current_thread()]
    ...
</code></pre>

<p>这种方式理论上是可行的，它最大的优点是消除了<code>std</code>对象在每层函数中的传递问题，但是，每个函数获取<code>std</code>的代码有点丑。</p>

<p>有没有更简单的方式？</p>

<p><code>ThreadLocal</code>应运而生，不用查找<code>dict</code>，<code>ThreadLocal</code>帮你自动做这件事：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import threading

# 创建全局ThreadLocal对象
local_school = threading.local()


def process_student():
    print &#39;Hello,%s(in %s)&#39; % (local_school.student, threading.current_thread().name)


def process_thread(name):
    # 绑定ThreadLocal的stutent：
    local_school.student = name
    process_student()

t1 = threading.Thread(target=process_thread, args=(&#39;Alice&#39;,), name=&#39;Thread-A&#39;)
t2 = threading.Thread(target=process_thread, args=(&#39;Bobs&#39;,), name=&#39;Thread-B&#39;)
t1.start()
t2.start()
t1.join()
t2.join()
</code></pre>

<p><img src="media/14937814533169/14937825491356.jpg" alt=""/></p>

<p>全局变量<code>local_school</code>就是一个<code>ThreadLocal</code>对象，每个<code>Thread</code>对它都可以读写<code>student</code>属性，但互不影响。你可以把<code>local_school</code>看成全局变量，但每个属性如<code>local_school.student</code>都是线程的局部变量，可以任意读写而互不干扰，也不用管理锁的问题，<code>ThreadLocal</code>内部会处理。</p>

<p>可以理解为全局变量<code>local_school</code>是一个dict，不但可以用<code>local_school.student</code>，还可以绑定其他变量，如<code>local_school.teacher</code>等等。</p>

<p><font color=red><strong><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</strong><br/>
</font></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程]]></title>
    <link href="https://lockxmonk.github.io/14936919183368.html"/>
    <updated>2017-05-02T10:25:18+08:00</updated>
    <id>https://lockxmonk.github.io/14936919183368.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">Lock</a>
</li>
<li>
<a href="#toc_1">小结</a>
</li>
</ul>


<p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p>

<p>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。</p>

<p>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p>

<p>Python的标准库提供了两个模块：<code>thread</code>和<code>threading</code>，<code>thread</code>是低级模块，<code>threading</code>是高级模块，对<code>thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>

<p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import time,threading

#新线程执行的代码
def loop():
    print &#39;thread %s is running...&#39; % threading.current_thread().name
    n = 0
    while n&lt;5:
        n = n+1
        print &#39;thread %s &gt;&gt;&gt; %s&#39; %(threading.current_thread().name,n)
        time.sleep(1)
    print &#39;thread %s ended.&#39; %threading.current_thread().name

print &#39;thread %s is running...&#39; % threading.current_thread().name
t= threading.Thread(target=loop,name=&#39;LoopThread&#39;)
t.start()
t.join()
print &#39;thread %s ended.&#39; % threading.current_thread().name
</code></pre>

<p><img src="media/14936919183368/14936948712548.jpg" alt=""/></p>

<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1，Thread-2……</code></p>

<h2 id="toc_0">Lock</h2>

<p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，<strong>而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</strong></p>

<p>来看看多个线程同时操作一个变量怎么把内容给改乱了：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import time,threading

# 假定这是你的银行存款:
balance = 0

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print balance
</code></pre>

<p><img src="media/14936919183368/14936957737021.jpg" alt=""/><br/>
结果为<code>14</code>而不是<code>0</code></p>

<p>我们定义了一个共享变量<code>balance</code>，初始值为0，并且启动两个线程，先存后取，理论上结果应该为0，但是，由于线程的调度是由操作系统决定的，当<code>t1、t2</code>交替执行时，只要循环次数足够多，<code>balance</code>的结果就不一定是0了。</p>

<p>我们为了得到准确的结果，在某个线程正在修改<code>balance</code>时就要为该线程上一把锁，直到锁释放，其它线程继续执行。创建一个锁就是通过<code>threading.Lock()</code>来实现：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import time,threading

# 假定这是你的银行存款:
balance = 0
lock=threading.Lock()

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        #先获取锁
        lock.acquire()
        try:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()
        
t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print balance
</code></pre>

<p><img src="media/14936919183368/14937055756329.jpg" alt=""/></p>

<p>当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p>

<p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p>

<h2 id="toc_1">小结</h2>

<p>多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。</p>

<p><strong>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦</strong></p>

<p><font color=red>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。<br/>
</font></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[进程和线程]]></title>
    <link href="https://lockxmonk.github.io/14936863062791.html"/>
    <updated>2017-05-02T08:51:46+08:00</updated>
    <id>https://lockxmonk.github.io/14936863062791.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">多进程</a>
</li>
<li>
<a href="#toc_1">multiprocessing</a>
</li>
<li>
<a href="#toc_2">Pool</a>
</li>
<li>
<a href="#toc_3">进程间通信</a>
<ul>
<li>
<a href="#toc_4">小结</a>
</li>
</ul>
</li>
</ul>


<p>我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办</p>

<p>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</p>

<p><strong>还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</strong></p>

<p>当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</p>

<p>总结一下就是，多任务的实现有3种方式：</p>

<ul>
<li>多进程模式；</li>
<li>多线程模式；</li>
<li>多进程+多线程模式。</li>
</ul>

<blockquote>
<p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
</blockquote>

<h2 id="toc_0">多进程</h2>

<p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code><font color=red>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回</font>。</p>

<p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p>

<p>Python的<code>os</code>模块封装了常见的系统调用，其中就包括<code>fork</code>，可以在Python程序中轻松创建子进程：</p>

<pre><code class="language-py">import os

print &#39;Process (%s) start&#39; %os.getpid()

pid = os.fork()
if pid == 0:
    print &#39;I am child process (%s) and my parent is %s.&#39; %(os.getpid(),os.getppid())
else:
    print &#39;I (%s) just created a child process (%s)&#39; %(os.getpid(),pid)
</code></pre>

<p><img src="media/14936863062791/14936874189758.jpg" alt=""/></p>

<p>第一次返回父进程，第二次返回子进程。所以分别打印出了不同的结果。</p>

<p>有了<code>fork</code>调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p>

<h2 id="toc_1">multiprocessing</h2>

<p>如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没有<code>fork</code>调用，难道在Windows上无法用Python编写多进程的程序？</p>

<p>由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。<code>multiprocessing</code>模块就是跨平台版本的多进程模块。</p>

<p><code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
from multiprocessing import Process

import os

# 子进程要执行的代码


def run_proc(name):
    print &#39;Run child process %s(%s)&#39; % (name, os.getpid())

if __name__ == &#39;__main__&#39;:
    print &#39;Parent process %s.&#39; % os.getpid()
p = Process(target=run_proc, args=(&#39;test&#39;,))
print &#39;Process will start.&#39;
p.start()
p.join()
print &#39;Process end&#39;
</code></pre>

<p><img src="media/14936863062791/14936889041171.jpg" alt=""/></p>

<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p>

<p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>

<h2 id="toc_2">Pool</h2>

<p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>

<pre><code class="language-py">from multiprocessing import Pool
import os
import time
import random


def long_time_task(name):
    print &#39;Run task %s(%s)...&#39; % (name, os.getpid())
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print &#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start))

if __name__ == &#39;__main__&#39;:
    print &#39;Parent process %s.&#39; % os.getpid()
    p = Pool()
    for i in range(9):
        p.apply_async(long_time_task, args=(i,))
    print &#39;Waiting for all subprocesses done...&#39;
    p.close()
    p.join()
    print &#39;All subprocess done&#39;
</code></pre>

<p><img src="media/14936863062791/14936904615182.jpg" alt=""/></p>

<p>代码解读：</p>

<p>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p>

<p>请注意输出的结果，task 0~7是立刻执行的，而task 8要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是8，因此，最多同时执行8个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：<code>p = Pool(9)</code></p>

<p>就可以同时跑9个进程。</p>

<p>由于Pool的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p>

<h2 id="toc_3">进程间通信</h2>

<p><code>Process</code>之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p>

<p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

from multiprocessing import Process,Queue
import os,time,random

#写数据进程执行的代码
def write(q):
    for value in [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;]:
        print &#39;Put %s to quene...&#39; % value
        q.put(value)
        time.sleep(random.random())
#读数据进程执行的代码
def read(q):
    while True:
        value = q.get(True)
        print &#39;Get %s from quene.&#39; %value

if __name__==&#39;__main__&#39;:
    #父进程创建Quene,并传给各个子进程：
    q = Queue()
    pw = Process(target=write,args=(q,))
    pr = Process(target=read,args=(q,))
    #启动子进程pw，写入：
    pw.start()
    #启动子进程pr，读取：
    pr.start()
    #等待pw结束：
    pw.join()
    #pr进程里是死循环，无法等待其结束，只能强行终止：
    pr.terminate()

</code></pre>

<p><img src="media/14936863062791/14936917220576.jpg" alt=""/></p>

<p>在Unix/Linux下，<code>multiprocessing</code>模块封装了<code>fork()</code>调用，使我们不需要关注<code>fork()</code>的细节。由于Windows没有fork调用，因此，<code>multiprocessing</code>需要“模拟”出fork的效果，父进程所有Python对象都必须通过<code>pickle</code>序列化再传到子进程去，所有，如果<code>multiprocessing</code>在Windows下调用失败了，要先考虑是不是pickle失败了。</p>

<h3 id="toc_4">小结</h3>

<p>在Unix/Linux下，可以使用<code>fork()</code>调用实现多进程。</p>

<p>要实现跨平台的多进程，可以使用<code>multiprocessing</code>模块。</p>

<p>进程间通信是通过<code>Queue、Pipes</code>等实现的。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[序列化]]></title>
    <link href="https://lockxmonk.github.io/14933396433742.html"/>
    <updated>2017-04-28T08:34:03+08:00</updated>
    <id>https://lockxmonk.github.io/14933396433742.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">JSON</a>
</li>
<li>
<a href="#toc_1">JSON进阶</a>
</li>
<li>
<a href="#toc_2">小结</a>
</li>
</ul>


<p><strong>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</strong></p>

<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>

<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>

<p>Python提供两个模块来实现序列化：<code>cPickle</code>和<code>pickle</code>。这两个模块功能是一样的，区别在于<code>cPickle</code>是C语言写的，速度快，<code>pickle</code>是纯Python写的，速度慢，跟<code>cStringIO和StringIO</code>一个道理。用的时候，先尝试导入<code>cPickle</code>，如果失败，再导入<code>pickle</code>：</p>

<pre><code class="language-py">try:
    import cPickle as pickle
except ImportError:
    import pickle
</code></pre>

<p>我们尝试把一个对象序列化并写入文件：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

d = dict(name=&#39;LZH&#39;,age=20,score=88)
print pickle.dumps(d)
</code></pre>

<p><img src="media/14933396433742/14933403797179.jpg" alt=""/></p>

<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>str</code>，然后，就可以把这个<code>str</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

d = dict(name=&#39;梁中豪&#39;,age=20,score=88)
f = open(&#39;test.txt&#39;,&#39;wb&#39;)  
pickle.dump(d,f)
f.close

</code></pre>

<p><img src="media/14933396433742/14933405542811.jpg" alt=""/></p>

<p>我们可以读取文件中这些内容，并且将他们反序列化来显示原来的内容：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

#d = dict(name=&#39;梁中豪&#39;,age=20,score=88)
f = open(&#39;test.txt&#39;,&#39;rb&#39;)  
print pickle.load(f)
f.close

</code></pre>

<p>可以先把内容读到一个<code>str</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象</p>

<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>

<p>下面我们用JSON来进行网络间的数据传递。</p>

<h2 id="toc_0">JSON</h2>

<p>如果我们要在不同的编程语言之间传递对象，<strong>就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串</strong>，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>

<p><strong><code>JSON</code>表示的对象就是标准的<code>JavaScript</code>语言的对象，<code>JSON</code>和Python内置的数据类型对应如下：</strong></p>

<table>
<thead>
<tr>
<th>Json类型</th>
<th>Python类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>{}</td>
<td>dict</td>
</tr>
<tr>
<td>[]</td>
<td>list</td>
</tr>
<tr>
<td>string</td>
<td>str或u&#39;unicode&#39;</td>
</tr>
<tr>
<td>12345.56</td>
<td>int或float</td>
</tr>
<tr>
<td>true/false</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody>
</table>

<p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</p>

<pre><code class="language-py">import json
d = dict(name=&#39;Lichao&#39;, age=20, score=88)
print json.dumps(d)

</code></pre>

<p><img src="media/14933396433742/14933496188910.jpg" alt=""/></p>

<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的JSON。类似的，<code>dump()</code>方法可以直接把JSON写入一个<code>file-like Object</code>。</p>

<p>要把JSON反序列化为Python对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把JSON的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>

<pre><code class="language-py">import json
json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Lichao&quot;}&#39;
print json.loads(json_str)
</code></pre>

<p><img src="media/14933396433742/14933497889867.jpg" alt=""/></p>

<p>有一点需要注意，就是反序列化得到的所有字符串对象默认都是<code>unicode</code>而不是<code>str</code>。由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的<code>str或unicode</code>与JSON的字符串之间转换。</p>

<h2 id="toc_1">JSON进阶</h2>

<p>Python的<code>dict</code>对象可以直接序列化为JSON的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p>

<pre><code class="language-py">import json


class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;LiChao&#39;, 20, 88)
print(json.dumps(s))
</code></pre>

<p><img src="media/14933396433742/14933605238135.jpg" alt=""/><br/>
向上述那样调用，会报错，因为<code>Student</code>对象不是一个可序列化为JSON的对象。</p>

<p>我们仔细看看<code>dumps()</code>方法的参数列表，可以发现，除了第一个必须的<code>obj</code>参数外，<code>dumps()</code>方法还提供了一大堆的可选参数。</p>

<p>这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把<code>Student</code>类实例序列化为JSON，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个JSON的<code>{}</code>对象。</p>

<p>可选参数<code>default</code>就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p>

<pre><code class="language-py">import json

def student2dict(std):
    return {
    &#39;name&#39;:std.name,
    &#39;age&#39;:std.age,
    &#39;score&#39;:std.score
    }

class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;LiChao&#39;, 20, 88)
print(json.dumps(s,default=student2dict))
</code></pre>

<p><img src="media/14933396433742/14933609788679.jpg" alt=""/></p>

<p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为<code>JSON</code>。</p>

<p><strong>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为<code>JSON</code>。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</strong></p>

<pre><code class="language-py">print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>

<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p>

<p>同样的道理，如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个dict对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p>

<pre><code class="language-py">import json

def dict2students(d):
    return Student(d[&#39;name&#39;],d[&#39;age&#39;],d[&#39;score&#39;])

class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;
print(json.loads(json_str,object_hook=dict2students))
</code></pre>

<p><img src="media/14933396433742/14933619206509.jpg" alt=""/></p>

<p>打印出的是反序列化的<code>Student</code>实例对象。</p>

<h2 id="toc_2">小结</h2>

<p>Python语言特定的序列化模块是<code>pickle</code>，但如果要把序列化搞得更通用、更符合Web标准，就可以使用<code>json</code>模块。</p>

<p><code>json</code>模块的<code>dumps()和loads()</code>函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[操作文件和目录]]></title>
    <link href="https://lockxmonk.github.io/14932778418691.html"/>
    <updated>2017-04-27T15:24:01+08:00</updated>
    <id>https://lockxmonk.github.io/14932778418691.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">环境变量</a>
</li>
<li>
<a href="#toc_1">操作文件和目录</a>
</li>
<li>
<a href="#toc_2">小结</a>
</li>
<li>
<a href="#toc_3">练习：</a>
</li>
</ul>


<p>如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如<code>dir</code>、<code>cp</code>等命令</p>

<p>Python内置的<code>os</code>模块也可以直接调用操作系统提供的接口函数。</p>

<p>打开Python交互式命令行，我们来看看如何使用<code>os</code>模块的基本功能：</p>

<p><img src="media/14932778418691/14932780434722.jpg" alt=""/></p>

<p>注意<code>uname()</code>函数在Windows上不提供，也就是说，os模块的某些函数是跟操作系统相关的。</p>

<h2 id="toc_0">环境变量</h2>

<p>在操作系统中定义的环境变量，全部保存在<code>os.environ</code>这个<code>dict</code>中，可以直接查看：<br/>
<img src="media/14932778418691/14932785335515.jpg" alt=""/></p>

<p>要获取某个环境变量的值，可以调用<code>os.getenv()</code>函数：</p>

<p><img src="media/14932778418691/14932786096064.jpg" alt=""/></p>

<h2 id="toc_1">操作文件和目录</h2>

<p>操作文件和目录的函数一部分放在os模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print os.path.abspath(&#39;.&#39;)
print os.path.join(&#39;/Users/liangzhonghao/Desktop/&#39;,&#39;test&#39;)

#os.mkdir(&#39;/Users/liangzhonghao/Desktop/python&#39;)
os.rmdir(&#39;/Users/liangzhonghao/Desktop/python&#39;)
</code></pre>

<p><img src="media/14932778418691/14932791801381.jpg" alt=""/></p>

<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print os.path.splitext(&#39;/Users/liangzhonghao/Desktop/text.txt&#39;)
</code></pre>

<p><img src="media/14932778418691/14932792804815.jpg" alt=""/></p>

<p><strong>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</strong></p>

<p><code>os</code>模块有很多功能，例如重命名文件，删除文件。但是他没有复制文件的功能。因为复制文件并非是由操作系统提供的系统调用。</p>

<p>幸运的是<code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p>

<p><strong>最后看看如何利用Python的特性来过滤文件</strong>。比如我们要列出当前目录下的所有目录，只需要一行代码：</p>

<pre><code class="language-py">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]
</code></pre>

<p><img src="media/14932778418691/14932797710625.jpg" alt=""/></p>

<p>要列出所有的.py文件，也只需一行代码：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#39;.py&#39;]
</code></pre>

<p><img src="media/14932778418691/14932798281538.jpg" alt=""/></p>

<h2 id="toc_2">小结</h2>

<p>Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在<code>os.path</code>模块中</p>

<h2 id="toc_3">练习：</h2>

<p>编写一个<code>search(s)</code>的函数，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出完整路径：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os

def search(s ,dir=os.path.abspath(&#39;.&#39;)):
    for x in os.listdir(dir):
        path = os.path.join(dir,x)
        if s in x:
            print path
        elif os.path.isdir(path):
            search(s,path)

search(&#39;pr&#39;)

</code></pre>

<p><img src="media/14932778418691/14932810251430.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[I/O编程]]></title>
    <link href="https://lockxmonk.github.io/14932734930436.html"/>
    <updated>2017-04-27T14:11:33+08:00</updated>
    <id>https://lockxmonk.github.io/14932734930436.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">文件读写</a>
<ul>
<li>
<a href="#toc_1">读文件</a>
</li>
<li>
<a href="#toc_2">file-like Object</a>
</li>
<li>
<a href="#toc_3">二进制文件</a>
</li>
<li>
<a href="#toc_4">写文件</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">小结</a>
</li>
</ul>


<h2 id="toc_0">文件读写</h2>

<h3 id="toc_1">读文件</h3>

<p>要以读文件的模式来打开一个文件对象，使用Python内置的<code>open（）</code>函数，传入文件名和标识符：</p>

<pre><code class="language-py">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)
</code></pre>

<p>标示符&#39;r&#39;表示读，这样，我们就成功地打开了一个文件。</p>

<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：<br/>
<img src="media/14932734930436/14932737513488.jpg" alt=""/></p>

<p>如果文件打开成功，接下来，调用<code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，用一个<code>str</code>对象表示：<br/>
<img src="media/14932734930436/14932741526772.jpg" alt=""/></p>

<p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现。这种方法太麻烦。我们这里使用python所提供的方法：</p>

<p>Python引入了with语句来自动帮我们调用<code>close()</code>方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;r&#39;) as f:
    print f.read()
</code></pre>

<p><img src="media/14932734930436/14932743740546.jpg" alt=""/></p>

<p>这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p>

<p>调用<code>read()</code>会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取<code>size</code>个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p>

<p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;r&#39;) as f:
    for line in f.readlines():
        print(line.strip())  #把末尾的&#39;\n&#39;删掉
</code></pre>

<p><img src="media/14932734930436/14932746986776.jpg" alt=""/></p>

<h3 id="toc_2">file-like Object</h3>

<p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。</p>

<p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p>

<h3 id="toc_3">二进制文件</h3>

<p>前面讲的默认都是读取文本文件，并且是ASCII编码的文本文件。要读取二进制文件，比如图片、视频等等，用<code>rb</code>模式打开文件即可：<br/>
<img src="media/14932734930436/14932760233490.jpg" alt=""/></p>

<h3 id="toc_4">写文件</h3>

<p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p>

<pre><code class="language-py">&gt;&gt;&gt; f = open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;, &#39;w&#39;)
&gt;&gt;&gt; f.write(&#39;Hello, world!Again！&#39;)
&gt;&gt;&gt; f.close()
</code></pre>

<p>这里推荐直接调用with方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;w&#39;) as f:
    f.write(&#39;Hello, world!Again!&#39;)
</code></pre>

<p><img src="media/14932734930436/14932763793296.jpg" alt=""/></p>

<p><font color=red><strong>要注意的是一旦写入文件，原来文件中的内容会被删除！</strong></font></p>

<h2 id="toc_5">小结</h2>

<p>在Python中，文件读写是通过<code>open()</code>函数打开的文件对象完成的。使用<code>with</code>语句操作文件IO是个好习惯。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文档测试]]></title>
    <link href="https://lockxmonk.github.io/14932622908500.html"/>
    <updated>2017-04-27T11:04:50+08:00</updated>
    <id>https://lockxmonk.github.io/14932622908500.html</id>
    <content type="html"><![CDATA[
<p><strong>在python中我们可以执行那些在注释中的代码，来进行测试。</strong></p>

<p>当我们编写注释时，如果写上这样的注释：</p>

<pre><code class="language-py">def abs(n):
    &#39;&#39;&#39;
    Function to get absolute value of number.

    Example:

    &gt;&gt;&gt; abs(1)
    1
    &gt;&gt;&gt; abs(-1)
    1
    &gt;&gt;&gt; abs(0)
    0
    &#39;&#39;&#39;
    return n if n &gt;= 0 else (-n)
</code></pre>

<p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p>

<p><strong>并且，Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</strong></p>

<p><font color=red>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用...表示中间一大段烦人的输出。</font></p>

<p>让我们用doctest来测试上次编写的<code>Dict</code>类：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Dict(dict):
    
    &quot;&quot;&quot;
    Simple dict but also support access as x.y style

    &gt;&gt;&gt; d1 = Dict()
    &gt;&gt;&gt; d1[&#39;x&#39;] = 100
    &gt;&gt;&gt; d1.x
    100
    &gt;&gt;&gt; d1.y = 200
    &gt;&gt;&gt; d1[&#39;y&#39;]
    200
    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#39;3&#39;)
    &gt;&gt;&gt; d2.c
    &#39;3&#39;
    &gt;&gt;&gt; d2[&#39;empty&#39;]
    Traceback (most recent call last):
        ...
    KeyError: &#39;empty&#39;
    &gt;&gt;&gt; d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: &#39;Dict&#39; object has no attribute &#39;empty&#39;
    
    &quot;&quot;&quot;
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)
    def __getattr__(self,key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)
        else:
            pass
        finally:
            pass
    def __setattr__(self,key,value):
        self[key] = value
if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod()
</code></pre>

<p>如果什么输出都没有，说明我们编写的<code>doctest</code>运行都是正确的。<br/>
<img src="media/14932622908500/14932639594028.jpg" alt=""/><br/>
如果我们把</p>

<pre><code class="language-py">&gt;&gt;&gt; d2.c
    &#39;4&#39; #3改成4
</code></pre>

<p>运行后就会显示：</p>

<p><img src="media/14932622908500/14932640459265.jpg" alt=""/></p>

<p><strong>注意到最后两行代码。当模块正常导入时，doctest不会被执行。只有在命令行运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图像去雾相关论文总结]]></title>
    <link href="https://lockxmonk.github.io/14932573311953.html"/>
    <updated>2017-04-27T09:42:11+08:00</updated>
    <id>https://lockxmonk.github.io/14932573311953.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">1.特征学习的单幅图像去雾算法 2016年</a>
</li>
</ul>
</li>
<li>
<a href="#toc_1">2.尺度自适应暗通道先验去雾方法</a>


<h2 id="toc_0">1.特征学习的单幅图像去雾算法 2016年</h2>

<p><strong>目的：</strong>为提高图像去雾的普适性，提出一种特征学习的单幅图像去雾方法。</p>

<p><strong>方法：</strong>通过稀疏自动编码机对有雾图像进行<strong>多尺度的纹理结构特征提取</strong>，同时抽取各种与雾相关的颜色特征。然后采用多层神经网络进行样本训练，得到雾天条件下纹理结构特征及颜色特征与场景深度间的映射关系，并估算出有雾图像的场景深度图。最后结合大气散射模型，根据场景深度图复原无雾图像。</p>

<p><strong>结论：对实验结果的定性及定量分 析表明，本文算法能有效获取有雾图像的场景深度，复原出视觉效果理想的无雾图像，且具有很好的场景普适性。</strong></p>

<p><strong>理解</strong>：<font color=red>本文认为图像去雾的问题可进一步转化为场景深度d的求解问题。</font>本文通过自动编码机获取到图片中物体的纹理特征，然后用多尺度的方法分别提取<strong>颜色特征、暗原色特征、颜色衰减特征、纹理结构</strong>特征。<strong>四者结合对场景深度进行估计</strong>。</p>

<p><strong>可以改进的</strong>：</p>

<ol>
<li><p>算法实时性不够强，效率比较低，可以考虑缩小图片尺寸，降低数据量，从而运用到视频去雾。</p></li>
<li><p>对雾气分布不均匀的图像，效果不理想，需要结合不同的气象模型来建立更为鲁棒的物理模型。</p></li>
</ol>

<h1 id="toc_1">2.尺度自适应暗通道先验去雾方法</h1>

<p><strong>目的：</strong><br/>
针对暗通道先验去雾方法的尺度选择问题 提出了一种尺度自适应方法， 根据图像的颜色和边 缘特征将暗通道求解的尺度自适应地调整到一个合适的范围。</p>

<p><strong>方法：</strong></p>

<ol>
<li><p>由颜色特征求解初始尺度：<font color=red>对于图像的不同区域采用不同的尺度求解暗通道: 在亮度较低或饱和度较高的区域，采用较小尺度; 在亮度较高且饱和度较低的区域，采用较大尺度;在景深突变处，采用较小尺度;在平滑区域，采用较大尺度。</font></p></li>
<li><p>由边缘特征对尺度进行修正:由于“光晕”现象发生在景深突变处，如果在边缘附近采用较小的尺度，可使透射率的求解窗口\(Ω_r(x)\)尽量不跨越景深边界，从而减小“光晕”现象; 在非边缘处采用较大的尺度，可以增大 \(J_{dark}(x)→0\)的概率，使复原图像的背景更平滑，噪声和失真更小。 由边缘特征对初始尺度\(r_0(x)\)进行修正.</p></li>
</ol>

<p><strong>结论：</strong><br/>
整个去雾过程参数自动配置，无需人工干 预，兼顾不同尺度复原图像的优点，复原图像色彩自然，对比度提升显著，并有效抑制了“光晕”现象。对多种雾化场景图像的处理结果表明: <strong>文中方法对场景的适应性强， 在任何情况下的处理结果均能达到 DG 方法的最优结果，甚至更好。</strong></p>

<p><strong>理解：</strong><br/>
该论文主要是针对HE的去雾方法，对暗通道尺寸进行自适应确定，减少了人工干预的复杂度。</p>

<p><strong>可以改进：</strong><br/>
<font color=red>该算法在运行时间上可以改进，也可以利用机器学习的方法来提取图片特征，避免Canny算子的局限性造成的边缘提取误差。<br/>
可以与上篇论文进行结合来提高上文尺度特征提取的效率。</font></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文档测试]]></title>
    <link href="https://lockxmonk.github.io/14928484245894.html"/>
    <updated>2017-04-22T16:07:04+08:00</updated>
    <id>https://lockxmonk.github.io/14928484245894.html</id>
    <content type="html"><![CDATA[
<p>如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。比如<a href="https://docs.python.org/2/library/re.html">re</a>模块就带了很多示例代码：</p>

<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search(&#39;(?&lt;=abc)def&#39;, &#39;abcdef&#39;)
&gt;&gt;&gt; m.group(0)
&#39;def&#39;
</code></pre>

<p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p>

<p>这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？</p>

<p>答案是肯定的。</p>

<p>当我们编写注释时，如果写上这样的注释：</p>

<pre><code class="language-py">
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单元测试]]></title>
    <link href="https://lockxmonk.github.io/14928429198094.html"/>
    <updated>2017-04-22T14:35:19+08:00</updated>
    <id>https://lockxmonk.github.io/14928429198094.html</id>
    <content type="html"><![CDATA[
<p>我们来编写一个<code>Dict</code>类，这个类的行为和<code>dict</code>一致，但是可以通过属性来访问，用起来就像下面这样：</p>

<pre><code>&gt;&gt;&gt; d = Dict(a=1, b=2)
&gt;&gt;&gt; d[&#39;a&#39;]
1
&gt;&gt;&gt; d.a
1
</code></pre>

<p>mydict.py代码为：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Dict(dict):

    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r &quot; &#39;Dict&#39; object has no atr &#39;%s&#39; &quot; % key)
        else:
            pass
        finally:
            pass

    def __setattr__(self, key, value):
        self[key] = value

</code></pre>

<p>为了编写单元测试，我们需要引入Python自带的<code>unittest</code>模块，编写<code>mydict_test.py</code>如下：</p>

<pre><code class="language-py">import unittest

from mydict import Dict


class TestDict(unittest.TestCase):

    def test_init(self):
        d = Dict(a=1, b=&#39;test&#39;)
        self.assertEquals(d.a, 1)
        self.assertEquals(d.b, &#39;test&#39;)
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d[&#39;key&#39;] = &#39;value&#39;
        self.assertEquals(d.key, &#39;value&#39;)

    def test_attr(self):
        d = Dict()
        d.key = &#39;value&#39;
        self.assertTrue(&#39;key&#39; in d)
        self.assertEquals(d[&#39;key&#39;], &#39;value&#39;)

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d[&#39;empty&#39;]

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError)
            value = d.empty

</code></pre>

<p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。</p>

<p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p>

<p>对每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是<code>assertEquals()：</code></p>

<pre><code class="language-py">self.assertEquals(abs(-1), 1) # 断言函数返回的结果与1相等
</code></pre>

<p>另一种重要的断言就是期待抛出指定类型的<code>Error</code>，比如通过<code>d[&#39;empty&#39;]</code>访问不存在的key时，断言会抛出<code>KeyError</code>：</p>

<pre><code class="language-py">with self.assertRaises(KeyError):
    value = d[&#39;empty&#39;]
</code></pre>

<p>而通过<code>d.empty</code>访问不存在的<code>key</code>时，我们期待抛出<code>AttributeError</code>：</p>

<pre><code class="language-py">with self.assertRaises(AttributeError):
    value = d.empty
</code></pre>

<h2 id="toc_0">运行单元测试</h2>

<p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在<code>mydict_test.py</code>的最后加上两行代码：</p>

<pre><code class="language-py">if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>

<p>这样就可以把<code>mydict_test.py</code>当做正常的python脚本运行：</p>

<p><img src="media/14928429198094/14928450280463.jpg" alt=""/></p>

<p>另一种更常见的方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试:<br/>
<img src="media/14928429198094/14928451217135.jpg" alt=""/></p>

<p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p>

<h2 id="toc_1">setUp与tearDown</h2>

<p>可以在单元测试中编写两个特殊的<code>setUp()</code>和<code>tearDown()</code>方法。这两个方法会分别在每<strong>调用一个测试方法的前后分别被执行</strong>。</p>

<p><code>setUp()和tearDown()</code>方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在<code>setUp()</code>方法中连接数据库，在<code>tearDown()</code>方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：</p>

<pre><code class="language-py">import unittest

from mydict import Dict

class TestDict(unittest.TestCase):

    def setUp(self):    
        print &#39;setUp...&#39;

    def tearDown(self):
        print &#39;tearDown...&#39;
    
    def test_init(self):    
        d = Dict(a=1, b=&#39;test&#39;)
        self.assertEquals(d.a, 1)   
        self.assertEquals(d.b, &#39;test&#39;)
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d[&#39;key&#39;] = &#39;value&#39;
        self.assertEquals(d.key, &#39;value&#39;)

    def test_attr(self):
        d = Dict()
        d.key = &#39;value&#39;
        self.assertTrue(&#39;key&#39; in d)
        self.assertEquals(d[&#39;key&#39;], &#39;value&#39;)

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d[&#39;empty&#39;]

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError):
            value = d.empty

if __name__ == &#39;__main__&#39;:
     unittest.main()
</code></pre>

<p><img src="media/14928429198094/14928470586520.jpg" alt=""/></p>

<h2 id="toc_2">总结</h2>

<ol>
<li><p>单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p></li>
<li><p>单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。</p></li>
<li><p>单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。</p></li>
<li><p>单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[调试]]></title>
    <link href="https://lockxmonk.github.io/14928307466218.html"/>
    <updated>2017-04-22T11:12:26+08:00</updated>
    <id>https://lockxmonk.github.io/14928307466218.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">断言</a>
</li>
<li>
<a href="#toc_1">logging</a>
</li>
<li>
<a href="#toc_2">pdb</a>
</li>
<li>
<a href="#toc_3">pdb.set_trace()</a>
</li>
<li>
<a href="#toc_4">IDE</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">总结</a>


<p>程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。</p>

<p>第一种方法简单直接粗暴有效，就是用<code>print</code>把可能有问题的变量打印出来看看.（这种方法不详细说明了，基本每个写代码的人都比较熟悉这种方法）</p>

<h2 id="toc_0">断言</h2>

<p>凡是用<code>print</code>来辅助查看的地方，都可以用断言<code>（assert）</code>来替代：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
def foo(s):
    n=int(s)
    assert n!=0,&#39;n is zero&#39;
    return 10/n
def main():
    foo(&#39;0&#39;)
main()
</code></pre>

<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，后面的代码就会出错。</p>

<p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p>

<p><img src="media/14928307466218/14928311015673.jpg" alt=""/><br/>
启动Python解释器时可以用<code>-O</code>参数来关闭<code>assert</code></p>

<pre><code>$ python -O err.py
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division or modulo by zero
</code></pre>

<p>关闭后，你可以把所有的<code>assert</code>语句当成<code>pass</code>来看。</p>

<h2 id="toc_1">logging</h2>

<p>把<code>print</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import logging

s = &#39;0&#39;
n = int(s)
logging.info(&#39;n = %d&#39; % n)
print 10 / n
</code></pre>

<p><code>logging.info()</code>就可以输出一段文本。运行，发现除了<code>ZeroDivisionError</code>，没有任何信息。<br/>
<img src="media/14928307466218/14928313656997.jpg" alt=""/></p>

<p>加上：</p>

<pre><code class="language-py">import logging
logging.basicConfig(level=logging.INFO)
</code></pre>

<p>之后显示：<br/>
<img src="media/14928307466218/14928314465553.jpg" alt=""/><br/>
这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug，info，warning，error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug和info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>

<p><code>logging</code>的另一个好处是通过简单的配置，<strong>一条语句可以同时输出到不同的地方，比如console和文件</strong>。</p>

<h2 id="toc_2">pdb</h2>

<p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
s = &#39;0&#39;
n = int(s)
print 10 / n
</code></pre>

<p>然后启动：<br/>
<img src="media/14928307466218/14928416845706.jpg" alt=""/></p>

<p>输入命令<code>l</code>来查看代码,输入命令<code>n</code>可以单步执行代码,任何时候都可以输入命令<code>p</code> 变量名来查看变量,输入命令<code>q</code>结束调试，退出程序.</p>

<h2 id="toc_3">pdb.set_trace()</h2>

<p>这个方法也是用<code>pdb</code>，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import pdb

s = &#39;0&#39;
n = int(s)
pdb.set_trace()  # 运行到这里会自动暂停
print 10 / n

</code></pre>

<p><img src="media/14928307466218/14928418957951.jpg" alt=""/><br/>
运行代码，程序会自动在<code>pdb.set_trace()</code>暂停并进入pdb调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行</p>

<p>这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。</p>

<h2 id="toc_4">IDE</h2>

<p>如果想要有好的设置断点、单步执行体验，就需要一个支持调试功能的IDE。目前比较好的<strong>Python IDE有PyCharm</strong>：<br/>
<a href="https://www.jetbrains.com/pycharm">https://www.jetbrains.com/pycharm</a></p>

<p>写程序最痛苦的事情莫过于调试，程序往往会以你意想不到的流程来运行，你期待执行的语句其实根本没有执行，这时候，就需要调试了。</p>

<h1 id="toc_5">总结</h1>

<p><strong>虽然用IDE调试起来比较方便，但是最后你会发现，<code>logging</code>才是终极武器。</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[错误、调试和测试]]></title>
    <link href="https://lockxmonk.github.io/14928231077736.html"/>
    <updated>2017-04-22T09:05:07+08:00</updated>
    <id>https://lockxmonk.github.io/14928231077736.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">错误处理</a>
<ul>
<li>
<a href="#toc_1">try</a>
</li>
<li>
<a href="#toc_2">调用堆栈</a>
</li>
<li>
<a href="#toc_3">记录错误</a>
</li>
<li>
<a href="#toc_4">抛出错误</a>
</li>
</ul>
</li>
</ul>


<p>Python内置了一套异常处理机制，来帮助我们进行错误处理。</p>

<p>此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的<strong><em>pdb</em></strong>可以让我们以单步方式执行代码。</p>

<p>最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。</p>

<h2 id="toc_0">错误处理</h2>

<p>在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数<code>open()</code>，成功时返回文件描述符（就是一个整数），出错时返回<code>-1</code>。</p>

<p>用错误码来表示是否出错十分不便，因为函数本身应该返回的正常结果和错误码混在一起，造成调用者必须用大量的代码来判断是否出错。</p>

<p>所以高级语言通常都内置了一套<code>try...except...finally...</code>的错误处理机制，Python也不例外。</p>

<h3 id="toc_1">try</h3>

<p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    print &#39;try...&#39;
    r = 10 / 0
    print &#39;result:&#39;, r
except ZeroDivisionError, e:
    print &#39;except:&#39;, e
finally:
    print &#39;finally...&#39;
print &#39;END&#39;
</code></pre>

<p><img src="media/14928231077736/14928238871411.jpg" alt=""/><br/>
从输出可以看到，当错误发生时，后续语句<code>print &#39;result:&#39;, r</code>不会被执行，<code>except</code>由于捕获到<code>ZeroDivisionError</code>，因此被执行。最后，<code>finally</code>语句被执行。然后，程序继续按照流程往下走。</p>

<p>你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的<code>except</code>语句块处理。没错，可以有多个<code>except</code>来捕获不同类型的错误：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    print &#39;try...&#39;
    r = 10 / int(0)
    print &#39;result:&#39;, r
except ValueError as e:
    print &#39;ValueError:&#39;,e
except ZeroDivisionError as e:
    print &#39;ZeroDivisionError:&#39;, e
else:
    print &#39;no error&#39;
finally:
    print &#39;finally...&#39;
print &#39;END&#39;
</code></pre>

<p><img src="media/14928231077736/14928249482640.jpg" alt=""/></p>

<p>Python的错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</p>

<pre><code class="language-py">try:
    foo()
except StandardError, e:
    print &#39;StandardError&#39;
except ValueError, e:
    print &#39;ValueError&#39;
</code></pre>

<p>第二个<code>except</code>永远也捕获不到<code>ValueError</code>，因为<code>ValueError是StandardError</code>的子类，如果有，也被第一个<code>except</code>给捕获了。</p>

<p>Python所有的错误都是从<code>BaseException</code>类派生的，常见的错误类型和继承关系看这里：</p>

<p><img src="media/14928231077736/14928254735561.jpg" alt=""/></p>

<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()调用bar()，bar()调用foo()，结果foo()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理：</p>

<pre><code class="language-py">def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar(&#39;0&#39;)
    except StandardError, e:
        print &#39;Error!&#39;
    finally:
        print &#39;finally...&#39;

print main()

</code></pre>

<p><img src="media/14928231077736/14928272805670.jpg" alt=""/></p>

<p>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写<code>try...except...finally</code>的麻烦。</p>

<h3 id="toc_2">调用堆栈</h3>

<p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    bar(&#39;0&#39;)

main()
</code></pre>

<p><img src="media/14928231077736/14928281628836.jpg" alt=""/><br/>
出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链。</p>

<p>从上往下依次查看错误。</p>

<h3 id="toc_3">记录错误</h3>

<p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p>

<p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar(&#39;0&#39;)
    except StandardError as e:
        logging.exception(e)
    else:
        pass
    finally:
        pass
main()
print &#39;END&#39;
</code></pre>

<p><strong>同样是出错，但程序打印完错误信息后会继续执行，并正常退出</strong>：<br/>
<img src="media/14928231077736/14928284148150.jpg" alt=""/><br/>
最后打印出了“END”</p>

<p>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</p>

<h3 id="toc_4">抛出错误</h3>

<p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p>

<p>如果要抛出错误，首先根据需要，可以定义一个错误的<code>class</code>，选择好继承关系，然后，用<code>raise</code>语句抛出一个错误的实例</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class FooError(StandardError):
    pass

def foo(s):
    n = int(s)
    if n == 0:
        raise FooError(&#39;invaild value: %s&#39; % s)
    return 10/0
foo(0)
</code></pre>

<p><img src="media/14928231077736/14928288600479.jpg" alt=""/></p>

<p><strong>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。</strong></p>

<p>最后，我们来看另一种错误处理的方式：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
def foo(s):
    n = int(s)
    return 10 / n

def bar(s):
    try:
        return foo(s) * 2
    except StandardError, e:
        print &#39;Error!&#39;
        raise

def main():
    bar(&#39;0&#39;)

main()
</code></pre>

<p><img src="media/14928231077736/14928306395157.jpg" alt=""/></p>

<p>在bar()函数中，我们明明已经捕获了错误，但是，打印一个<code>Error</code>!后，又把错误通过<code>raise</code>语句抛出去了，这不有病么？</p>

<p>其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p>

<p>raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型：</p>

<pre><code class="language-py">try:
    10 / 0
except ZeroDivisionError:
    raise ValueError(&#39;input error!&#39;)
</code></pre>

<p>只要是合理的转换逻辑就可以，但是，决不应该把一个<code>IOError</code>转换成毫不相干的<code>ValueError</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用元类]]></title>
    <link href="https://lockxmonk.github.io/14927355881897.html"/>
    <updated>2017-04-21T08:46:28+08:00</updated>
    <id>https://lockxmonk.github.io/14927355881897.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">metaclass</a>
</li>
</ul>


<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是<strong>运行时动态创建的</strong>。</p>

<p>比方说我们要定义一个<code>Hello</code>的class：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Hello(object):
    def hello(self, name=&#39;world&#39;):
        print(&#39;Hello, %s.&#39; % name)
h = Hello()
h.hello()
print (type(Hello))
print (type(h))
</code></pre>

<p><img src="media/14927355881897/14927620006235.jpg" alt=""/></p>

<p><font color=red><strong><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个class，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是<code>class Hello</code>。</strong></font></p>

<p>我们说class的定义是运行时动态创建的，而<strong>创建class的方法就是使用<code>type()</code>函数</strong>。</p>

<p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，<strong>我们可以通过<code>type()</code>函数创建出Hello类，而无需通过<code>class Hello(object)...</code>的定义</strong>：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
def fn(self, name=&#39;world&#39;):   # 先定义函数
    print(&#39;Hello, %s.&#39; % name)

Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn))  # 创建Hello class
h = Hello()
h.hello()
print(type(Hello))
print(type(h))

</code></pre>

<p><img src="media/14927355881897/14927623112362.jpg" alt=""/></p>

<p><strong>要创建一个class对象，type()函数依次传入3个参数：</strong></p>

<ol>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li>
<li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li>
</ol>

<p>通过<code>type()</code>函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p>

<blockquote>
<p>正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
</blockquote>

<h2 id="toc_0">metaclass</h2>

<p>除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用metaclass。<br/>
简单的解释就是：先定义metaclass，就可以创建类，最后创建实例。</p>

<p>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</p>

<p><strong>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</strong></p>

<p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：</p>

<p>定义<code>ListMetaclass</code>，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

# metaclass是创建类，所以必须从`type`类型派生：
class ListMetaclass(type):

    def __new__(cls, name, bases, attrs):
        attrs[&#39;add&#39;] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)


class MyList(list):
    __metaclass__ = ListMetaclass  # 指示使用ListMetaclass来定制类
</code></pre>

<p>当我们写下<code>__metaclass__ = ListMetaclass</code>语句时，魔术就生效了，它指示Python解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>

<p><code>__new__()</code><strong>方法接收到的参数依次是</strong>：</p>

<ol>
<li><p>当前准备创建的类的对象；</p></li>
<li><p>类的名字；</p></li>
<li><p>类继承的父类集合；</p></li>
<li><p>类的方法集合。</p></li>
</ol>

<p>我们测试输出为：</p>

<pre><code class="language-py">L = MyList()
L.add(1)
print L
</code></pre>

<p><img src="media/14927355881897/14927637008533.jpg" alt=""/></p>

<p>动态修改有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。</p>

<p>但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。</p>

<p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</p>

<p>要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p>

<p>具体方法参见<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820064557c69858840b4c48d2b8411bc2ea9099ba000">廖老师的教学网站</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向对象高级编程]]></title>
    <link href="https://lockxmonk.github.io/14926766188460.html"/>
    <updated>2017-04-20T16:23:38+08:00</updated>
    <id>https://lockxmonk.github.io/14926766188460.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">使用__slots__</a>
</li>
<li>
<a href="#toc_1">使用@property</a>
</li>
<li>
<a href="#toc_2">多重继承</a>
<ul>
<li>
<a href="#toc_3">Mixin</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">定制类</a>
<ul>
<li>
<a href="#toc_5">__str__</a>
</li>
<li>
<a href="#toc_6">__iter__</a>
</li>
<li>
<a href="#toc_7">__getitem__</a>
</li>
</ul>
</li>
<li>
<a href="#toc_8">__getattr__</a>
</li>
<li>
<a href="#toc_9">__call__</a>
</li>
</ul>


<p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。</p>

<p><strong><em>我们可以动态的给某一个实例绑定属性、方法。要绑定该类所有的实例的话，则可以将方法绑定到该类上。</em></strong></p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Student(object):
    &quot;&quot;&quot;docstring for Student&quot;&quot;&quot;
    pass
s = Student()
s.name = &#39;梁中豪&#39;  # 动态给实例绑定一个属性

from types import MethodType


def set_age(self, age):  # 定义一个函数作为实例方法
    self.age = age
s.set_age = MethodType(set_age, s, Student)  # 给实例绑定一个方法
s.set_age(25)

# 为了给所有实例都绑定方法，可以给class绑定方法：


def set_score(self, score):  # 定义一个函数作为实例方法
    self.score = score
Student.set_score = MethodType(set_score, None, Student)
s.set_score(100) #给class绑定方法后，所有实例均可调用
s2 = Student()
s2.set_score(90)
print s.name, s.age, s.score, s2.score
</code></pre>

<p><img src="media/14926766188460/14926773474695.jpg" alt=""/></p>

<h2 id="toc_0">使用__slots__</h2>

<p>如果我们想要限制class的属性怎么办？比如，只允许对Student实例添加<code>name和age</code>属性。那么可以使用一个特殊的<code>__slots__</code>变量。</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Student(object):
    &quot;&quot;&quot;docstring for Student&quot;&quot;&quot;
    __slots__ = (&#39;name&#39;,&#39;age&#39;)
    
s = Student()
s.name = &#39;梁中豪&#39;
s.age = 21
print s.name, s.age
s.score = 90
print s.score

</code></pre>

<p><img src="media/14926766188460/14926779162430.jpg" alt=""/></p>

<p><font color=red>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类起作用，对继承的子类是不起作用的. 除非在子类中也定义<code>__slots__</code>，这样，子类允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。<br/>
</font></p>

<h2 id="toc_1">使用@property</h2>

<p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改。</p>

<p>这显然不合逻辑。为了限制score的范围，可以通过一个<code>set_score()</code>方法来设置成绩，再通过一个<code>get_score()</code>来获取成绩，这样，在<code>set_score()</code>方法里，就可以检查参数：</p>

<pre><code class="language-py">class Student(object):

    def get_score(self):
        return self._score

    def set_score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value
s = Student()
s.set_score(50)
s.get_score()
s.set_score(999)
s.get_score()
</code></pre>

<p><img src="media/14926766188460/14927376402165.jpg" alt=""/></p>

<p>上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p>

<p>对于类的方法，装饰器一样起作用。Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的：</p>

<pre><code class="language-py">
class Student(object):

    @property
    def score(self):
        return self._score

    @score.setter
    def score(self, value):
        if not isinstance(value, int):
            raise ValueError(&#39;score must be an integer!&#39;)
        if value &lt; 0 or value &gt; 100:
            raise ValueError(&#39;score must between 0 ~ 100!&#39;)
        self._score = value

s = Student
s.score = 60
print s.score
</code></pre>

<p><code>@property</code>的实现比较复杂，我们先考察如何使用。把一个<code>getter</code>方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个<code>setter</code>方法变成属性赋值</p>

<p>如果只定义getter方法，不定义setter方法就是一个只读属性：</p>

<pre><code class="language-py">class Student(object):

    @property
    def birth(self):
        return self._birth

    @birth.setter
    def birth(self, value):
        self._birth = value

    @property
    def age(self):
        return 2014 - self._birth
s = Student()
s.birth = 23
print s.birth
</code></pre>

<h2 id="toc_2">多重继承</h2>

<p>继承是面向对象编程的一个重要的方式，因为通过继承，子类就可以扩展父类的功能。</p>

<p>一个类可以继承多个类，称为多重继承，如下所示：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Animal(object):
    &quot;&quot;&quot;docstring for Animal&quot;&quot;&quot;
    pass


class Mammal(Animal):
    &quot;&quot;&quot;docstring for Mammal&quot;&quot;&quot;
    print &#39;Mammal&#39;


class Bird(Animal):
    &quot;&quot;&quot;docstring for Bird&quot;&quot;&quot;
    print &#39;Bird&#39;


class Runable(object):
    &quot;&quot;&quot;docstring for Runable&quot;&quot;&quot;

    def run(self):
        print &#39;Running...&#39;


class Flyable(object):
    &quot;&quot;&quot;docstring for Flyable&quot;&quot;&quot;

    def fly(self):
        print &#39;Flying...&#39;


class Dog(Mammal, Runable):
    &quot;&quot;&quot;docstring for Dog&quot;&quot;&quot;
    pass


class Bat(Mammal, Flyable):
    &quot;&quot;&quot;docstring for Bat&quot;&quot;&quot;
    pass
</code></pre>

<p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>

<h3 id="toc_3">Mixin</h3>

<p>在设计类的继承关系时，通常，主线都是单一继承下来的，例如，<code>Ostrich</code>继承自<code>Bird</code>。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为<code>Mixin</code>。</p>

<p>为了更好地看出继承关系，我们把Runnable和Flyable改为<code>RunnableMixin</code>和<code>FlyableMixin</code>。类似的，你还可以定义出肉食动物<code>CarnivorousMixin</code>和植食动物<code>HerbivoresMixin</code>，让某个动物同时拥有好几个<code>Mixin</code>：</p>

<pre><code class="language-py">class Dog(Mammal, RunnableMixin, CarnivorousMixin):
    pass
</code></pre>

<p>由于Python允许使用多重继承，因此，Mixin就是一种常见的设计。</p>

<p><strong>只允许单一继承的语言（如Java）不能使用Mixin的设计</strong>。</p>

<h2 id="toc_4">定制类</h2>

<p>看到类似<code>__slots__</code>这种形如<code>__xxx__</code>的变量或者函数名就要注意，这些在Python中是有特殊用途的。</p>

<p>类似有很多特殊变量来帮助我们定制类：</p>

<h3 id="toc_5">__str__</h3>

<p>我们先定义一个<code>Student</code>类，打印一个实例：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;
    def __init__(self, name):
        super(Students, self).__init__()
        self.name = name
print Students(&#39;LZH&#39;)
</code></pre>

<p><img src="media/14926766188460/14927559673818.jpg" alt=""/><br/>
得到上图所示，我们可以定制所打印的内容。</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;
    def __init__(self, name):
        super(Students, self).__init__()
        self.name = name
    def __str__(self):
        return &#39;Students object (name:%s)&#39; %self.name
print Students(&#39;LZH&#39;)
</code></pre>

<p><img src="media/14926766188460/14927560929527.jpg" alt=""/><br/>
这样打印出来的实例，不但好看，而且容易看出实例内部重要的数据。<br/>
当然这只是负责定制<code>print</code>方法输出的内容。直接敲变量不用<code>print</code>，打印出来的实例还是不好看。</p>

<p>这是因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>

<pre><code class="language-py">class Student(object):
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return &#39;Student object (name=%s)&#39; % self.name
    __repr__ = __str__  #因为两者方法几乎一样，所以可以直接偷懒将前者赋值给repr
</code></pre>

<h3 id="toc_6">__iter__</h3>

<p>如果一个类想被用于<code>for ... in</code>循环，类似<code>list或tuple</code>那样，就必须实现一个<code>__iter__()</code>方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的<code>next()</code>方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。</p>

<p>我们以斐波那契数列为例，写一个Fib类，可以作用于for循环：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Fib(object):
    &quot;&quot;&quot;docstring for Fib&quot;&quot;&quot;

    def __init__(self):
        self.a, self.b = 0, 1  # 初始化两个计数器a，b

    def __iter__(self):
        return self  # 实例本身就是迭代对象，故返回自己

    def next(self):
        self.a, self.b = self.b, self.a + self.b
        if self.a &gt; 100:
            raise StopIteration()
        return self.a

for n in Fib():
    print n
</code></pre>

<p><img src="media/14926766188460/14927569583236.jpg" alt=""/></p>

<h3 id="toc_7">__getitem__</h3>

<p>上述要表现得像list那样按照下标取出元素，需要实现<code>__getitem__()</code>方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

class Fib(object):
    &quot;&quot;&quot;docstring for Fib&quot;&quot;&quot;

    def __getitem__(self, n):
        a, b = 1, 1
        for x in range(n):
            a, b = b, a + b
        print a

f = Fib()
f[0]
f[2]
f[4]

</code></pre>

<p><img src="media/14926766188460/14927581032895.jpg" alt=""/></p>

<p>不能简单的直接执行切片方法，Fib会报错。原因是<code>__getitem__()</code>传入的参数可能是一个int，也可能是一个切片对象slice，所以要做判断：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-


class Fib(object):
    &quot;&quot;&quot;docstring for Fib&quot;&quot;&quot;

    def __getitem__(self, n):
        if isinstance(n, int):
            a, b = 1, 1
            for x in range(n):
                a, b = b, a + b
            print a
        if isinstance(n, slice):
            start = n.start
            stop = n.stop
            a, b = 1, 1
            L = []
            for x in range(stop):
                if x &gt;= start:
                    L.append(a)
                a, b = b, a + b
            print L

f = Fib()
f[5]
f[1:5]
</code></pre>

<p><img src="media/14926766188460/14927591015675.jpg" alt=""/></p>

<h2 id="toc_8">__getattr__</h2>

<p>当定义好一个类后，若实例调用一个不存在的属性，则会报错，但是我们可以运用<code>__getattr__</code>动态返回一个属性。例如：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Student(object):

    def __init__(self):
        self.name = &#39;Michael&#39;

    def __getattr__(self, attr):
        if attr==&#39;score&#39;:
            return 99

s = Student()
print s.name
print s.score
print s.age
</code></pre>

<p><img src="media/14926766188460/14927598715799.jpg" alt=""/><br/>
只有在没有找到属性的情况下，才调用<code>__getattr__</code>，已有的属性，比如<code>name</code>，不会在<code>__getattr__</code>中查找。</p>

<p>此外，注意到任意调用如<code>s.age</code>都会返回<code>None</code>，这是因为我们定义的<code>__getattr__</code>默认返回就是<code>None</code>。</p>

<p><strong>这实际上可以把一个类的所有属性和方法调用全部动态化处理了，不需要任何特殊手段。例如动态的拼接api接口：</strong></p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Chain(object):

    def __init__(self, path=&#39;&#39;):
        self._path = path

    def __getattr__(self, path):
        return Chain(&#39;%s/%s&#39; % (self._path, path))

    def __str__(self):
        return self._path
print Chain().status.user.timeline.list
print Chain(&#39;LZH&#39;).status.user.timeline.list
</code></pre>

<p><img src="media/14926766188460/14927597036919.jpg" alt=""/></p>

<h2 id="toc_9">__call__</h2>

<p>任何类，只需要定义一个__call__()方法，就可以直接对实例进行调用。请看示例：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;
    def __init__(self, name):
        super(Students, self).__init__()
        self.name = name
    def __call__(self):
        print (&#39;My name is %s.&#39; % self.name)

s = Students(&#39;LZH&#39;)
s()
</code></pre>

<p><img src="media/14926766188460/14927611817291.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类和实例]]></title>
    <link href="https://lockxmonk.github.io/14926712777578.html"/>
    <updated>2017-04-20T14:54:37+08:00</updated>
    <id>https://lockxmonk.github.io/14926712777578.html</id>
    <content type="html"><![CDATA[
<ul>
<li>
<a href="#toc_0">数据封装</a>
</li>
<li>
<a href="#toc_1">访问限制</a>
</li>
<li>
<a href="#toc_2">继承和多态</a>
</li>
<li>
<a href="#toc_3">获取对象信息</a>
<ul>
<li>
<a href="#toc_4">使用type()</a>
</li>
<li>
<a href="#toc_5">使用isinstance()</a>
</li>
<li>
<a href="#toc_6">使用dir()</a>
</li>
</ul>
</li>
</ul>


<p>在Python中，定义类是通过<code>class</code>关键字：</p>

<pre><code class="language-py">class Student(object):
    pass
</code></pre>

<p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，<strong>如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类</strong>。</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;

    def __init__(self, name, score):
        super(Students, self).__init__()
        self.name = name
        self.score = score
</code></pre>

<p>注意到<code>__init__</code>方法的第一个参数永远是self，表示创建的实例本身，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code>就指向创建的实例本身。</p>

<p>和普通的函数相比，在类中定义的函数只有一点不同，<font color=red>就是第一个参数永远是实例变量self，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数和关键字参数。</font></p>

<h2 id="toc_0">数据封装</h2>

<p>面向对象编程的一个重要特点就是数据封装，创建实例需要给出<code>name</code>和<code>score</code>，而如何打印，都是在Student类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</p>

<p>例如下面增加一个成绩分类的方法：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;

    def __init__(self, name, score):
        super(Students, self).__init__()
        self.name = name
        self.score = score

    def print_score(self):
        print &#39;%s:%s&#39; % (self.name, self.score)

    def get_grade(self):
        if self.score &gt;= 90:
            print &#39;A&#39;
        elif self.score &gt;= 60:
            print &#39;B&#39;
        else:
            print &#39;C&#39;

bart = Students(&#39;Bart&#39;, 59)
lisa = Students(&#39;梁中豪&#39;, 100)
bart.print_score()
bart.get_grade()
lisa.print_score()
lisa.get_grade()
</code></pre>

<h2 id="toc_1">访问限制</h2>

<p>在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。</p>

<p>但是，从前面Student类的定义来看，外部代码还是可以自由地修改一个实例的<code>name</code>、<code>score</code>属性</p>

<p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，<font color=red>在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，</font>所以，我们把Student类改一改：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;

    def __init__(self, name, score):
        super(Students, self).__init__()
        self.__name = name
        self.__score = score

    def print_score(self):
        print &#39;%s:%s&#39; % (self.__name, self.__score)

   
bart = Students(&#39;Bart&#39;, 59)
lisa = Students(&#39;梁中豪&#39;, 100)
bart.print_score()
lisa.__name
</code></pre>

<p>改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.<code>__name</code>和实例变量<code>.__score</code>了：<br/>
<img src="media/14926712777578/14926727380387.jpg" alt=""/><br/>
如果又要允许外部代码修改score,可以给Student类增加set_score方法.这里跟java很像。不在过多叙述。</p>

<h2 id="toc_2">继承和多态</h2>

<p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>

<p>继承最大的好处是子类获得了父类的全部功能。由于<code>Animial</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为它的子类，什么事也没干，就自动拥有了<code>run()</code>方法，当然也可以对父类方法进行重写。</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class Animal(object):
    &quot;&quot;&quot;docstring for Animal&quot;&quot;&quot;

    def run(self):
        print &#39;Animal is running..&#39;


class Dog(Animal):
    pass


class Cat(Animal):
    &quot;&quot;&quot;docstring for Cat&quot;&quot;&quot;

    def run(self):
        print &#39;Cat is running..&#39;

dog = Dog()
dog.run()

cat = Cat()
cat.run()

</code></pre>

<p><img src="media/14926712777578/14926743181176.jpg" alt=""/></p>

<h2 id="toc_3">获取对象信息</h2>

<p>当我们拿到一个对象的引用时，如何知道这个对象是什么类型？</p>

<h3 id="toc_4">使用type()</h3>

<p>基本类型都可以用<code>type()</code>判断：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

print type(123),type(&#39;str&#39;),type(None)
</code></pre>

<p><img src="media/14926712777578/14926750871663.jpg" alt=""/></p>

<p>Python把每种type类型都定义好了常量，放在types模块里，使用之前，需要先导入：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import types
print type(&#39;abc&#39;)==types.StringType
print type(u&#39;abc&#39;)==types.UnicodeType
print type([])==types.ListType
print type(str) == types.TypeType
</code></pre>

<p><img src="media/14926712777578/14926752976543.jpg" alt=""/><br/>
<strong>最后注意到有一种类型就叫TypeType，所有类型本身的类型就是TypeType.比如<code>int，str</code>等</strong></p>

<h3 id="toc_5">使用isinstance()</h3>

<p>我们使用<code>isinstance()</code>来判断class的类型，例如：</p>

<pre><code class="language-py">class Animals(object):
    &quot;&quot;&quot;docstring for Animals&quot;&quot;&quot;
    pass
class Cat(Animals):
    &quot;&quot;&quot;docstring for Cat&quot;&quot;&quot;
    pass
class Dog(Animals):
    &quot;&quot;&quot;docstring for Dog&quot;&quot;&quot;
    pass
a = Animals()
d = Dog()
h = Cat()
print isinstance(h, Cat),isinstance(d, Dog),isinstance(a, Animals)
</code></pre>

<p><img src="media/14926712777578/14926756201012.jpg" alt=""/></p>

<p>当然也可以用<code>isinstance()</code>来判断基本类型</p>

<h3 id="toc_6">使用dir()</h3>

<p>如果要获得一个对象的所有属性和方法，可以使用<code>dir()</code>函数，它返回一个包含字符串的<code>list</code>，比如，获得一个str对象的所有属性和方法：</p>

<pre><code class="language-py">&gt;&gt;&gt; dir(&#39;abc&#39;)
</code></pre>

<p><img src="media/14926712777578/14926758082813.jpg" alt=""/></p>

<p><strong>仅仅把属性和方法列出来是不够的，配合<code>getattr()、setattr()以及hasattr()</code>，我们可以直接操作一个对象的状态：</strong></p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

class Animals(object):
    &quot;&quot;&quot;docstring for Animals&quot;&quot;&quot;

    def __init__(self):
        self.x = 9

    def power(self):
        print self.x * self.x
obj = Animals()

print hasattr(obj, &#39;x&#39;)  # 有属性&#39;x&#39;吗？
print hasattr(obj, &#39;y&#39;)  # 有属性&#39;y&#39;吗？
print setattr(obj, &#39;y&#39;, 19)  # 设置一个属性&#39;y&#39;
print getattr(obj, &#39;y&#39;)  # 获取属性&#39;y&#39;
print obj.y
</code></pre>

<p><img src="media/14926712777578/14926764199501.jpg" alt=""/></p>

<p>也可以获得对象的方法：</p>

<pre><code class="language-py">fn = getattr(obj, &#39;power&#39;)
print fn,fn(),
</code></pre>

<p><img src="media/14926712777578/14926765852729.jpg" alt=""/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向对象编程]]></title>
    <link href="https://lockxmonk.github.io/14926690841704.html"/>
    <updated>2017-04-20T14:18:04+08:00</updated>
    <id>https://lockxmonk.github.io/14926690841704.html</id>
    <content type="html"><![CDATA[
<p>采用面向对象的程序设计思想来设计一个简单的学生成绩打印，我们首选思考的不是程序的执行流程，而是<code>Student</code>这种数据类型应该被视为一个对象，这个对象拥有<code>name</code>和<code>score</code>这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个<code>print_score</code>消息，让对象自己把自己的数据打印出来</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class Students(object):
    &quot;&quot;&quot;docstring for Students&quot;&quot;&quot;

    def __init__(self, name, score):
        super(Students, self).__init__()
        self.name = name
        self.score = score

    def print_score(self):
        print &#39;%s:%s&#39; % (self.name, self.score)


bart = Students(&#39;Bart&#39;, 59)
lisa = Students(&#39;梁中豪&#39;, 100)
bart.print_score()
lisa.print_score()
</code></pre>

<p><img src="media/14926690841704/14926708025078.jpg" alt=""/></p>

<p><strong>面向对象三大特点：封装、继承、多态。</strong></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用_future_]]></title>
    <link href="https://lockxmonk.github.io/14926579397626.html"/>
    <updated>2017-04-20T11:12:19+08:00</updated>
    <id>https://lockxmonk.github.io/14926579397626.html</id>
    <content type="html"><![CDATA[
<p>Python的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。有些改动是不兼容旧版本的，也就是在当前版本运行正常的代码，到下一个版本运行就可能不正常了。</p>

<p>从Python 2.7到Python 3.x就有不兼容的一些改动，比如2.x里的字符串用<code>&#39;xxx&#39;</code>表示str，Unicode字符串用<code>u&#39;xxx&#39;</code>表示unicode，而在3.x中，所有字符串都被视为unicode，因此，写<code>u&#39;xxx&#39;和&#39;xxx&#39;</code>是完全一致的.还有在2.x中以<code>&#39;xxx&#39;</code>表示的str就必须写成<code>b&#39;xxx&#39;</code>，以此表示“二进制字符串”。</p>

<p><font color=red>Python提供了<code>__future__模块</code>，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。</font>举例说明如下：</p>

<p>为了适应Python 3.x的新的字符串的表示方法，在2.7版本的代码中，可以通过unicode_literals来使用Python 3.x的新的语法：</p>

<pre><code class="language-py"># still running on Python 2.7
# -*- coding: utf-8 -*-

from __future__ import unicode_literals

print &#39;\&#39;xxx\&#39; is unicode?&#39;, isinstance(&#39;xxx&#39;, unicode)
print &#39;u\&#39;xxx\&#39; is unicode?&#39;, isinstance(u&#39;xxx&#39;, unicode)
print &#39;\&#39;xxx\&#39; is str?&#39;, isinstance(&#39;xxx&#39;, str)
print &#39;b\&#39;xxx\&#39; is str?&#39;, isinstance(b&#39;xxx&#39;, str)
</code></pre>

<p><img src="media/14926579397626/14926584481460.jpg" alt=""/><br/>
注意到上面的代码仍然在Python 2.7下运行，但结果显示去掉前缀u的<code>&#39;a string&#39;</code>仍是一个unicode，而加上前缀b的<code>b&#39;a string&#39;</code>才变成了str</p>

<p>由于Python是由社区推动的开源并且免费的开发语言，不受商业公司控制，因此，<strong>Python的改进往往比较激进，不兼容的情况时有发生。Python为了确保你能顺利过渡到新版本，特别提供了__future__模块，让你在旧的版本中试验新版本的一些特性</strong>。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用第三方模块]]></title>
    <link href="https://lockxmonk.github.io/14925924499918.html"/>
    <updated>2017-04-19T17:00:49+08:00</updated>
    <id>https://lockxmonk.github.io/14925924499918.html</id>
    <content type="html"><![CDATA[
<p>在Python中，安装第三方模块，是通过setuptools这个工具完成的。Python有两个封装了setuptools的包管理工具：<code>easy_install和pip</code>。<font color=red>目前官方推荐使用<code>pip</code>。</font></p>

<p>Mac和linux本身自带pip，不用安装，在win下需要安装。这里不再过多叙述。</p>

<p>这里试着安装一个第三方库：<strong>Python Imaging Library</strong>，这是Python下非常强大的处理图像的工具库。一般来说，第三方库都会在Python官方的<a href="http://pypi.python.org">http://pypi.python.org</a>网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Python Imaging Library的名称叫PIL，因此，安装Python Imaging Library的命令就是：</p>

<p><del>pip install PIL</del>（现在用pillow来代替PIL）</p>

<pre><code>sudo pip install Pillow
</code></pre>

<p>处理图片的方法为：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
from PIL import Image

im = Image.open(&#39;icon.png&#39;)
print im.format, im.size, im.mode

im.thumbnail((150,100))
im.save(&#39;thumb.jpg&#39;,&#39;JPEG&#39;)
</code></pre>

<p><img src="media/14925924499918/14926575371706.jpg" alt=""/><br/>
将原图<code>icon.png</code>:<br/>
<img src="media/14925924499918/icon.png" alt="icon"/></p>

<p>生成一个名为<code>thumb.jpg</code>的图片：<br/>
<img src="media/14925924499918/thumb.jpg" alt="thumb"/></p>

<blockquote>
<p>这两张图暂时没有看出明显的区别，需要深入研究。</p>
</blockquote>

<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在<code>sys</code>模块的<code>path</code>变量中：</p>

<pre><code>&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path
[&#39;&#39;, &#39;/Library/Python/2.7/site-packages/pip-8.1.1-py2.7.egg&#39;, 
&#39;/System/Library/Frameworks/Python.framework/Versions/2.7/lib/python27.zip&#39;,... ]
</code></pre>

<p>想要添加自己的搜索目录可以：</p>

<pre><code class="language-py">&gt;&gt;&gt; import sys
&gt;&gt;&gt; sys.path.append(&#39;/Users/michael/my_py_scripts&#39;)
</code></pre>

<p><font color=red>这种方法是在运行时修改，运行结束后失效。</font></p>

<p>第二种方法是设置环境变量<code>PYTHONPATH</code>这里不做详述。</p>

]]></content>
  </entry>
  
</feed>
