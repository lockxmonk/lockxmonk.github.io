<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[LZH007]]></title>
  <link href="https://lockxmonk.github.io/atom.xml" rel="self"/>
  <link href="https://lockxmonk.github.io/"/>
  <updated>2017-12-07T17:20:54+08:00</updated>
  <id>https://lockxmonk.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im/">MWeb</generator>
  
  <entry>
    <title type="html"><![CDATA[Happy Number]]></title>
    <link href="https://lockxmonk.github.io/15127409536382.html"/>
    <updated>2017-12-08T21:49:13+08:00</updated>
    <id>https://lockxmonk.github.io/15127409536382.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127409536382/15127409821970.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int happy(int num){
        int a = 0;
        while (num!=0) {
            a += int(pow(num%10, 2));
            num/=10;
        }
        return a;
    }


    bool isHappy(int n) {
        int slow, fast;
        slow = fast = n;
        do {
            slow = happy(slow);
            fast = happy(fast);
            fast = happy(fast);
        } while(slow != fast);

        return slow==1?1:0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Find the Difference]]></title>
    <link href="https://lockxmonk.github.io/15127221024719.html"/>
    <updated>2017-12-08T16:35:02+08:00</updated>
    <id>https://lockxmonk.github.io/15127221024719.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127221024719/15127221121271.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    char findTheDifference(string s, string t) {
        char sum = 0;
        for (char c: s) {
            sum^=c;
        }
        for (char c: t) {
            sum^=c;
        }
        return sum;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distribute Candies]]></title>
    <link href="https://lockxmonk.github.io/15127198152754.html"/>
    <updated>2017-12-08T15:56:55+08:00</updated>
    <id>https://lockxmonk.github.io/15127198152754.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127198152754/15127198177167.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int distributeCandies(vector&lt;int&gt;&amp; candies) {
        int res = 0;
        unordered_map&lt;int, vector&lt;int&gt;&gt; map;
        for (int i =0; i&lt;candies.size(); i++) {
            map[candies[i]].push_back(candies[i]);
        }
        if (map.size()&lt;=candies.size()/2) {
            return map.size();
        }else{
            return candies.size()/2;
        }
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fizz Buzz]]></title>
    <link href="https://lockxmonk.github.io/15127166881202.html"/>
    <updated>2017-12-08T15:04:48+08:00</updated>
    <id>https://lockxmonk.github.io/15127166881202.html</id>
    <content type="html"><![CDATA[
<p>Write a program that outputs the string representation of numbers from 1 to n.</p>

<p>But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”.</p>

<p><img src="media/15127166881202/15127167059726.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; fizzBuzz(int n) {
        vector&lt;string&gt; res;
        for (int i=1; i&lt;=n; i++) {
            if (i%3==0&amp;&amp;i%5==0) {
                res.push_back(&quot;FizzBuzz&quot;);
            }else if (i%5==0){
                res.push_back(&quot;Buzz&quot;);
            }else if(i%3==0){
                res.push_back(&quot;Fizz&quot;);
            }else{
                res.push_back(to_string(i));
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sum of Two Integers]]></title>
    <link href="https://lockxmonk.github.io/15127150080101.html"/>
    <updated>2017-12-08T14:36:48+08:00</updated>
    <id>https://lockxmonk.github.io/15127150080101.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127150080101/15127150099516.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int getSum(int a, int b) {
        int sum = a;
        while (b!=0) {
            sum = a^b;
            b = (a&amp;b)&lt;&lt;1;
            a = sum;
        }
        return a;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Employee Importance]]></title>
    <link href="https://lockxmonk.github.io/15127074753393.html"/>
    <updated>2017-12-08T12:31:15+08:00</updated>
    <id>https://lockxmonk.github.io/15127074753393.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15127074753393/15127075000371.jpg" alt=""/></p>

<pre><code class="language-c++">/*
// Employee info
class Employee {
public:
    // It&#39;s the unique ID of each node.
    // unique id of this employee
    int id;
    // the importance value of this employee
    int importance;
    // the id of direct subordinates
    vector&lt;int&gt; subordinates;
};
*/
class Solution {
public:
    int getImportance(vector&lt;Employee*&gt; employees, int id) {
        unordered_map&lt;int ,Employee*&gt; map;
        for(auto emp:employees){
            map[emp-&gt;id] = emp;
        }
        return help(map,id);
    }
    
    int help(unordered_map&lt;int, Employee*&gt;&amp; map, int id){
        int sum = map[id]-&gt;importance;
        for(auto element : map[id]-&gt;subordinates){
            sum += help(map, element);
        }
        return sum;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Single Number]]></title>
    <link href="https://lockxmonk.github.io/15127037334925.html"/>
    <updated>2017-12-08T11:28:53+08:00</updated>
    <id>https://lockxmonk.github.io/15127037334925.html</id>
    <content type="html"><![CDATA[
<p>Given an array of integers, every element appears twice except for one. Find that single one.</p>

<pre><code class="language-c++">class Solution {
public:
    int singleNumber(vector&lt;int&gt;&amp; nums) {
        sort(nums.begin(), nums.end());
        for (int i =0; i&lt;nums.size(); i++) {
            if (nums[i]!=nums[i+1]) {
                return nums[i];
            }else{
                i++;
            }
        }
        return -1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Nim Game]]></title>
    <link href="https://lockxmonk.github.io/15126366447476.html"/>
    <updated>2017-12-07T16:50:44+08:00</updated>
    <id>https://lockxmonk.github.io/15126366447476.html</id>
    <content type="html"><![CDATA[
<p>You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.</p>

<p>Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.</p>

<p>For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.</p>

<p>列举1~n情况，每4个一循环.</p>

<pre><code class="language-c++">class Solution {
public:
    bool canWinNim(int n) {
        return n%4!=0;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next Greater Element I]]></title>
    <link href="https://lockxmonk.github.io/15126354530210.html"/>
    <updated>2017-12-07T16:30:53+08:00</updated>
    <id>https://lockxmonk.github.io/15126354530210.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15126354530210/15126354552862.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; res;
        for(auto num1:findNums){
            for (int i = 0; i&lt;nums.size(); i++) {
                int log = 0;
                if (nums[i]==num1) {
                    for (int j = i; j&lt;nums.size(); j++) {
                        if (nums[j]&gt;num1) {
                            res.push_back(nums[j]);
                            log = 1;
                            break;
                        }
                    }
                    if (log == 0) res.push_back(-1);
                    break;
                }
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Island Perimeter]]></title>
    <link href="https://lockxmonk.github.io/15126325722591.html"/>
    <updated>2017-12-07T15:42:52+08:00</updated>
    <id>https://lockxmonk.github.io/15126325722591.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15126325722591/15126325750006.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int islandPerimeter(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
        int squNum = 0 ,log = 0;
        for (int i = 0; i&lt;grid.size(); i++) {
            for (int j = 0; j&lt;grid[0].size(); j++) {
                if (grid[i][j]==1) {
                    squNum++;
                    if (i!=0&amp;&amp;grid[i-1][j]==1) {
                        log+=2;
                    }
                    if (j!=grid[0].size()-1&amp;&amp;grid[i][j+1]==1) {
                        log+=2;
                    }
                }
            }
        }
        return squNum*4-log;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hamming Distance]]></title>
    <link href="https://lockxmonk.github.io/15126119727244.html"/>
    <updated>2017-12-07T09:59:32+08:00</updated>
    <id>https://lockxmonk.github.io/15126119727244.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15126119727244/15126119824070.jpg" alt=""/></p>

<p>利用按位异或操作<code>^</code>来标记不同的位置。<br/>
<code>c++<br/>
class Solution {<br/>
public:<br/>
    int hammingDistance(int x, int y) {<br/>
        int tmp = x^y;<br/>
        int res = 0;<br/>
        while (tmp) {<br/>
            if ((tmp&gt;&gt;1)&lt;&lt;1!=tmp) {<br/>
                res++;<br/>
            }<br/>
            tmp&gt;&gt;=1;<br/>
        }<br/>
        return res;<br/>
    }<br/>
};<br/>
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Keyboard Row]]></title>
    <link href="https://lockxmonk.github.io/15125498375074.html"/>
    <updated>2017-12-06T16:43:57+08:00</updated>
    <id>https://lockxmonk.github.io/15125498375074.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15125498375074/15125498549999.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) {
        set&lt;char&gt; row1 = {&#39;q&#39;, &#39;w&#39;, &#39;e&#39;, &#39;r&#39;, &#39;t&#39;, &#39;y&#39;,&#39;u&#39;, &#39;i&#39;, &#39;o&#39;, &#39;p&#39;};
        set&lt;char&gt; row2 = {&#39;a&#39;, &#39;s&#39;, &#39;d&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;};
        set&lt;char&gt; row3 = { &#39;z&#39;, &#39;x&#39;, &#39;c&#39;, &#39;v&#39;, &#39;b&#39; ,&#39;n&#39;, &#39;m&#39;};
        vector&lt;set&lt;char&gt;&gt; rows = {row1,row2,row3};
        vector&lt;string&gt; res;
        for (auto str: words) {
            int log = 0;
            for (int i = 0; i&lt;rows.size(); i++) {
                if (rows[i].count((char)tolower(str[0]))&gt;0) {
                    log = i;
                }
            }
            for (int j = 0; j&lt;str.length(); j++) {
                if (rows[log].count((char)tolower(str[j]))==0) {
                    break;
                }
                if (j==str.length()-1) {
                    res.push_back(str);
                }
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Repeated String Match]]></title>
    <link href="https://lockxmonk.github.io/15125446581353.html"/>
    <updated>2017-12-06T15:17:38+08:00</updated>
    <id>https://lockxmonk.github.io/15125446581353.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15125446581353/15125446683319.jpg" alt=""/></p>

<p>要考虑<code>&quot;abc&quot; &quot;abc&quot; &quot;abc&quot;</code>和<code>&quot;c abc a&quot;</code>的情况，所以<code>i&lt;=lenB/lenA+2</code><br/>
<code>c++<br/>
class Solution {<br/>
public:<br/>
    int repeatedStringMatch(string A, string B) {<br/>
        int lenA = A.length(),lenB = B.length();<br/>
        string tmp = A;<br/>
        for (int i = 1; i&lt;=lenB/lenA+2; i++ , tmp+=A) {<br/>
            if (tmp.find(B)!=string::npos) {<br/>
                return i;<br/>
            }<br/>
        }<br/>
        return -1;<br/>
    }<br/>
};<br/>
</code></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Number of Segments in a String]]></title>
    <link href="https://lockxmonk.github.io/15125415026569.html"/>
    <updated>2017-12-06T14:25:02+08:00</updated>
    <id>https://lockxmonk.github.io/15125415026569.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15125415026569/15125415108675.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int countSegments(string s) {
        int res = 0;
        for (int i = 0; i&lt;s.length(); i++) {
            if (s[i]!=&#39; &#39;&amp;&amp; (s[i+1]==&#39; &#39;|| i==s.length()-1)) {
                res++;
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Battleships in a Board]]></title>
    <link href="https://lockxmonk.github.io/15124598875437.html"/>
    <updated>2017-12-05T15:44:47+08:00</updated>
    <id>https://lockxmonk.github.io/15124598875437.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15124598875437/15124598979272.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) {
        int m = board.size();
        int n = board[0].size();
        int res = 0;
        for (int i=0; i&lt;m; i++) {
            for (int j =0; j&lt;n; j++) {
                if ((board[i][j]==&#39;X&#39;)&amp;&amp;(i==0||board[i-1][j]!=&#39;X&#39;)&amp;&amp;(j==0||board[i][j-1]!=&#39;X&#39;)) {
                    ++res;
                }
            }
        }
        return res;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Complex Number Multiplication]]></title>
    <link href="https://lockxmonk.github.io/15124576449217.html"/>
    <updated>2017-12-05T15:07:24+08:00</updated>
    <id>https://lockxmonk.github.io/15124576449217.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15124576449217/15124576549963.jpg" alt=""/></p>

<p>第一次写的复杂版：</p>

<pre><code class="language-c++">string complexNumberMultiply(string a, string b) {
    int a1=0 ,b1=0 ,a2=0 ,b2=0;
    for (int i = 0; i&lt;a.length(); i++) {
        int log = 0;
        if (a[i]==&#39;+&#39;) {
            log = i;
            string tmp;
            for (int j=0; j&lt;i; j++) {
                tmp+=a[j];
            }
            sscanf(tmp.c_str(), &quot;%d&quot;,&amp;a1);
            tmp = &quot;&quot;;
            for (int m = i+1; m&lt;a.length()-1; m++) {
                tmp+=a[m];
            }
            sscanf(tmp.c_str(), &quot;%d&quot;,&amp;b1);
        }
    }
    for (int i = 0; i&lt;b.length(); i++) {
        int log = 0;
        if (b[i]==&#39;+&#39;) {
            log = i;
            string tmp;
            for (int j=0; j&lt;i; j++) {
                tmp+=b[j];
            }
            sscanf(tmp.c_str(), &quot;%d&quot;,&amp;a2);
            tmp = &quot;&quot;;
            for (int m = i+1; m&lt;b.length()-1; m++) {
                tmp+=b[m];
            }
            sscanf(tmp.c_str(), &quot;%d&quot;,&amp;b2);
        }
    }
    string res = to_string(a1*a2-b1*b2)+&quot;+&quot;+to_string(a1*b2+a2*b1)+&quot;i&quot;;
    return res;
}
</code></pre>

<p>精简版：</p>

<pre><code class="language-c++">class Solution {
public:
    string complexNumberMultiply(string a, string b) {
        int c,d,e,f;
        char ret[100];
        sscanf(a.c_str(),&quot;%d+%di&quot;,&amp;c,&amp;d);
        sscanf(b.c_str(),&quot;%d+%di&quot;,&amp;e,&amp;f);
        cout&lt;&lt;c&lt;&lt;&quot; &quot;&lt;&lt;d&lt;&lt;&quot; &quot;&lt;&lt;e&lt;&lt;&quot; &quot;&lt;&lt;f&lt;&lt;endl;
        sprintf(ret,&quot;%d+%di&quot;,(c*e-f*d),(d*e+c*f));
        string ans(ret);
        return ans;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Student Attendance Record I]]></title>
    <link href="https://lockxmonk.github.io/15124550672696.html"/>
    <updated>2017-12-05T14:24:27+08:00</updated>
    <id>https://lockxmonk.github.io/15124550672696.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15124550672696/15124551477663.jpg" alt=""/></p>

<p>优化前：<br/>
<code>c++<br/>
bool checkRecord(string s) {<br/>
    int logA = 0;<br/>
    for (int i=0; i&lt;s.length(); i++) {<br/>
        if (s[i]==&#39;A&#39;) {<br/>
            logA++;<br/>
            if (logA&gt;1) {<br/>
                return 0;<br/>
            }<br/>
        }<br/>
        if (i&gt;1&amp;&amp;s[i]==&#39;L&#39;&amp;&amp;s[i-1]==&#39;L&#39;&amp;&amp;s[i-2]==&#39;L&#39;) {<br/>
            return 0;<br/>
        }<br/>
    }<br/>
    return 1;<br/>
}<br/>
</code></p>

<p>优化后：</p>

<pre><code class="language-c++">class Solution {
public:
    bool checkRecord(string s) {
        int count_A = 0;
        int pos = 0;
        while(pos&lt;s.length())
        {
            if(s[pos]==&#39;A&#39;)
            {
                count_A++;
                pos++;
                if(count_A&gt;1)
                    return false;
            }
            else if(s[pos]==&#39;L&#39;)
            {
                int count = 0;
                while(pos&lt;s.length()&amp;&amp;s[pos]==&#39;L&#39;)
                {
                    count++;
                    pos++;
                }
                if(count&gt;2)
                    return false;
            }
            else
                pos++;
            
        }
        return true;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Baseball Game]]></title>
    <link href="https://lockxmonk.github.io/15124490673294.html"/>
    <updated>2017-12-05T12:44:27+08:00</updated>
    <id>https://lockxmonk.github.io/15124490673294.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15124490673294/15124490974323.jpg" alt=""/><br/>
<img src="media/15124490673294/15124491075954.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int calPoints(vector&lt;string&gt;&amp; ops) {
        int sum = 0, score = 0;
        vector&lt;int&gt; rounds;
        for (string op : ops) {
            if (op == &quot;C&quot;) {
                sum -= rounds.back();
                rounds.pop_back();
                continue;
            }
            if (op == &quot;D&quot;) {
                sum += score = rounds.back() * 2;
            }
            else if (op == &quot;+&quot;) {
                sum += score = rounds[rounds.size() - 1] + rounds[rounds.size() - 2];
            }
            else {
                sum += score = stoi(op);
            }
            rounds.push_back(score);
        }
        return sum;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implement strStr()]]></title>
    <link href="https://lockxmonk.github.io/15123924891077.html"/>
    <updated>2017-12-04T21:01:29+08:00</updated>
    <id>https://lockxmonk.github.io/15123924891077.html</id>
    <content type="html"><![CDATA[
<p><img src="media/15123924891077/15123924935113.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int strStr(string haystack, string needle) {
        int j = 0;  //标记needle的初始位置
        int h = haystack.length(), n = needle.length();
        if (!n) {
            return 0;
        }
        for (int i =0; i&lt;h-n+1; i++) {
            int tmp = i;
            while (tmp&lt;h &amp;&amp; j&lt;n &amp;&amp; haystack[tmp]==needle[j]) {
                tmp++;
                j++;
            }
            if (j==n) {
                return i;
            }else{
                j=0;
            }
        }
        return -1;
    }
};
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[String Compression]]></title>
    <link href="https://lockxmonk.github.io/15123884479504.html"/>
    <updated>2017-12-04T19:54:07+08:00</updated>
    <id>https://lockxmonk.github.io/15123884479504.html</id>
    <content type="html"><![CDATA[
<p>Given an array of characters, compress it in-place.</p>

<p>The length after compression must always be smaller than or equal to the original array.</p>

<p>Every element of the array should be a character (not int) of length 1.</p>

<p>After you are done modifying the input array in-place, return the new length of the array.</p>

<p>Follow up:<br/>
Could you solve it using only O(1) extra space?</p>

<p><img src="media/15123884479504/15123884710226.jpg" alt=""/></p>

<pre><code class="language-c++">class Solution {
public:
    int compress(vector&lt;char&gt;&amp; chars) {
        int tol = 1;    //统计相同字符的数量
        for (int i = 0; i&lt;chars.size(); i++) {
            while (i!=chars.size()-1 &amp;&amp; chars[i]==chars[i+1]) {
                chars.erase(chars.begin()+i+1);
                tol++;
            }
            int log = 0; //标记插入数字是1的情况
            int logNum = 0;  //统计插入的数字个数
            while (log==1||tol!=1 &amp;&amp; tol&gt;0) {
                chars.insert(chars.begin()+i+1, char(tol%10+&#39;0&#39;));
                tol/=10;
                log = tol==1?tol:0;
                logNum++;
            }
            i+=logNum;
            tol = 1;
        }
        return chars.size();
    }
};
</code></pre>

]]></content>
  </entry>
  
</feed>
