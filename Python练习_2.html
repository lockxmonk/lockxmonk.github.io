<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Python练习 - LZH007
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="LZH007" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:lockxmonk.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; LZH007</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="Effective%20OC2.0.html">Effective OC2.0</a></li>
        
            <li><a href="English%20Study.html">English Study</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html">统计学习方法</a></li>
        
            <li><a href="Python%E7%BB%83%E4%B9%A0.html">Python练习</a></li>
        
            <li><a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html">图像去雾技术</a></li>
        
            <li><a href="iOS.html">iOS</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14932734930436.html">
                
                  <h1>I/O编程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">文件读写</a>
<ul>
<li>
<a href="#toc_1">读文件</a>
</li>
<li>
<a href="#toc_2">file-like Object</a>
</li>
<li>
<a href="#toc_3">二进制文件</a>
</li>
<li>
<a href="#toc_4">写文件</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">小结</a>
</li>
</ul>


<h2 id="toc_0">文件读写</h2>

<h3 id="toc_1">读文件</h3>

<p>要以读文件的模式来打开一个文件对象，使用Python内置的<code>open（）</code>函数，传入文件名和标识符：</p>

<pre><code class="language-py">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)
</code></pre>

<p>标示符&#39;r&#39;表示读，这样，我们就成功地打开了一个文件。</p>

<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：<br/>
<img src="media/14932734930436/14932737513488.jpg" alt=""/></p>

<p>如果文件打开成功，接下来，调用<code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，用一个<code>str</code>对象表示：<br/>
<img src="media/14932734930436/14932741526772.jpg" alt=""/></p>

<p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现。这种方法太麻烦。我们这里使用python所提供的方法：</p>

<p>Python引入了with语句来自动帮我们调用<code>close()</code>方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;r&#39;) as f:
    print f.read()
</code></pre>

<p><img src="media/14932734930436/14932743740546.jpg" alt=""/></p>

<p>这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p>

<p>调用<code>read()</code>会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取<code>size</code>个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p>

<p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;r&#39;) as f:
    for line in f.readlines():
        print(line.strip())  #把末尾的&#39;\n&#39;删掉
</code></pre>

<p><img src="media/14932734930436/14932746986776.jpg" alt=""/></p>

<h3 id="toc_2">file-like Object</h3>

<p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。</p>

<p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p>

<h3 id="toc_3">二进制文件</h3>

<p>前面讲的默认都是读取文本文件，并且是ASCII编码的文本文件。要读取二进制文件，比如图片、视频等等，用<code>rb</code>模式打开文件即可：<br/>
<img src="media/14932734930436/14932760233490.jpg" alt=""/></p>

<h3 id="toc_4">写文件</h3>

<p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p>

<pre><code class="language-py">&gt;&gt;&gt; f = open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;, &#39;w&#39;)
&gt;&gt;&gt; f.write(&#39;Hello, world!Again！&#39;)
&gt;&gt;&gt; f.close()
</code></pre>

<p>这里推荐直接调用with方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;w&#39;) as f:
    f.write(&#39;Hello, world!Again!&#39;)
</code></pre>

<p><img src="media/14932734930436/14932763793296.jpg" alt=""/></p>

<p><font color=red><strong>要注意的是一旦写入文件，原来文件中的内容会被删除！</strong></font></p>

<h2 id="toc_5">小结</h2>

<p>在Python中，文件读写是通过<code>open()</code>函数打开的文件对象完成的。使用<code>with</code>语句操作文件IO是个好习惯。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14932622908500.html">
                
                  <h1>文档测试</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>在python中我们可以执行那些在注释中的代码，来进行测试。</strong></p>

<p>当我们编写注释时，如果写上这样的注释：</p>

<pre><code class="language-py">def abs(n):
    &#39;&#39;&#39;
    Function to get absolute value of number.

    Example:

    &gt;&gt;&gt; abs(1)
    1
    &gt;&gt;&gt; abs(-1)
    1
    &gt;&gt;&gt; abs(0)
    0
    &#39;&#39;&#39;
    return n if n &gt;= 0 else (-n)
</code></pre>

<p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p>

<p><strong>并且，Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</strong></p>

<p><font color=red>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用...表示中间一大段烦人的输出。</font></p>

<p>让我们用doctest来测试上次编写的<code>Dict</code>类：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Dict(dict):
    
    &quot;&quot;&quot;
    Simple dict but also support access as x.y style

    &gt;&gt;&gt; d1 = Dict()
    &gt;&gt;&gt; d1[&#39;x&#39;] = 100
    &gt;&gt;&gt; d1.x
    100
    &gt;&gt;&gt; d1.y = 200
    &gt;&gt;&gt; d1[&#39;y&#39;]
    200
    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#39;3&#39;)
    &gt;&gt;&gt; d2.c
    &#39;3&#39;
    &gt;&gt;&gt; d2[&#39;empty&#39;]
    Traceback (most recent call last):
        ...
    KeyError: &#39;empty&#39;
    &gt;&gt;&gt; d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: &#39;Dict&#39; object has no attribute &#39;empty&#39;
    
    &quot;&quot;&quot;
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)
    def __getattr__(self,key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)
        else:
            pass
        finally:
            pass
    def __setattr__(self,key,value):
        self[key] = value
if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod()
</code></pre>

<p>如果什么输出都没有，说明我们编写的<code>doctest</code>运行都是正确的。<br/>
<img src="media/14932622908500/14932639594028.jpg" alt=""/><br/>
如果我们把</p>

<pre><code class="language-py">&gt;&gt;&gt; d2.c
    &#39;4&#39; #3改成4
</code></pre>

<p>运行后就会显示：</p>

<p><img src="media/14932622908500/14932640459265.jpg" alt=""/></p>

<p><strong>注意到最后两行代码。当模块正常导入时，doctest不会被执行。只有在命令行运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14928429198094.html">
                
                  <h1>单元测试</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>我们来编写一个<code>Dict</code>类，这个类的行为和<code>dict</code>一致，但是可以通过属性来访问，用起来就像下面这样：</p>

<pre><code>&gt;&gt;&gt; d = Dict(a=1, b=2)
&gt;&gt;&gt; d[&#39;a&#39;]
1
&gt;&gt;&gt; d.a
1
</code></pre>

<p>mydict.py代码为：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Dict(dict):

    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)

    def __getattr__(self, key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r &quot; &#39;Dict&#39; object has no atr &#39;%s&#39; &quot; % key)
        else:
            pass
        finally:
            pass

    def __setattr__(self, key, value):
        self[key] = value

</code></pre>

<p>为了编写单元测试，我们需要引入Python自带的<code>unittest</code>模块，编写<code>mydict_test.py</code>如下：</p>

<pre><code class="language-py">import unittest

from mydict import Dict


class TestDict(unittest.TestCase):

    def test_init(self):
        d = Dict(a=1, b=&#39;test&#39;)
        self.assertEquals(d.a, 1)
        self.assertEquals(d.b, &#39;test&#39;)
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d[&#39;key&#39;] = &#39;value&#39;
        self.assertEquals(d.key, &#39;value&#39;)

    def test_attr(self):
        d = Dict()
        d.key = &#39;value&#39;
        self.assertTrue(&#39;key&#39; in d)
        self.assertEquals(d[&#39;key&#39;], &#39;value&#39;)

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d[&#39;empty&#39;]

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError)
            value = d.empty

</code></pre>

<p>编写单元测试时，我们需要编写一个测试类，从<code>unittest.TestCase</code>继承。</p>

<p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p>

<p>对每一类测试都需要编写一个<code>test_xxx()</code>方法。由于<code>unittest.TestCase</code>提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是<code>assertEquals()：</code></p>

<pre><code class="language-py">self.assertEquals(abs(-1), 1) # 断言函数返回的结果与1相等
</code></pre>

<p>另一种重要的断言就是期待抛出指定类型的<code>Error</code>，比如通过<code>d[&#39;empty&#39;]</code>访问不存在的key时，断言会抛出<code>KeyError</code>：</p>

<pre><code class="language-py">with self.assertRaises(KeyError):
    value = d[&#39;empty&#39;]
</code></pre>

<p>而通过<code>d.empty</code>访问不存在的<code>key</code>时，我们期待抛出<code>AttributeError</code>：</p>

<pre><code class="language-py">with self.assertRaises(AttributeError):
    value = d.empty
</code></pre>

<h2 id="toc_0">运行单元测试</h2>

<p>一旦编写好单元测试，我们就可以运行单元测试。最简单的运行方式是在<code>mydict_test.py</code>的最后加上两行代码：</p>

<pre><code class="language-py">if __name__ == &#39;__main__&#39;:
    unittest.main()
</code></pre>

<p>这样就可以把<code>mydict_test.py</code>当做正常的python脚本运行：</p>

<p><img src="media/14928429198094/14928450280463.jpg" alt=""/></p>

<p>另一种更常见的方法是在命令行通过参数<code>-m unittest</code>直接运行单元测试:<br/>
<img src="media/14928429198094/14928451217135.jpg" alt=""/></p>

<p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p>

<h2 id="toc_1">setUp与tearDown</h2>

<p>可以在单元测试中编写两个特殊的<code>setUp()</code>和<code>tearDown()</code>方法。这两个方法会分别在每<strong>调用一个测试方法的前后分别被执行</strong>。</p>

<p><code>setUp()和tearDown()</code>方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在<code>setUp()</code>方法中连接数据库，在<code>tearDown()</code>方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码：</p>

<pre><code class="language-py">import unittest

from mydict import Dict

class TestDict(unittest.TestCase):

    def setUp(self):    
        print &#39;setUp...&#39;

    def tearDown(self):
        print &#39;tearDown...&#39;
    
    def test_init(self):    
        d = Dict(a=1, b=&#39;test&#39;)
        self.assertEquals(d.a, 1)   
        self.assertEquals(d.b, &#39;test&#39;)
        self.assertTrue(isinstance(d, dict))

    def test_key(self):
        d = Dict()
        d[&#39;key&#39;] = &#39;value&#39;
        self.assertEquals(d.key, &#39;value&#39;)

    def test_attr(self):
        d = Dict()
        d.key = &#39;value&#39;
        self.assertTrue(&#39;key&#39; in d)
        self.assertEquals(d[&#39;key&#39;], &#39;value&#39;)

    def test_keyerror(self):
        d = Dict()
        with self.assertRaises(KeyError):
            value = d[&#39;empty&#39;]

    def test_attrerror(self):
        d = Dict()
        with self.assertRaises(AttributeError):
            value = d.empty

if __name__ == &#39;__main__&#39;:
     unittest.main()
</code></pre>

<p><img src="media/14928429198094/14928470586520.jpg" alt=""/></p>

<h2 id="toc_2">总结</h2>

<ol>
<li><p>单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p></li>
<li><p>单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。</p></li>
<li><p>单元测试代码要非常简单，如果测试代码太复杂，那么测试代码本身就可能有bug。</p></li>
<li><p>单元测试通过了并不意味着程序就没有bug了，但是不通过程序肯定有bug。</p></li>
</ol>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14928307466218.html">
                
                  <h1>调试</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">断言</a>
</li>
<li>
<a href="#toc_1">logging</a>
</li>
<li>
<a href="#toc_2">pdb</a>
</li>
<li>
<a href="#toc_3">pdb.set_trace()</a>
</li>
<li>
<a href="#toc_4">IDE</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">总结</a>


<p>程序能一次写完并正常运行的概率很小，基本不超过1%。总会有各种各样的bug需要修正。有的bug很简单，看看错误信息就知道，有的bug很复杂，我们需要知道出错时，哪些变量的值是正确的，哪些变量的值是错误的，因此，需要一整套调试程序的手段来修复bug。</p>

<p>第一种方法简单直接粗暴有效，就是用<code>print</code>把可能有问题的变量打印出来看看.（这种方法不详细说明了，基本每个写代码的人都比较熟悉这种方法）</p>

<h2 id="toc_0">断言</h2>

<p>凡是用<code>print</code>来辅助查看的地方，都可以用断言<code>（assert）</code>来替代：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
def foo(s):
    n=int(s)
    assert n!=0,&#39;n is zero&#39;
    return 10/n
def main():
    foo(&#39;0&#39;)
main()
</code></pre>

<p><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，后面的代码就会出错。</p>

<p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code>：</p>

<p><img src="media/14928307466218/14928311015673.jpg" alt=""/><br/>
启动Python解释器时可以用<code>-O</code>参数来关闭<code>assert</code></p>

<pre><code>$ python -O err.py
Traceback (most recent call last):
  ...
ZeroDivisionError: integer division or modulo by zero
</code></pre>

<p>关闭后，你可以把所有的<code>assert</code>语句当成<code>pass</code>来看。</p>

<h2 id="toc_1">logging</h2>

<p>把<code>print</code>替换为<code>logging</code>是第3种方式，和<code>assert</code>比，<code>logging</code>不会抛出错误，而且可以输出到文件：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import logging

s = &#39;0&#39;
n = int(s)
logging.info(&#39;n = %d&#39; % n)
print 10 / n
</code></pre>

<p><code>logging.info()</code>就可以输出一段文本。运行，发现除了<code>ZeroDivisionError</code>，没有任何信息。<br/>
<img src="media/14928307466218/14928313656997.jpg" alt=""/></p>

<p>加上：</p>

<pre><code class="language-py">import logging
logging.basicConfig(level=logging.INFO)
</code></pre>

<p>之后显示：<br/>
<img src="media/14928307466218/14928314465553.jpg" alt=""/><br/>
这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有<code>debug，info，warning，error</code>等几个级别，当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。同理，指定<code>level=WARNING</code>后，<code>debug和info</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>

<p><code>logging</code>的另一个好处是通过简单的配置，<strong>一条语句可以同时输出到不同的地方，比如console和文件</strong>。</p>

<h2 id="toc_2">pdb</h2>

<p>第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。我们先准备好程序：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
s = &#39;0&#39;
n = int(s)
print 10 / n
</code></pre>

<p>然后启动：<br/>
<img src="media/14928307466218/14928416845706.jpg" alt=""/></p>

<p>输入命令<code>l</code>来查看代码,输入命令<code>n</code>可以单步执行代码,任何时候都可以输入命令<code>p</code> 变量名来查看变量,输入命令<code>q</code>结束调试，退出程序.</p>

<h2 id="toc_3">pdb.set_trace()</h2>

<p>这个方法也是用<code>pdb</code>，但是不需要单步执行，我们只需要<code>import pdb</code>，然后，在可能出错的地方放一个<code>pdb.set_trace()</code>，就可以设置一个断点：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import pdb

s = &#39;0&#39;
n = int(s)
pdb.set_trace()  # 运行到这里会自动暂停
print 10 / n

</code></pre>

<p><img src="media/14928307466218/14928418957951.jpg" alt=""/><br/>
运行代码，程序会自动在<code>pdb.set_trace()</code>暂停并进入pdb调试环境，可以用命令<code>p</code>查看变量，或者用命令<code>c</code>继续运行</p>

<p>这个方式比直接启动pdb单步调试效率要高很多，但也高不到哪去。</p>

<h2 id="toc_4">IDE</h2>

<p>如果想要有好的设置断点、单步执行体验，就需要一个支持调试功能的IDE。目前比较好的<strong>Python IDE有PyCharm</strong>：<br/>
<a href="https://www.jetbrains.com/pycharm">https://www.jetbrains.com/pycharm</a></p>

<p>写程序最痛苦的事情莫过于调试，程序往往会以你意想不到的流程来运行，你期待执行的语句其实根本没有执行，这时候，就需要调试了。</p>

<h1 id="toc_5">总结</h1>

<p><strong>虽然用IDE调试起来比较方便，但是最后你会发现，<code>logging</code>才是终极武器。</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14928231077736.html">
                
                  <h1>错误、调试和测试</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">错误处理</a>
<ul>
<li>
<a href="#toc_1">try</a>
</li>
<li>
<a href="#toc_2">调用堆栈</a>
</li>
<li>
<a href="#toc_3">记录错误</a>
</li>
<li>
<a href="#toc_4">抛出错误</a>
</li>
</ul>
</li>
</ul>


<p>Python内置了一套异常处理机制，来帮助我们进行错误处理。</p>

<p>此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的<strong><em>pdb</em></strong>可以让我们以单步方式执行代码。</p>

<p>最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。</p>

<h2 id="toc_0">错误处理</h2>

<p>在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。在操作系统提供的调用中，返回错误码非常常见。比如打开文件的函数<code>open()</code>，成功时返回文件描述符（就是一个整数），出错时返回<code>-1</code>。</p>

<p>用错误码来表示是否出错十分不便，因为函数本身应该返回的正常结果和错误码混在一起，造成调用者必须用大量的代码来判断是否出错。</p>

<p>所以高级语言通常都内置了一套<code>try...except...finally...</code>的错误处理机制，Python也不例外。</p>

<h3 id="toc_1">try</h3>

<p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    print &#39;try...&#39;
    r = 10 / 0
    print &#39;result:&#39;, r
except ZeroDivisionError, e:
    print &#39;except:&#39;, e
finally:
    print &#39;finally...&#39;
print &#39;END&#39;
</code></pre>

<p><img src="media/14928231077736/14928238871411.jpg" alt=""/><br/>
从输出可以看到，当错误发生时，后续语句<code>print &#39;result:&#39;, r</code>不会被执行，<code>except</code>由于捕获到<code>ZeroDivisionError</code>，因此被执行。最后，<code>finally</code>语句被执行。然后，程序继续按照流程往下走。</p>

<p>你还可以猜测，错误应该有很多种类，如果发生了不同类型的错误，应该由不同的<code>except</code>语句块处理。没错，可以有多个<code>except</code>来捕获不同类型的错误：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    print &#39;try...&#39;
    r = 10 / int(0)
    print &#39;result:&#39;, r
except ValueError as e:
    print &#39;ValueError:&#39;,e
except ZeroDivisionError as e:
    print &#39;ZeroDivisionError:&#39;, e
else:
    print &#39;no error&#39;
finally:
    print &#39;finally...&#39;
print &#39;END&#39;
</code></pre>

<p><img src="media/14928231077736/14928249482640.jpg" alt=""/></p>

<p>Python的错误其实也是class，所有的错误类型都继承自<code>BaseException</code>，所以在使用<code>except</code>时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。比如：</p>

<pre><code class="language-py">try:
    foo()
except StandardError, e:
    print &#39;StandardError&#39;
except ValueError, e:
    print &#39;ValueError&#39;
</code></pre>

<p>第二个<code>except</code>永远也捕获不到<code>ValueError</code>，因为<code>ValueError是StandardError</code>的子类，如果有，也被第一个<code>except</code>给捕获了。</p>

<p>Python所有的错误都是从<code>BaseException</code>类派生的，常见的错误类型和继承关系看这里：</p>

<p><img src="media/14928231077736/14928254735561.jpg" alt=""/></p>

<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数<code>main()调用bar()，bar()调用foo()，结果foo()</code>出错了，这时，只要<code>main()</code>捕获到了，就可以处理：</p>

<pre><code class="language-py">def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar(&#39;0&#39;)
    except StandardError, e:
        print &#39;Error!&#39;
    finally:
        print &#39;finally...&#39;

print main()

</code></pre>

<p><img src="media/14928231077736/14928272805670.jpg" alt=""/></p>

<p>也就是说，不需要在每个可能出错的地方去捕获错误，只要在合适的层次去捕获错误就可以了。这样一来，就大大减少了写<code>try...except...finally</code>的麻烦。</p>

<h3 id="toc_2">调用堆栈</h3>

<p>如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    bar(&#39;0&#39;)

main()
</code></pre>

<p><img src="media/14928231077736/14928281628836.jpg" alt=""/><br/>
出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链。</p>

<p>从上往下依次查看错误。</p>

<h3 id="toc_3">记录错误</h3>

<p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p>

<p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
import logging

def foo(s):
    return 10 / int(s)

def bar(s):
    return foo(s) * 2

def main():
    try:
        bar(&#39;0&#39;)
    except StandardError as e:
        logging.exception(e)
    else:
        pass
    finally:
        pass
main()
print &#39;END&#39;
</code></pre>

<p><strong>同样是出错，但程序打印完错误信息后会继续执行，并正常退出</strong>：<br/>
<img src="media/14928231077736/14928284148150.jpg" alt=""/><br/>
最后打印出了“END”</p>

<p>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</p>

<h3 id="toc_4">抛出错误</h3>

<p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。</p>

<p>如果要抛出错误，首先根据需要，可以定义一个错误的<code>class</code>，选择好继承关系，然后，用<code>raise</code>语句抛出一个错误的实例</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
class FooError(StandardError):
    pass

def foo(s):
    n = int(s)
    if n == 0:
        raise FooError(&#39;invaild value: %s&#39; % s)
    return 10/0
foo(0)
</code></pre>

<p><img src="media/14928231077736/14928288600479.jpg" alt=""/></p>

<p><strong>只有在必要的时候才定义我们自己的错误类型。如果可以选择Python已有的内置的错误类型（比如ValueError，TypeError），尽量使用Python内置的错误类型。</strong></p>

<p>最后，我们来看另一种错误处理的方式：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
def foo(s):
    n = int(s)
    return 10 / n

def bar(s):
    try:
        return foo(s) * 2
    except StandardError, e:
        print &#39;Error!&#39;
        raise

def main():
    bar(&#39;0&#39;)

main()
</code></pre>

<p><img src="media/14928231077736/14928306395157.jpg" alt=""/></p>

<p>在bar()函数中，我们明明已经捕获了错误，但是，打印一个<code>Error</code>!后，又把错误通过<code>raise</code>语句抛出去了，这不有病么？</p>

<p>其实这种错误处理方式不但没病，而且相当常见。捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p>

<p>raise语句如果不带参数，就会把当前错误原样抛出。此外，在except中raise一个Error，还可以把一种类型的错误转化成另一种类型：</p>

<pre><code class="language-py">try:
    10 / 0
except ZeroDivisionError:
    raise ValueError(&#39;input error!&#39;)
</code></pre>

<p>只要是合理的转换逻辑就可以，但是，决不应该把一个<code>IOError</code>转换成毫不相干的<code>ValueError</code></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14927355881897.html">
                
                  <h1>使用元类</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">metaclass</a>
</li>
</ul>


<p>动态语言和静态语言最大的不同，就是函数和类的定义，不是编译时定义的，而是<strong>运行时动态创建的</strong>。</p>

<p>比方说我们要定义一个<code>Hello</code>的class：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Hello(object):
    def hello(self, name=&#39;world&#39;):
        print(&#39;Hello, %s.&#39; % name)
h = Hello()
h.hello()
print (type(Hello))
print (type(h))
</code></pre>

<p><img src="media/14927355881897/14927620006235.jpg" alt=""/></p>

<p><font color=red><strong><code>type()</code>函数可以查看一个类型或变量的类型，<code>Hello</code>是一个class，它的类型就是<code>type</code>，而<code>h</code>是一个实例，它的类型就是<code>class Hello</code>。</strong></font></p>

<p>我们说class的定义是运行时动态创建的，而<strong>创建class的方法就是使用<code>type()</code>函数</strong>。</p>

<p><code>type()</code>函数既可以返回一个对象的类型，又可以创建出新的类型，比如，<strong>我们可以通过<code>type()</code>函数创建出Hello类，而无需通过<code>class Hello(object)...</code>的定义</strong>：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
def fn(self, name=&#39;world&#39;):   # 先定义函数
    print(&#39;Hello, %s.&#39; % name)

Hello = type(&#39;Hello&#39;, (object,), dict(hello=fn))  # 创建Hello class
h = Hello()
h.hello()
print(type(Hello))
print(type(h))

</code></pre>

<p><img src="media/14927355881897/14927623112362.jpg" alt=""/></p>

<p><strong>要创建一个class对象，type()函数依次传入3个参数：</strong></p>

<ol>
<li>class的名称；</li>
<li>继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；</li>
<li>class的方法名称与函数绑定，这里我们把函数<code>fn</code>绑定到方法名<code>hello</code>上。</li>
</ol>

<p>通过<code>type()</code>函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p>

<blockquote>
<p>正常情况下，我们都用<code>class Xxx...</code>来定义类，但是，<code>type()</code>函数也允许我们动态创建出类来，也就是说，动态语言本身支持运行期动态创建类，这和静态语言有非常大的不同，要在静态语言运行期创建类，必须构造源代码字符串再调用编译器，或者借助一些工具生成字节码实现，本质上都是动态编译，会非常复杂。</p>
</blockquote>

<h2 id="toc_0">metaclass</h2>

<p>除了使用<code>type()</code>动态创建类以外，要控制类的创建行为，还可以使用metaclass。<br/>
简单的解释就是：先定义metaclass，就可以创建类，最后创建实例。</p>

<p>所以，metaclass允许你创建类或者修改类。换句话说，你可以把类看成是metaclass创建出来的“实例”。</p>

<p><strong>metaclass是Python面向对象里最难理解，也是最难使用的魔术代码。正常情况下，你不会碰到需要使用metaclass的情况，所以，以下内容看不懂也没关系，因为基本上你不会用到。</strong></p>

<p>我们先看一个简单的例子，这个metaclass可以给我们自定义的MyList增加一个add方法：</p>

<p>定义<code>ListMetaclass</code>，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

# metaclass是创建类，所以必须从`type`类型派生：
class ListMetaclass(type):

    def __new__(cls, name, bases, attrs):
        attrs[&#39;add&#39;] = lambda self, value: self.append(value)
        return type.__new__(cls, name, bases, attrs)


class MyList(list):
    __metaclass__ = ListMetaclass  # 指示使用ListMetaclass来定制类
</code></pre>

<p>当我们写下<code>__metaclass__ = ListMetaclass</code>语句时，魔术就生效了，它指示Python解释器在创建<code>MyList</code>时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>

<p><code>__new__()</code><strong>方法接收到的参数依次是</strong>：</p>

<ol>
<li><p>当前准备创建的类的对象；</p></li>
<li><p>类的名字；</p></li>
<li><p>类继承的父类集合；</p></li>
<li><p>类的方法集合。</p></li>
</ol>

<p>我们测试输出为：</p>

<pre><code class="language-py">L = MyList()
L.add(1)
print L
</code></pre>

<p><img src="media/14927355881897/14927637008533.jpg" alt=""/></p>

<p>动态修改有什么意义？直接在MyList定义中写上add()方法不是更简单吗？正常情况下，确实应该直接写，通过metaclass修改纯属变态。</p>

<p>但是，总会遇到需要通过metaclass修改类定义的。ORM就是一个典型的例子。</p>

<p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</p>

<p>要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p>

<p>具体方法参见<a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/001386820064557c69858840b4c48d2b8411bc2ea9099ba000">廖老师的教学网站</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Python练习_1.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Python练习_3.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>LZH007</h1>
                <div class="site-des">LZH的技术杂事小博客~</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Effective%20OC2.0.html"><strong>Effective OC2.0</strong></a>
        
            <a href="English%20Study.html"><strong>English Study</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html"><strong>统计学习方法</strong></a>
        
            <a href="Python%E7%BB%83%E4%B9%A0.html"><strong>Python练习</strong></a>
        
            <a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html"><strong>图像去雾技术</strong></a>
        
            <a href="iOS.html"><strong>iOS</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14956154840973.html">hashlib</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14956131169957.html">在ios中判断一个viewcontroller是都已经正常present</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14955929300450.html">Caffe代码梳理</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14955245049549.html">运行caffe框架中的cifar10样例</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14955029237844.html">Struct</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
