<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Python练习 - LZH007
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="LZH007" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:lockxmonk.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; LZH007</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="MAC%20OS.html">MAC OS</a></li>
        
            <li><a href="Effective%20OC2.0.html">Effective OC2.0</a></li>
        
            <li><a href="English%20Study.html">English Study</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html">统计学习方法</a></li>
        
            <li><a href="Python%E7%BB%83%E4%B9%A0.html">Python练习</a></li>
        
            <li><a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html">图像去雾技术</a></li>
        
            <li><a href="iOS.html">iOS</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14936919183368.html">
                
                  <h1>多线程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">Lock</a>
</li>
<li>
<a href="#toc_1">小结</a>
</li>
</ul>


<p>多任务可以由多进程完成，也可以由一个进程内的多线程完成。</p>

<p>我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。</p>

<p>由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。</p>

<p>Python的标准库提供了两个模块：<code>thread</code>和<code>threading</code>，<code>thread</code>是低级模块，<code>threading</code>是高级模块，对<code>thread</code>进行了封装。绝大多数情况下，我们只需要使用<code>threading</code>这个高级模块。</p>

<p>启动一个线程就是把一个函数传入并创建<code>Thread</code>实例，然后调用<code>start()</code>开始执行：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import time,threading

#新线程执行的代码
def loop():
    print &#39;thread %s is running...&#39; % threading.current_thread().name
    n = 0
    while n&lt;5:
        n = n+1
        print &#39;thread %s &gt;&gt;&gt; %s&#39; %(threading.current_thread().name,n)
        time.sleep(1)
    print &#39;thread %s ended.&#39; %threading.current_thread().name

print &#39;thread %s is running...&#39; % threading.current_thread().name
t= threading.Thread(target=loop,name=&#39;LoopThread&#39;)
t.start()
t.join()
print &#39;thread %s ended.&#39; % threading.current_thread().name
</code></pre>

<p><img src="media/14936919183368/14936948712548.jpg" alt=""/></p>

<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的<code>threading</code>模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1，Thread-2……</code></p>

<h2 id="toc_0">Lock</h2>

<p>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，<strong>而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</strong></p>

<p>来看看多个线程同时操作一个变量怎么把内容给改乱了：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import time,threading

# 假定这是你的银行存款:
balance = 0

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print balance
</code></pre>

<p><img src="media/14936919183368/14936957737021.jpg" alt=""/><br/>
结果为<code>14</code>而不是<code>0</code></p>

<p>我们定义了一个共享变量<code>balance</code>，初始值为0，并且启动两个线程，先存后取，理论上结果应该为0，但是，由于线程的调度是由操作系统决定的，当<code>t1、t2</code>交替执行时，只要循环次数足够多，<code>balance</code>的结果就不一定是0了。</p>

<p>我们为了得到准确的结果，在某个线程正在修改<code>balance</code>时就要为该线程上一把锁，直到锁释放，其它线程继续执行。创建一个锁就是通过<code>threading.Lock()</code>来实现：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import time,threading

# 假定这是你的银行存款:
balance = 0
lock=threading.Lock()

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        #先获取锁
        lock.acquire()
        try:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()
        
t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print balance
</code></pre>

<p><img src="media/14936919183368/14937055756329.jpg" alt=""/></p>

<p>当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。</p>

<p>获得锁的线程用完后一定要释放锁，否则那些苦苦等待锁的线程将永远等待下去，成为死线程。所以我们用<code>try...finally</code>来确保锁一定会被释放。</p>

<h2 id="toc_1">小结</h2>

<p>多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。</p>

<p><strong>Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦</strong></p>

<p><font color=red>Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。<br/>
</font></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14936863062791.html">
                
                  <h1>进程和线程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">多进程</a>
</li>
<li>
<a href="#toc_1">multiprocessing</a>
</li>
<li>
<a href="#toc_2">Pool</a>
</li>
<li>
<a href="#toc_3">进程间通信</a>
<ul>
<li>
<a href="#toc_4">小结</a>
</li>
</ul>
</li>
</ul>


<p>我们前面编写的所有的Python程序，都是执行单任务的进程，也就是只有一个线程。如果我们要同时执行多个任务怎么办</p>

<p>一种是启动多个进程，每个进程虽然只有一个线程，但多个进程可以一块执行多个任务。</p>

<p><strong>还有一种方法是启动一个进程，在一个进程内启动多个线程，这样，多个线程也可以一块执行多个任务。</strong></p>

<p>当然还有第三种方法，就是启动多个进程，每个进程再启动多个线程，这样同时执行的任务就更多了，当然这种模型更复杂，实际很少采用。</p>

<p>总结一下就是，多任务的实现有3种方式：</p>

<ul>
<li>多进程模式；</li>
<li>多线程模式；</li>
<li>多进程+多线程模式。</li>
</ul>

<blockquote>
<p>线程是最小的执行单元，而进程由至少一个线程组成。如何调度进程和线程，完全由操作系统决定，程序自己不能决定什么时候执行，执行多长时间。</p>
</blockquote>

<h2 id="toc_0">多进程</h2>

<p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是<code>fork()</code><font color=red>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回</font>。</p>

<p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p>

<p>Python的<code>os</code>模块封装了常见的系统调用，其中就包括<code>fork</code>，可以在Python程序中轻松创建子进程：</p>

<pre><code class="language-py">import os

print &#39;Process (%s) start&#39; %os.getpid()

pid = os.fork()
if pid == 0:
    print &#39;I am child process (%s) and my parent is %s.&#39; %(os.getpid(),os.getppid())
else:
    print &#39;I (%s) just created a child process (%s)&#39; %(os.getpid(),pid)
</code></pre>

<p><img src="media/14936863062791/14936874189758.jpg" alt=""/></p>

<p>第一次返回父进程，第二次返回子进程。所以分别打印出了不同的结果。</p>

<p>有了<code>fork</code>调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p>

<h2 id="toc_1">multiprocessing</h2>

<p>如果你打算编写多进程的服务程序，Unix/Linux无疑是正确的选择。由于Windows没有<code>fork</code>调用，难道在Windows上无法用Python编写多进程的程序？</p>

<p>由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。<code>multiprocessing</code>模块就是跨平台版本的多进程模块。</p>

<p><code>multiprocessing</code>模块提供了一个<code>Process</code>类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
from multiprocessing import Process

import os

# 子进程要执行的代码


def run_proc(name):
    print &#39;Run child process %s(%s)&#39; % (name, os.getpid())

if __name__ == &#39;__main__&#39;:
    print &#39;Parent process %s.&#39; % os.getpid()
p = Process(target=run_proc, args=(&#39;test&#39;,))
print &#39;Process will start.&#39;
p.start()
p.join()
print &#39;Process end&#39;
</code></pre>

<p><img src="media/14936863062791/14936889041171.jpg" alt=""/></p>

<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个<code>Process</code>实例，用<code>start()</code>方法启动，这样创建进程比<code>fork()</code>还要简单。</p>

<p><code>join()</code>方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>

<h2 id="toc_2">Pool</h2>

<p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>

<pre><code class="language-py">from multiprocessing import Pool
import os
import time
import random


def long_time_task(name):
    print &#39;Run task %s(%s)...&#39; % (name, os.getpid())
    start = time.time()
    time.sleep(random.random() * 3)
    end = time.time()
    print &#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start))

if __name__ == &#39;__main__&#39;:
    print &#39;Parent process %s.&#39; % os.getpid()
    p = Pool()
    for i in range(9):
        p.apply_async(long_time_task, args=(i,))
    print &#39;Waiting for all subprocesses done...&#39;
    p.close()
    p.join()
    print &#39;All subprocess done&#39;
</code></pre>

<p><img src="media/14936863062791/14936904615182.jpg" alt=""/></p>

<p>代码解读：</p>

<p>对<code>Pool</code>对象调用<code>join()</code>方法会等待所有子进程执行完毕，调用<code>join()</code>之前必须先调用<code>close()</code>，调用<code>close()</code>之后就不能继续添加新的<code>Process</code>了。</p>

<p>请注意输出的结果，task 0~7是立刻执行的，而task 8要等待前面某个task完成后才执行，这是因为Pool的默认大小在我的电脑上是8，因此，最多同时执行8个进程。这是Pool有意设计的限制，并不是操作系统的限制。如果改成：<code>p = Pool(9)</code></p>

<p>就可以同时跑9个进程。</p>

<p>由于Pool的默认大小是CPU的核数，如果你不幸拥有8核CPU，你要提交至少9个子进程才能看到上面的等待效果。</p>

<h2 id="toc_3">进程间通信</h2>

<p><code>Process</code>之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p>

<p>我们以<code>Queue</code>为例，在父进程中创建两个子进程，一个往<code>Queue</code>里写数据，一个从<code>Queue</code>里读数据：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

from multiprocessing import Process,Queue
import os,time,random

#写数据进程执行的代码
def write(q):
    for value in [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;]:
        print &#39;Put %s to quene...&#39; % value
        q.put(value)
        time.sleep(random.random())
#读数据进程执行的代码
def read(q):
    while True:
        value = q.get(True)
        print &#39;Get %s from quene.&#39; %value

if __name__==&#39;__main__&#39;:
    #父进程创建Quene,并传给各个子进程：
    q = Queue()
    pw = Process(target=write,args=(q,))
    pr = Process(target=read,args=(q,))
    #启动子进程pw，写入：
    pw.start()
    #启动子进程pr，读取：
    pr.start()
    #等待pw结束：
    pw.join()
    #pr进程里是死循环，无法等待其结束，只能强行终止：
    pr.terminate()

</code></pre>

<p><img src="media/14936863062791/14936917220576.jpg" alt=""/></p>

<p>在Unix/Linux下，<code>multiprocessing</code>模块封装了<code>fork()</code>调用，使我们不需要关注<code>fork()</code>的细节。由于Windows没有fork调用，因此，<code>multiprocessing</code>需要“模拟”出fork的效果，父进程所有Python对象都必须通过<code>pickle</code>序列化再传到子进程去，所有，如果<code>multiprocessing</code>在Windows下调用失败了，要先考虑是不是pickle失败了。</p>

<h3 id="toc_4">小结</h3>

<p>在Unix/Linux下，可以使用<code>fork()</code>调用实现多进程。</p>

<p>要实现跨平台的多进程，可以使用<code>multiprocessing</code>模块。</p>

<p>进程间通信是通过<code>Queue、Pipes</code>等实现的。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/2</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14933396433742.html">
                
                  <h1>序列化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">JSON</a>
</li>
<li>
<a href="#toc_1">JSON进阶</a>
</li>
<li>
<a href="#toc_2">小结</a>
</li>
</ul>


<p><strong>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</strong></p>

<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>

<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>

<p>Python提供两个模块来实现序列化：<code>cPickle</code>和<code>pickle</code>。这两个模块功能是一样的，区别在于<code>cPickle</code>是C语言写的，速度快，<code>pickle</code>是纯Python写的，速度慢，跟<code>cStringIO和StringIO</code>一个道理。用的时候，先尝试导入<code>cPickle</code>，如果失败，再导入<code>pickle</code>：</p>

<pre><code class="language-py">try:
    import cPickle as pickle
except ImportError:
    import pickle
</code></pre>

<p>我们尝试把一个对象序列化并写入文件：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

d = dict(name=&#39;LZH&#39;,age=20,score=88)
print pickle.dumps(d)
</code></pre>

<p><img src="media/14933396433742/14933403797179.jpg" alt=""/></p>

<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>str</code>，然后，就可以把这个<code>str</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

d = dict(name=&#39;梁中豪&#39;,age=20,score=88)
f = open(&#39;test.txt&#39;,&#39;wb&#39;)  
pickle.dump(d,f)
f.close

</code></pre>

<p><img src="media/14933396433742/14933405542811.jpg" alt=""/></p>

<p>我们可以读取文件中这些内容，并且将他们反序列化来显示原来的内容：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

#d = dict(name=&#39;梁中豪&#39;,age=20,score=88)
f = open(&#39;test.txt&#39;,&#39;rb&#39;)  
print pickle.load(f)
f.close

</code></pre>

<p>可以先把内容读到一个<code>str</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象</p>

<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>

<p>下面我们用JSON来进行网络间的数据传递。</p>

<h2 id="toc_0">JSON</h2>

<p>如果我们要在不同的编程语言之间传递对象，<strong>就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串</strong>，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>

<p><strong><code>JSON</code>表示的对象就是标准的<code>JavaScript</code>语言的对象，<code>JSON</code>和Python内置的数据类型对应如下：</strong></p>

<table>
<thead>
<tr>
<th>Json类型</th>
<th>Python类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>{}</td>
<td>dict</td>
</tr>
<tr>
<td>[]</td>
<td>list</td>
</tr>
<tr>
<td>string</td>
<td>str或u&#39;unicode&#39;</td>
</tr>
<tr>
<td>12345.56</td>
<td>int或float</td>
</tr>
<tr>
<td>true/false</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody>
</table>

<p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</p>

<pre><code class="language-py">import json
d = dict(name=&#39;Lichao&#39;, age=20, score=88)
print json.dumps(d)

</code></pre>

<p><img src="media/14933396433742/14933496188910.jpg" alt=""/></p>

<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的JSON。类似的，<code>dump()</code>方法可以直接把JSON写入一个<code>file-like Object</code>。</p>

<p>要把JSON反序列化为Python对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把JSON的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>

<pre><code class="language-py">import json
json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Lichao&quot;}&#39;
print json.loads(json_str)
</code></pre>

<p><img src="media/14933396433742/14933497889867.jpg" alt=""/></p>

<p>有一点需要注意，就是反序列化得到的所有字符串对象默认都是<code>unicode</code>而不是<code>str</code>。由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的<code>str或unicode</code>与JSON的字符串之间转换。</p>

<h2 id="toc_1">JSON进阶</h2>

<p>Python的<code>dict</code>对象可以直接序列化为JSON的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p>

<pre><code class="language-py">import json


class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;LiChao&#39;, 20, 88)
print(json.dumps(s))
</code></pre>

<p><img src="media/14933396433742/14933605238135.jpg" alt=""/><br/>
向上述那样调用，会报错，因为<code>Student</code>对象不是一个可序列化为JSON的对象。</p>

<p>我们仔细看看<code>dumps()</code>方法的参数列表，可以发现，除了第一个必须的<code>obj</code>参数外，<code>dumps()</code>方法还提供了一大堆的可选参数。</p>

<p>这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把<code>Student</code>类实例序列化为JSON，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个JSON的<code>{}</code>对象。</p>

<p>可选参数<code>default</code>就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p>

<pre><code class="language-py">import json

def student2dict(std):
    return {
    &#39;name&#39;:std.name,
    &#39;age&#39;:std.age,
    &#39;score&#39;:std.score
    }

class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;LiChao&#39;, 20, 88)
print(json.dumps(s,default=student2dict))
</code></pre>

<p><img src="media/14933396433742/14933609788679.jpg" alt=""/></p>

<p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为<code>JSON</code>。</p>

<p><strong>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为<code>JSON</code>。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</strong></p>

<pre><code class="language-py">print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>

<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p>

<p>同样的道理，如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个dict对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p>

<pre><code class="language-py">import json

def dict2students(d):
    return Student(d[&#39;name&#39;],d[&#39;age&#39;],d[&#39;score&#39;])

class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;
print(json.loads(json_str,object_hook=dict2students))
</code></pre>

<p><img src="media/14933396433742/14933619206509.jpg" alt=""/></p>

<p>打印出的是反序列化的<code>Student</code>实例对象。</p>

<h2 id="toc_2">小结</h2>

<p>Python语言特定的序列化模块是<code>pickle</code>，但如果要把序列化搞得更通用、更符合Web标准，就可以使用<code>json</code>模块。</p>

<p><code>json</code>模块的<code>dumps()和loads()</code>函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14932778418691.html">
                
                  <h1>操作文件和目录</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">环境变量</a>
</li>
<li>
<a href="#toc_1">操作文件和目录</a>
</li>
<li>
<a href="#toc_2">小结</a>
</li>
<li>
<a href="#toc_3">练习：</a>
</li>
</ul>


<p>如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如<code>dir</code>、<code>cp</code>等命令</p>

<p>Python内置的<code>os</code>模块也可以直接调用操作系统提供的接口函数。</p>

<p>打开Python交互式命令行，我们来看看如何使用<code>os</code>模块的基本功能：</p>

<p><img src="media/14932778418691/14932780434722.jpg" alt=""/></p>

<p>注意<code>uname()</code>函数在Windows上不提供，也就是说，os模块的某些函数是跟操作系统相关的。</p>

<h2 id="toc_0">环境变量</h2>

<p>在操作系统中定义的环境变量，全部保存在<code>os.environ</code>这个<code>dict</code>中，可以直接查看：<br/>
<img src="media/14932778418691/14932785335515.jpg" alt=""/></p>

<p>要获取某个环境变量的值，可以调用<code>os.getenv()</code>函数：</p>

<p><img src="media/14932778418691/14932786096064.jpg" alt=""/></p>

<h2 id="toc_1">操作文件和目录</h2>

<p>操作文件和目录的函数一部分放在os模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print os.path.abspath(&#39;.&#39;)
print os.path.join(&#39;/Users/liangzhonghao/Desktop/&#39;,&#39;test&#39;)

#os.mkdir(&#39;/Users/liangzhonghao/Desktop/python&#39;)
os.rmdir(&#39;/Users/liangzhonghao/Desktop/python&#39;)
</code></pre>

<p><img src="media/14932778418691/14932791801381.jpg" alt=""/></p>

<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print os.path.splitext(&#39;/Users/liangzhonghao/Desktop/text.txt&#39;)
</code></pre>

<p><img src="media/14932778418691/14932792804815.jpg" alt=""/></p>

<p><strong>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</strong></p>

<p><code>os</code>模块有很多功能，例如重命名文件，删除文件。但是他没有复制文件的功能。因为复制文件并非是由操作系统提供的系统调用。</p>

<p>幸运的是<code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p>

<p><strong>最后看看如何利用Python的特性来过滤文件</strong>。比如我们要列出当前目录下的所有目录，只需要一行代码：</p>

<pre><code class="language-py">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]
</code></pre>

<p><img src="media/14932778418691/14932797710625.jpg" alt=""/></p>

<p>要列出所有的.py文件，也只需一行代码：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#39;.py&#39;]
</code></pre>

<p><img src="media/14932778418691/14932798281538.jpg" alt=""/></p>

<h2 id="toc_2">小结</h2>

<p>Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在<code>os.path</code>模块中</p>

<h2 id="toc_3">练习：</h2>

<p>编写一个<code>search(s)</code>的函数，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出完整路径：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os

def search(s ,dir=os.path.abspath(&#39;.&#39;)):
    for x in os.listdir(dir):
        path = os.path.join(dir,x)
        if s in x:
            print path
        elif os.path.isdir(path):
            search(s,path)

search(&#39;pr&#39;)

</code></pre>

<p><img src="media/14932778418691/14932810251430.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14932734930436.html">
                
                  <h1>I/O编程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">文件读写</a>
<ul>
<li>
<a href="#toc_1">读文件</a>
</li>
<li>
<a href="#toc_2">file-like Object</a>
</li>
<li>
<a href="#toc_3">二进制文件</a>
</li>
<li>
<a href="#toc_4">写文件</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">小结</a>
</li>
</ul>


<h2 id="toc_0">文件读写</h2>

<h3 id="toc_1">读文件</h3>

<p>要以读文件的模式来打开一个文件对象，使用Python内置的<code>open（）</code>函数，传入文件名和标识符：</p>

<pre><code class="language-py">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)
</code></pre>

<p>标示符&#39;r&#39;表示读，这样，我们就成功地打开了一个文件。</p>

<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：<br/>
<img src="media/14932734930436/14932737513488.jpg" alt=""/></p>

<p>如果文件打开成功，接下来，调用<code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，用一个<code>str</code>对象表示：<br/>
<img src="media/14932734930436/14932741526772.jpg" alt=""/></p>

<p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现。这种方法太麻烦。我们这里使用python所提供的方法：</p>

<p>Python引入了with语句来自动帮我们调用<code>close()</code>方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;r&#39;) as f:
    print f.read()
</code></pre>

<p><img src="media/14932734930436/14932743740546.jpg" alt=""/></p>

<p>这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p>

<p>调用<code>read()</code>会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取<code>size</code>个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p>

<p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;r&#39;) as f:
    for line in f.readlines():
        print(line.strip())  #把末尾的&#39;\n&#39;删掉
</code></pre>

<p><img src="media/14932734930436/14932746986776.jpg" alt=""/></p>

<h3 id="toc_2">file-like Object</h3>

<p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。</p>

<p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p>

<h3 id="toc_3">二进制文件</h3>

<p>前面讲的默认都是读取文本文件，并且是ASCII编码的文本文件。要读取二进制文件，比如图片、视频等等，用<code>rb</code>模式打开文件即可：<br/>
<img src="media/14932734930436/14932760233490.jpg" alt=""/></p>

<h3 id="toc_4">写文件</h3>

<p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p>

<pre><code class="language-py">&gt;&gt;&gt; f = open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;, &#39;w&#39;)
&gt;&gt;&gt; f.write(&#39;Hello, world!Again！&#39;)
&gt;&gt;&gt; f.close()
</code></pre>

<p>这里推荐直接调用with方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;w&#39;) as f:
    f.write(&#39;Hello, world!Again!&#39;)
</code></pre>

<p><img src="media/14932734930436/14932763793296.jpg" alt=""/></p>

<p><font color=red><strong>要注意的是一旦写入文件，原来文件中的内容会被删除！</strong></font></p>

<h2 id="toc_5">小结</h2>

<p>在Python中，文件读写是通过<code>open()</code>函数打开的文件对象完成的。使用<code>with</code>语句操作文件IO是个好习惯。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14932622908500.html">
                
                  <h1>文档测试</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>在python中我们可以执行那些在注释中的代码，来进行测试。</strong></p>

<p>当我们编写注释时，如果写上这样的注释：</p>

<pre><code class="language-py">def abs(n):
    &#39;&#39;&#39;
    Function to get absolute value of number.

    Example:

    &gt;&gt;&gt; abs(1)
    1
    &gt;&gt;&gt; abs(-1)
    1
    &gt;&gt;&gt; abs(0)
    0
    &#39;&#39;&#39;
    return n if n &gt;= 0 else (-n)
</code></pre>

<p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p>

<p><strong>并且，Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</strong></p>

<p><font color=red>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用...表示中间一大段烦人的输出。</font></p>

<p>让我们用doctest来测试上次编写的<code>Dict</code>类：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Dict(dict):
    
    &quot;&quot;&quot;
    Simple dict but also support access as x.y style

    &gt;&gt;&gt; d1 = Dict()
    &gt;&gt;&gt; d1[&#39;x&#39;] = 100
    &gt;&gt;&gt; d1.x
    100
    &gt;&gt;&gt; d1.y = 200
    &gt;&gt;&gt; d1[&#39;y&#39;]
    200
    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#39;3&#39;)
    &gt;&gt;&gt; d2.c
    &#39;3&#39;
    &gt;&gt;&gt; d2[&#39;empty&#39;]
    Traceback (most recent call last):
        ...
    KeyError: &#39;empty&#39;
    &gt;&gt;&gt; d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: &#39;Dict&#39; object has no attribute &#39;empty&#39;
    
    &quot;&quot;&quot;
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)
    def __getattr__(self,key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)
        else:
            pass
        finally:
            pass
    def __setattr__(self,key,value):
        self[key] = value
if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod()
</code></pre>

<p>如果什么输出都没有，说明我们编写的<code>doctest</code>运行都是正确的。<br/>
<img src="media/14932622908500/14932639594028.jpg" alt=""/><br/>
如果我们把</p>

<pre><code class="language-py">&gt;&gt;&gt; d2.c
    &#39;4&#39; #3改成4
</code></pre>

<p>运行后就会显示：</p>

<p><img src="media/14932622908500/14932640459265.jpg" alt=""/></p>

<p><strong>注意到最后两行代码。当模块正常导入时，doctest不会被执行。只有在命令行运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="Python练习_1.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Python练习_3.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>LZH007</h1>
                <div class="site-des">LZH的技术杂事小博客~</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="MAC%20OS.html"><strong>MAC OS</strong></a>
        
            <a href="Effective%20OC2.0.html"><strong>Effective OC2.0</strong></a>
        
            <a href="English%20Study.html"><strong>English Study</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html"><strong>统计学习方法</strong></a>
        
            <a href="Python%E7%BB%83%E4%B9%A0.html"><strong>Python练习</strong></a>
        
            <a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html"><strong>图像去雾技术</strong></a>
        
            <a href="iOS.html"><strong>iOS</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14980252836745.html">MAC下openBlas的安装</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14980135145677.html">Caffe中的Net</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14974936829967.html">Caffe中Layer的学习</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14974281629389.html">怎样移除OSXRESERVED分区(如果BootCamp Assistant在安装之后没有成功删除这个分区)</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14974276192148.html">重新利用boot camp安装win10</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
