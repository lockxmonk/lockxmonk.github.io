<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  LZH007
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="LZH007" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:lockxmonk.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; LZH007</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="MAC%20OS.html">MAC OS</a></li>
        
            <li><a href="Effective%20OC2.0.html">Effective OC2.0</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html">统计学习方法</a></li>
        
            <li><a href="Python%E7%BB%83%E4%B9%A0.html">Python练习</a></li>
        
            <li><a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html">图像去雾技术</a></li>
        
            <li><a href="iOS.html">iOS</a></li>
        
            <li><a href="English%20Study.html">English Study</a></li>
        
            <li><a href="%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0.html">算法学习</a></li>
        
            <li><a href="%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98.html">常见面试问题</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="15033908572762.html">
                
                  <h1>第十二条 消息转发机制(Message forwarding)</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>第11条讲解了对象的消息传递机制，并强调了其重要性。第12条则要讲解另外一个重要的问题，就是对象在收到无法解读的消息之后会发生什么情况。若想令类能理解某条消息，我们必须以程序码实现出对应的方法才行。<font color=red><strong>但是，在编译期向类发送了其无法解读的消息并不会报错，因为在运行期可以继续向类中添加方法，所以编译器在编译时还无法确知类中到底会不会有某个方法实现。</strong></font>当对象接收到无法解读的消息后，就会启动<mark>“消息转发&quot;（message forwarding)机制</mark>，程序员可经由此过程告沂对象应该如何处理未知消息。</p>

<p>消息转发分为两大阶段:</p>

<ol>
<li><p>先征询接收者，所属的类，看其是否能动态添加方法，以处理当前这个“未知的选择子&quot;（unknown selector),这叫做“动态方法解析”（dynamic method resolution)。</p></li>
<li><p>涉及“完整的消息转发机制”（full forwarding mechanism)。如果运行期系统已经把第一阶段执行完了，那么接收者自己就无法再以动态新增方法的手段来响应包含该选择子的消息了。此时，运行期系统会请求接收者以其他手段来处理与消息相关的方法调用。这又细分为<strong>两小步</strong>。首先，请接收者看看有没有其他对象能处理这条消息。若有，则运行期系统会把消息转给那个对象，于是消息转发过程结束，一切如常。若没有“备援的接收者”（replacement receiver)，则启动完整的消息转发机制，运行期系统会把与消息有关的全部细节都封装到<code>NSInvocation</code>对象中，再给接收者最后一次机会，令其设法解决当前还未处理的这条消息。</p></li>
</ol>

<h2 id="toc_0">动态方法解析</h2>

<p>对象在收到无法解读的消息后，首先将调用其所属类的下列类方法：</p>

<pre><code class="language-objc">
+ (BOOL)resolvelnstanceMethod:(SEL)selector

</code></pre>

<p>该方法的参数就是那个未知的选择子，其返回值为<code>Boolean</code>类型，表示这个类是否能新增一个实例方法用以处理此选择子。在继续往下执行转发机制之前，本类有机会新增一个处理此选择子的方法。假如尚未实现的方法不是实例方法而是类方法，那么运行期系统就会调用另外一个方法，该方法与 <code>“resolvelnstanceMethod:”</code> 类似，叫做 <code>“resolveClassMethod:”</code>。使用这种办法的前提是：相关方法的实现代码已经写好，只等着运行的时候动态插在类里面就可以了。此方案常用来实现<code>@dynamic</code>属性（参见第6条)，比如说，要访问<code>CoreData</code>框架中<code>NSManagedObjects</code>对象的属性时就可以这么做，因为实现这些属性所需的存取方法在编译期就能确定。</p>

<p>下列代码演示了如何用<code>“resolvelnstanceMethod:”</code>来实现<code>@dynamic</code>属性：</p>

<pre><code class="language-objc">
id autoDictionaryGetter(id self, SEL _cmd);
void autoDictionarySetter(id selff SEL _cmd, id value);
+ (BOOL)resolvelnstanceMethod:(SEL)selector {
    NSString *selectorString = NSStringFromSelector(selector);
    if ( /* selector is from a ©dynamic property ★/ ){
        if([selectorstring has Prefix: @&quot;set&quot;]){
            class addMethod(self,
                            selector,
                            (IMP)autoDictionarySetter,
                            &quot;v@ :@&quot;);
    } else {
        class_addMethod(self,
                        selector,
                        (IMP)autoDictionaryGetter,
                        &quot;@ @:&quot;);
        }              
        return YES;
    }
return [super resolvelnstanceMethod:selector];

}

</code></pre>

<h2 id="toc_1">备援接受者</h2>

<p>当前接收者还有第二次机会能处理未知的选择子，在这一步中，运行期系统会问它：能不能把这条消息转给其他接收者来处理。与该步骤对应的处理方法如下：</p>

<pre><code class="language-objc">
-(id)forwardingTargetForSelector:(SEL)selector

</code></pre>

<p>方法参数代表未知的选择子，若当前接收者能找到备援对象，则将其返回，若找不到，就返回<code>nil</code>。通过此方案，我们可以用“组合”（composition)来模拟出“多重继承”（multiple inheritance)的某些特性。在一个对象内部，可能还有一系列其他对象，该对象可经由此方法将能够处理某选择子的相关内部对象返回，这样的话，在外界看来，好像是该对象亲自处理了这些消息似的。</p>

<p><font color=red>请注意，我们无法操作经由这一步所转发的消息。若是想在发送给备援接收者之前先修改消息内容，那就得通过完整的消息转发机制来做了。</font></p>

<h2 id="toc_2">完整的消息转发</h2>

<p>如果转发算法已经来到这一步的话，那么唯一能做的就是启用完整的消息转发机制了。首先创建<code>NSInvocation</code>对象，把与尚未处理的那条消息有关的全部细节都封于其中。此对象包含选择子、目标（target)及参数。在触发NSIrwocation对象时，“消息派发系统”(message-dispatch system)将亲自出马，把消息指派给目标对象。<br/>
此步骤会调用下列方法来转发消息：</p>

<pre><code class="language-objc">
-(void)forwardlnvocation:(NSInvocation*)invocation

</code></pre>

<p>这个方法可以实现得很简单：只需改变调用目标，使消息在新目标上得以调用即可。然<br/>
而这样实现出来的方法与“备援接收者”方案所实现的方法等效，所以很少有人采用这么简<br/>
单的实现方式。比较有用的实现方式为：在触发消息前，先以某种方式改变消息内容，比如追加另外一个参数，或是改换选择子，等等。</p>

<p>实现此方法时，若发现某调用操作不应由本类处理，则需调用超类的同名方法。这样的话，继承体系中的每个类都有机会处理此调用请求，直至<code>NSObject</code>。如果最后调用了<code>NSObject</code>类的方法，那么该方法还会继而调用<code>“doesNotRecognizeSelector:”</code>以抛出异常，此异常表明选择子最终未能得到处理。</p>

<h2 id="toc_3">消息转发全流程</h2>

<p>下图展示了消息转发机制处理消息的各个步骤:<br/>
<img src="media/15033908572762/15033988345236.jpg" alt=""/></p>

<p><font color=red>接收者在每一步中均有机会处理消息。步骤越往后，处理消息的代价就越大。</font>最好能在第一步就处理完，这样的话，运行期系统就可以将此方法缓存起来了。如果这个类的实例稍后还收到同名选择子，那么根本无须启动消息转发流程。</p>

<h2 id="toc_4">完整的示例</h2>

<p>假设要编写一个类似于“字典”的对象，它里面可以容纳其他对象，只不过开发者要直接通过属性来存取其中的数据。这个类的设计思路是：由幵发者来添加属性定义，并将其声明为<code>@dynamic</code>，而类则会自动处理相关属性值的存放与获取操作。</p>

<p>定义该类的接口为:</p>

<pre><code class="language-objc">
#import &lt;Foundation/Foundation.h&gt;
@interface EOCAutoDictionary : NSObject
@property (nonatomic, strong) NSNumber *number;
@property (nonatomic, strong) NSDate *date;
@property (nonatomic, strong)id qpaqueObject;

@end

</code></pre>

<p>本例中，这些属性具体是什么其实无关紧要。笔者用了这么多种数据类型，只是想演示此 功能很有用。在类的内部，每个属性的值还是会存放在字典里，所以我们先在类中编写如下代码，并将属性声明为@dynamiC，这样的话，编译器就不会为其自动生成实例变量及存取方法了：</p>

<pre><code class="language-objc">
#import &quot;EOCAutoDictionary.h&quot;
#import &lt;objc/runtime.h&gt;

@interface EOCAutoDictionary ()

@property (nonatomic, strong) NSMutableDictionary *backingstore;

@end

@implementation EOCAutoDictionary

@dynamic string, number, date, opaqueObject;

-(id)init {
    if ( (self = [super init]}} {
          _backingStore = [NSMutableDictionary new];
}
    return self;
}

</code></pre>

<p>本例的关键在于<code>resolvelnstanceMethod:</code>方法的实现代码：</p>

<pre><code class="language-objc">
+ (BOOL)resolvelnstanceMethod:(SEL)selector {
    NSString *selectorstring = NSStringFromSelector(selector); 
    if ([selectorstring hasPrefix: @&quot;set&quot;]){
        class_addMethod(self,
                        selector,
                        (IMP)autoDictionarySetter
                         &quot;v@:@&quot;);
    } else {
        class_addMethod(self,
                        selector,
                        (IMP)autoDictionaryGetter,
                        &quot;@@:&quot;;)    
    }
    return YES;
}
@end

</code></pre>

<p>当开发者首次在<code>EOCAutoDictionary</code>实例上访问某个属性时，运行期系统还找不到 对应的选择子，因为所需的选择子既没有直接实现，也没有合成出来。现在假设要写入 <code>opaqueObject</code>属性，那么系统就会以<code>“setOpaqueObject:”</code>为选择子来调用上面这个方法。 同理，在读取该属性时，系统也会调用上述方法，只不过传入的选择子是<code>opaqueObject</code>。</p>

<p><code>resolvelnslanceMethod</code>方法会判断选择子的前缀是否为set，以此分辨其是set选择子还是 get选择子。在这两种情况下，都要向类中新增一个处理该选择子所用的方法，这两个方 法分别以<code>autoDictionarySetter</code>及<code>autoDictionaryGetter</code>函数指针的形式出现。此时就用到<code>class_addMethod</code>方法，它可以向类中动态地添加方法，用以处理给定的选择子。第三个参 数为函数指针，指向待添加的方法。而最后一个参数则表示待添加方法的“类型编码”（type encoding)。在本例中，编码开头的字符表示方法的返回值类型，后续字符则表示其所接受的各个参数.</p>

<p><code>getter</code>函数可以用下列代码实现:</p>

<pre><code class="language-objc">
id autoDictionaryGetter(id self, SEL _cmd) {
    //Get the backing store from the object
    EOCAutoDictionary *typedSelf = (EOCAutoDictionary^)self；
    NSMutableDictionary *backingStore = typedSelf.backingStore;
    //The key is simply the selector name 
    NSString *key = NSStringFromSelector(_cmd);
    // Return the value
    return [backingStore objectForKey:key];
}

</code></pre>

<p>而setter函数则可以这么写：</p>

<pre><code class="language-objc">
void autoDictionarySetter(id self, SEL _cmd, id value) {
    //Get the backing store from the object
    EOCAutoDictionary *typedSelf = (EOCAutoDictionary*)self；
    NSMutableDictionary *backingStore = typedSelf.backingStore;

    /** The selector will be for example, &quot;setOpaqueObject:&quot;
    *   We need to remove the &quot;set&quot;，and lowercase the first
    *   letter of the remainder.
    */
    
    NSString *selectorstring = NSStringFromSelector(_cmd);
    NSMutablestring *key = [selectorstring mutableCopy】；
    // Remove the &quot; : &quot; at the end 
    [key deleteCharactersInRange:NSMakeRange(key.length - 1, 1)];
    // Remove the fsetf prefix
    [key deleteCharactersInRange:NSMakeRange(0, 3)];
    // Lowercase the first character
    NSString *lowercaseFirstChar = [[key substringToIndex:1] lowercasestring];
    [key replaceCharactersInRange:NSMakeRange(0 ,1) withString:lowercaseFirstChar];
    if (value) {
    [backingStore setObject:value forKey:key];
    } else {
    [backingStore removeObjectForKey:key];
    }
}

</code></pre>

<p>EOCAutoDictionary的用法很简单：</p>

<pre><code class="language-objc">
    EOCAutoDictionary *dict = [EOCAutoDictionarynew];
    diet.date = [NSDatedateWithTimeIntervalSincel970:475372800];
    NSLog (@&quot;diet .date = %@&quot; , dict.date);
    // Output: diet.date = 1985-01-24 00:00:00 +0000

</code></pre>

<p>其他属性的访问方式与<code>date</code>类似，要想添加新属性，只需来定义，并将其声明为<code>@dynamic</code>即可。</p>

<h2 id="toc_5">要点</h2>

<ul>
<li>若对象无法响应某个选择子，则进人消息转发流程。</li>
<li>通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。 </li>
<li>对象可以把其无法解读的某些选择子转交给其他对象来处理。</li>
<li>经过上述两步之后，如果还是没办法处理选择子，那就启动完整的消息转发机制。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/22</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%B9%E8%B1%A1,%E6%B6%88%E6%81%AF,%E8%BF%90%E8%A1%8C%E6%9C%9F.html'>第二章 对象,消息,运行期</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15033059328138.html">
                
                  <h1>第十一条:理解Objc_msgSend的作用</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>在对象中调用方法,在oc中称作&quot;传递消息&quot;.消息有“名称&quot;（name)或“选择子&quot;（selector)，可以接受参数，而且可能还有返回值。</p>

<p>因为OC是C语言的超集,所以我们用C语言来举例.C语言使用“静态绑定”（static binding),也就是说，在编译期就能决定运行时所应调用的函数。</p>

<pre><code class="language-c">#import &lt;stdio.h&gt;

void printHello() {
    printf (&quot;Hello, world! \n&quot;);
    }
void printGoodbye() {
    printf (&quot;Goodbye, world! \n&quot;);

void doTheThing(int type) {
    if (type == 0)  {
        printHello();
    }else{
        printGoodbye();
    }
    return 0；
}

</code></pre>

<p>编译器在编译代码的时候就已经知道程序中有<code>printHello</code>与<code>printGoodbye</code>这两个函数了，于是会直接生成调用这些函数的指令。而函数地址实际上是硬编码在指令之中的。</p>

<p>但是将程序改写为下面这样后:</p>

<pre><code class="language-c">#import &lt;stdio.h&gt;

void printHello() {
    printf (&quot;Hello, world! \n&quot;);
    }
void printGoodbye() {
    printf (&quot;Goodbye, world! \n&quot;);

void doTheThing(int type) {
    void(*fnc)()
    if (type == 0)  {
        fnc = printHello;
    }else{
        fnc = printGoodbye;
    }
    fnc();
    return 0；
}

</code></pre>

<p>这个时候就要使用“动态绑定”（dynamic binding) 了，因为所要调用的函数直到运行期才能确定。编译器在这种情况下生成的指令与刚才那个例子不同，<mark>在第一个例子中，<code>if</code>与<code>else</code>语句里都有函数调用指令。而在第二个例子中，只有一个函数调用指令，不过待调用的函数地址无法硬编码在指令之中，而是要在运行期读取出来</mark>。</p>

<p>在oc中如果向某对象传递消息(方法调用),就会使用动态绑定机制来决定需要调用的方法。在底层，所有方法都是普通的C语言函数，然而对象收到消息之后，究竟该调用哪个方法则完全于运行期决定，甚至可以在程序运行时改变，这些特性使得Objective-C成为一门真正的动态语言。</p>

<p>给对象发送消息可以这样来写：</p>

<pre><code class="language-objc">
id returnValue = [someObject messageName:parameter];

</code></pre>

<p>在本例中，<code>someObject</code>叫做“接收者”（receiver),<code>messageName</code> 叫做<code>“选择子”</code>（selector)。选择子与参数合起来称为“消息”（message)。编译器看到此消息后，将其转换为一条标准的C语言函数调用，所调用的函数乃是消息传递机制中的核心函数,叫做<code>objc_msgSend</code>,其<br/>
“原型&quot;（prototype)如下：</p>

<pre><code class="language-c">
void objc_msgSend(id self, SEL cmd, •••)

</code></pre>

<p>这是个‘参数个数可变的函数’(variadic function)9，能接受两个或两个以上的参数。第一个参数代表接收者，第二个参数代表选择子（SEL是选择子的类型)，后续参数就是消息中的那些参数，其顺序不变。<strong>选择子指的就是方法的名字</strong>。“选择子”与“方法”这两个词经常交替使用。编译器会把刚才那个例子中的消息转换为如下函数：</p>

<pre><code class="language-c">
id returnValue = objc_msgSend(someObject,
                            ^selector(messageName:),
                            parameter);

</code></pre>

<p><code>objc_msgSend</code>函数会依据接收者与选择子的类型来调用适当的方法。为了完成此操作，该方法需要在接收者所属的类中搜寻其“方法列表”（list of methods),如果能找到与选择子名称相符的方法，就跳至其实现代码。若是找不到，那就沿着继承体系继续向上査找，等找到合适的方法之后再跳转。如果最终还是找不到相符的方法，那就执行“消息转发” (message forwarding)操作。消息转发将在第12条中详解。</p>

<p>其它特殊情况需要由一些函数来处理:</p>

<ul>
<li><strong>objc_msgSendstret。</strong>如果待发送的消息要返回结构体，那么可交由此函数处理。只有当CPU的寄存器能够容纳得下消息返回类型时，这个函数才能处理此消息。若是返回值无法容纳于CPU寄存器中（比如说返回的结构体太大了)，那么就由另一个函数执行派发。此时，那个函数会通过分配在栈上的某个变量来处理消息所返回的结构体。</li>
<li>ObjC_mSgSerid_fpret。如果消息返回的是浮点数，那么可交由此函数处理,在某些架构的CPU中调用函数时，需要对浮点数寄存器（floating-point register)做特殊处理,也就是说，通常所用的ObjC_msgSend在这种情况下并不合适。这个函数是为了处理x86等架构CPU中某些令人稍觉惊讶的奇怪状况。</li>
<li>objc_msgSendSuper3 如果要给超类发消息，例如[supermessage:parameter],那么就交由此函数处理。也有另外两个与objc_msgSendstret和objc_MsgSend_fpret等效的函数，用于处理发给super的相应消息。</li>
</ul>

<p>刚才曾提到,Objc_msgSend等函数一旦找到应该调用的方法之后，就会‘跳转过去’。之所以能这样做，是因为Objective-C对象的每个方法都可以视为简单的C函数，其原型如下：</p>

<pre><code class="language-c">
&lt;return type&gt; Class_selector(id self, SEL _cmd, •••)

</code></pre>

<p>真正的函数名和上面写的可能不太一样，笔者用“类”（class)和“选择子”（selector)来命名是想解释其工作原理。每个类里都有一张表格，其中的指针都会指向这种函数，而选择子的名称则是査表时所用的“键”。ObjC_msgSend等函数正是通过这张表格来寻找应该执行的方法并跳至其实现的。请注意，原型的样子和ObjC_msgSend函数很像。这不是巧合，而是为了利用“尾调用优化”技术，令“跳至方法实现”这一操作变得更简单些。</p>

<h2 id="toc_0">要点</h2>

<ul>
<li>消息由接收者、选择子及参数构成。给某对象&quot;发送消息&quot;(invoke a message)也就相当于在该对象上“调用方法”（call a method)。</li>
<li>发给某对象的全部消息都要由“动态消息派发系统”（dynamic message dispatch system)来处理，该系统会査出对应的方法，并执行其代码。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%B9%E8%B1%A1,%E6%B6%88%E6%81%AF,%E8%BF%90%E8%A1%8C%E6%9C%9F.html'>第二章 对象,消息,运行期</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="15032784762045.html">
                
                  <h1>小论文想法</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>1,结合雾天道路行进过程中,图像在远端,中端和近处的雾气浓度不同,进行评估,来自动化调节去雾强度.可以结合边缘检测算法(OTSU),来检测出天空的区域(当前方有车时,检测),然后将图像分割为远中近三个部分.</p>

<p>2.</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/8/21</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html'>图像去雾技术</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14993030681229.html">
                
                  <h1>Caffe最优化求解过程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">求解器是什么</a>
</li>
<li>
<a href="#toc_1">求解器是如何实现的</a>
<ul>
<li>
<a href="#toc_2">算法描述</a>
</li>
</ul>
</li>
</ul>


<p>将前面几天讲述的不同Layer组合起来就可以构建起完整的<code>CNN/DNN</code>。今天将从Caffe的Solver类入手，对Caffe训练时的流程做深入分析，也就是看Caffe实际是如何“动”起来的。</p>

<h2 id="toc_0">求解器是什么</h2>

<p>从前两天内容我们学习到，Net己经完成部分学习任务（数据前向传播、误差反向传播),<mark>而CNN剩下有监督的优化过程、利用每层的梯度生成权值增量则由求解器(Solver)负责.</mark></p>

<p>求解器负责对模型优化,它的KPI(Key Performance Indicator,关键绩效指你，某公司常用的一种员工绩效评定方式）就是让损失函数达到全局最小。</p>

<p>求解器的特性如下:</p>

<ul>
<li>负责记录优化过程，创建用于学习的训练网络和用于评估学习效果的测试网络。</li>
<li>调用Forward\(\rightarrow\)调用Backward\(\rightarrow\)更新权值，反复迭代优化模型。</li>
<li>周期性的评估测试网络</li>
<li>在优化过程中为模型,求解器状态打快照.</li>
</ul>

<p>为了让权值从初始化状态向着更好的模型前进，求解器在每次迭代中做了如下事情：</p>

<ul>
<li>调用Net的前向传播函数来计算输出和损失函数。</li>
<li>调用Net的反向传播函数来计算梯度。</li>
<li>根据求解器方法,将梯度转换为权值增量</li>
<li>根据学习速率、历史权值、所用方法更新求解器状态。</li>
</ul>

<h2 id="toc_1">求解器是如何实现的</h2>

<p>在卷积神经网络中,有两种类型的层需要学习:卷积层和全连接层（统称权值层，因为它们都有<code>weight</code>参数）。<mark>在设计求解器时，学习速率参数的设置也是针对这两个层的</mark>。</p>

<p>在caffe中我们要适当把握度,控制收敛的参数---学习速率.</p>

<p>我们来具体看一下Caffe是如何对权值学习做到“不偏不倚”的。</p>

<h3 id="toc_2">算法描述</h3>

<p>Caffe中的求解器有以下几种:</p>

<ul>
<li>随机梯度下降法（Stochastic Gradient Descent, SGD),最常用的一种</li>
<li>AdaDelta</li>
<li>自适应梯度法（Adaptive Gradient, ADAGRAD)</li>
<li>Adam</li>
<li>Nesterov加速梯度法（Nesterov’s Accelerated Gradient, NAG)</li>
<li>RMSprop</li>
</ul>

<p><mark>求解器方法重点是最小化损失函数的全局优化问题</mark>,对于数据集D,优化目标是在全数据集D上损失函数平均值：<br/>
\[<br/>
L(W)=\frac{1}{|{D}|}\sum^{|D|}_{i}{f_w(X^{(i)}) + \lambda{r}(W)}<br/>
\]</p>

<p>其中，\(f_w(X^{(i)})\)是在数据实例\(X^{(i)\)上的损失函数，\(r(W)\)为规整项，\(\lambda\)为规整项的权重。数据集\(D\)可能非常大，工程上一般在每次迭代中使用这个目标函数的随机逼近，即小批量数据\(N&lt;&lt;|D|\)个数据实例:</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/6</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Caffe%E6%9C%80%E4%BC%98%E5%8C%96%E6%B1%82%E8%A7%A3%E8%BF%87%E7%A8%8B.html'>Caffe最优化求解过程</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14992368546707.html">
                
                  <h1>第10条:在既有类中使用关联对象存放自定义数据</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>有时需要在对象中存放相关信息。这时我们通常会从对象所属的类中继承一个子类，然后改用这个子类对象。然而并非所有情况下都能这么做，<mark>有时候类的实例可能是由某种机制所创建的，而开发者无法令这种机制创建出自己所写的子类实例</mark>。</p>

<p><code>Objective-C</code>中有一项强大的特性可以解决此问题，这就是<code>“关联对象&quot;（Associated Object)</code>。</p>

<p>可以给某对象关联许多其他对象，这些对象通过“键”来区分.存储对象值的时候，可以指明“存储策略”（storage policy),用以维护相应的“内存管理语义”。存储策略由名为<code>Objc_ASSOCiationPolicy</code>的枚举所定义，下表列出了该枚举的取值，同时还列出了与之等效属性：假如关联对象成为了属性，那么它就会具备对应的语义（第6条详解了“属性”这个概念).</p>

<table>
<thead>
<tr>
<th>关联类型</th>
<th>等效的@property属性</th>
</tr>
</thead>

<tbody>
<tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>assign</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>nonatomic, retain</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>nonatomic, copy</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>retain</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>copy</td>
</tr>
</tbody>
</table>

<p>下列方法可以管理关联对象：</p>

<ul>
<li><p>void objc_setAssociatedObject ( id object, void*key, id value, objc AssociationPolicypolicy)<br/>
此方法以给定的键和策略为某对象设置关联对象值。</p></li>
<li><p>id objc_getAssociatedObject(id object, void*key)<br/>
此方法根据给定的键从某对象中获取相应的关联对象值。</p></li>
<li><p>void objc removeAssociatedObjects(id object)<br/>
此方法移除指定对象的全部关联对象。</p></li>
</ul>

<p>我们可以把某对象想象成<code>NSDictionary</code>,把关联到该对象的值理解为字典中的条目,于是，存取关联对象的值就相当于在NSDictionary对象上调用<code>[object setObject:value forKey:key]</code>与<code>[object objectForKey:key]</code>方法。然而两者之间有个重要差别：设置关联对象时用的键（key)是个&quot;不透明的指针&quot;(opaque pointer)”。如果在两个键上调用<code>“isEqual:”</code>方法的返回值是<code>YES</code>,那么<code>NSDictionary</code>就认为二者相等；然而在设置关联对象值时，若想令两个键匹配到同一个值，则二者必须是完全相同的指针才行。鉴于此，<font color=red>在设置关联对象值时，通常使用<mark>静态全局变量做键</mark></font>。</p>

<h2 id="toc_0">关联对象用法举例</h2>

<p>开发iOS时经常用到<code>UIAlertView</code>类，该类提供了一种标准视图，可向用户展示警告信息.当用户按下按钮关闭该视图时,需要用委托协议（delegate protocol)来处理此动作，但是，要想设置好这个委托机制，就得把创建警告视图和处理按钮动作的代码分开。由于代码分作两块，所以读起来有点乱。比方说，我们在使用<code>UIAlertView</code>时，一般都会这么写：</p>

<pre><code class="language-objc">-(void)askUserAQuestion{
    UIAlertView *alert = [[UIAlertView alloc]
                            initWithTitle:@&quot;Question&quot;
                                  message:@&quot;What do you want to do?&quot;
                                 delegate:self
                        cancelButtonTitle:@&quot;Cancel&quot;
                        otherButtonTitles:@&quot;Continue&quot;, nil]；
        [alert show];
}

// UIAlertViewDelegate protocol method
-(void)alertView:(UIAlertView *)alertView
        clickedButtonAtlndex:(NSInteger)buttonIndex
{
    if (buttonlndex == 0) {
        [self doCancel];
    } else {
        [self doContinue];
    }
}

</code></pre>

<p><font color=red>如果想在同一个类里处理多个警告信息视图，那么代码就会变得更为复杂，我们必须在 <code>delegate</code>方法中检査传人的<code>alertView</code>参数，并据此选用相应的逻辑。要是能在创建警告视图的时候直接把处理每个按钮的逻辑都写好，那就简单多了。这可以通过关联对象来做。创建完警告视图之后，设定一个与之关联的&quot;块&quot;(block)，等到执行<code>delegate</code>方法时再将其读出来。</font>此方案的实现代码如下：</p>

<pre><code class="language-objc">
#import &lt;objc/runtime.h&gt;

static void *EOCMyAlertViewKey = &quot;EOCMyAlertViewKey&quot;;

-(void)askUserAQuestion {
    UIAlertView *alert = [[UIAlertViewalloc]
                            initWithTitle:@&quot;Question&quot;
                                  message: @&quot;What do you want to do?&quot;
                                 delegate:self
                        cancelButtonTitle: @&quot;Cancel&quot;,
                        otherButtonTitles: @&quot;Continue&quot;, nil];
        void (^block)(NSInteger) = ^(NSInteger buttonIndex){
            if (buttonlndex == 0) {
                [self doCancel];
            }else {
                [self doContinue];
            }
        };
        objc_setAssociatedObject(alert,
                                 EOCMyAlertViewKey,
                                 block,
                                 OBJC_ASSOCIATION_COPY);
        [alert show];
}

// UIAlertViewDelegate protocol method
-(void)alertView:(UIAlertView*)alertView
       clickedButtonAtIndex:(NSInteger)buttonIndex
{
    void (^block)(NSInteger)=
        objc_getAssociatedObject(alertView, EOCMyAlertViewKey);
    block(buttonIndex);
}


</code></pre>

<p>以这种方式改写之后，创建警告视图与处理操作结果的代码都放在一起了，这样比原来更易读慷，因为我们无须在两部分代码之间来回游走，即可明白警告视图的用处。但是,采用该方案时需注意：块可能要捕获(capture)某些变量，这也许会造成“保留环”（retain cycle)。第40条详述了此问题。</p>

<p><mark>正如大家所见，这种做法很有用，但是只应该在其他办法行不通时才去考虑用它。若是<br/>
滥用，则很快就会令代码失控，使其难于调试。</mark>“保留环”产生的原因很难査明，因为关联对象之间的关系并没有正式的定义（formal definition)，其内存管理语义是在关联的时候才定义的，而不是在接口中预先定好的。使用这种写法时要小心，不能仅仅因为某处可以用该写法就一定要用它。想创建这种<code>UIAlertView</code>还有个办法，那就是从中继承子类，把块保存为子类中的属性。笔者认为：若是需要多次用到alert视图，那么这种做法比使用关联对象要好。</p>

<h2 id="toc_1">要点</h2>

<ul>
<li>可以通过&quot;关联对象&quot;机制来把两个对象连起来</li>
<li>定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”。</li>
<li>只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于査找的bug。</li>
</ul>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%AF%B9%E8%B1%A1,%E6%B6%88%E6%81%AF,%E8%BF%90%E8%A1%8C%E6%9C%9F.html'>第二章 对象,消息,运行期</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14992160809956.html">
                
                  <h1>SoftmaxWithLossLayer的实现</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>我们找到<code>SoftmaxWithLossLayer.hpp</code>文件查看声明,如下:</p>

<pre><code class="language-c++">
//将实数预测向量通过Softmax计算获得每个类别的概率分布
//这个类比单独SoftmaxLayer + MultinomialLogisticLossLayer在梯度数值计算上更加稳定
//Test阶段，这个层可以直接用SoftmaxLayer代替
/**
 *输入Blob 1为预测结果，形状为N x K x 1 x 1，K为总类别数目，N为批量数。取值范围为（-Inf, Inf)，
 *表示每个类别获得的分类score,值越大说明输入图像与该类别越接近
 *输入Blob 2为真实标签，形状为N x 1 x 1 x 1
 *输出Blob为计算得到的交叉熵分类损失E，形状为1 x 1 x 1 x 1
**/
template &lt;typename Dtype&gt;
class SoftmaxWithLossLayer : public LossLayer&lt;Dtype&gt; {
 public:
   /**
    * @param param provides LossParameter loss_param, with options:
    *  - ignore_label (optional)
    *    Specify a label value that should be ignored when computing the loss.
    *  - normalize (optional, default true)
    *    If true, the loss is normalized by the number of (nonignored) labels
    *    present; otherwise the loss is simply summed over spatial locations.
    */
    explicit SoftmaxWithLossLayer(const LayerParameter&amp; param)
      : LossLayer&lt;Dtype&gt;(param) {}
  virtual void LayerSetUp(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
      const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);
  virtual void Reshape(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
      const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);
  virtual inline const char* type() const { return &quot;SoftmaxWithLoss&quot;; }
  virtual inline int ExactNumTopBlobs() const { return -1; }
  virtual inline int MinTopBlobs() const { return 1; }
  virtual inline int MaxTopBlobs() const { return 2; }

 protected:
  virtual void Forward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
      const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);
  virtual void Forward_gpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom,
      const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top);
      
/**
   * @brief Computes the softmax loss error gradient w.r.t. the predictions.
   *
   * Gradients cannot be computed with respect to the label inputs (bottom[1]),
   * so this method ignores bottom[1] and requires !propagate_down[1], crashing
   * if propagate_down[1] is set.
   *
   * @param top output Blob vector (length 1), providing the error gradient with
   *      respect to the outputs
   *   -# @f$ (1 \times 1 \times 1 \times 1) @f$
   *      This Blob&#39;s diff will simply contain the loss_weight* @f$ \lambda @f$,
   *      as @f$ \lambda @f$ is the coefficient of this layer&#39;s output
   *      @f$\ell_i@f$ in the overall Net loss
   *      @f$ E = \lambda_i \ell_i + \mbox{other loss terms}@f$; hence
   *      @f$ \frac{\partial E}{\partial \ell_i} = \lambda_i @f$.
   *      (*Assuming that this top Blob is not used as a bottom (input) by any
   *      other layer of the Net.)
   * @param propagate_down see Layer::Backward.
   *      propagate_down[1] must be false as we can&#39;t compute gradients with
   *      respect to the labels.
   * @param bottom input Blob vector (length 2)
   *   -# @f$ (N \times C \times H \times W) @f$
   *      the predictions @f$ x @f$; Backward computes diff
   *      @f$ \frac{\partial E}{\partial x} @f$
   *   -# @f$ (N \times 1 \times 1 \times 1) @f$
   *      the labels -- ignored as we can&#39;t compute their error gradients
   */
  virtual void Backward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,
      const vector&lt;bool&gt;&amp; propagate_down, const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom);
  virtual void Backward_gpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,
      const vector&lt;bool&gt;&amp; propagate_down, const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom);
      
/// Read the normalization mode parameter and compute the normalizer based
  /// on the blob size.  If normalization_mode is VALID, the count of valid
  /// outputs will be read from valid_count, unless it is -1 in which case
  /// all outputs are assumed to be valid.
  virtual Dtype get_normalizer(
      LossParameter_NormalizationMode normalization_mode, int valid_count);

  /// The internal SoftmaxLayer used to map predictions to a distribution.(内置一个SoftmaxLayer对象)
  shared_ptr&lt;Layer&lt;Dtype&gt; &gt; softmax_layer_;
  /// prob stores the output probability predictions from the SoftmaxLayer.
  Blob&lt;Dtype&gt; prob_;
  /// bottom vector holder used in call to the underlying SoftmaxLayer::Forward
  vector&lt;Blob&lt;Dtype&gt;*&gt; softmax_bottom_vec_;
  /// top vector holder used in call to the underlying SoftmaxLayer::Forward
  vector&lt;Blob&lt;Dtype&gt;*&gt; softmax_top_vec_;
  /// Whether to ignore instances with a certain label.
  bool has_ignore_label_;
  /// The label indicating that an instance should be ignored.
  int ignore_label_;
  /// How to normalize the output loss.
  LossParameter_NormalizationMode normalization_;

  int softmax_axis_, outer_num_, inner_num_;
};

</code></pre>

<p>之后我们来看实现的<code>.cpp</code>文件:</p>

<p>第一个是SetUp函数.<br/>
```c++</p>

<p>template <typename Dtype><br/>
void SoftmaxWithLossLayer<Dtype>::LayerSetUp(<br/>
    const vector<Blob<Dtype><em>&gt;&amp; bottom, const vector<Blob<Dtype></em>&gt;&amp; top) {<br/>
  LossLayer<Dtype>::LayerSetUp(bottom, top);<br/>
  //创建时动态修改本层的LayerParameter参数，适应SoftmaxLayer<br/>
  LayerParameter softmax_param(this-&gt;layer_param_);<br/>
  softmax_param.set_type(&quot;Softmax&quot;);<br/>
  softmax_layer_ = LayerRegistry<Dtype>::CreateLayer(softmax_param);<br/>
  softmax_bottom_vec_.clear();<br/>
  softmax_bottom_vec_.push_back(bottom[0]);<br/>
  softmax_top_vec_.clear();<br/>
  softmax_top_vec_.push_back(&amp;prob_);<br/>
  softmax_layer_-&gt;SetUp(softmax_bottom_vec_, softmax_top_vec_);</p>

<p>has_ignore_label_ =<br/>
    this-&gt;layer_param_.loss_param().has_ignore_label();<br/>
  if (has_ignore_label_) {<br/>
    ignore_label_ = this-&gt;layer_param_.loss_param().ignore_label();<br/>
  }<br/>
  if (!this-&gt;layer_param_.loss_param().has_normalization() &amp;&amp;<br/>
      this-&gt;layer_param_.loss_param().has_normalize()) {<br/>
    normalization_ = this-&gt;layer_param_.loss_param().normalize() ?<br/>
                     LossParameter_NormalizationMode_VALID :<br/>
                     LossParameter_NormalizationMode_BATCH_SIZE;<br/>
  } else {<br/>
    normalization_ = this-&gt;layer_param_.loss_param().normalization();<br/>
  }<br/>
}</p>

<pre><code>可见，在SetUp阶段，创建了内部SoftmaxLayer对象并配置了其输入/输出Blob，然后调用该对象的SetUp函数。


下面看看`SoftmaxWithLossLayer`的前向传播函数：

```c++

template &lt;typename Dtype&gt;
void SoftmaxWithLossLayer&lt;Dtype&gt;::Forward_cpu(
    const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom, const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top) {
  // The forward pass computes the softmax prob values.(内部SoftmaxLayer的前向传播计算)
  softmax_layer_-&gt;Forward(softmax_bottom_vec_, softmax_top_vec_);
  //获得概率密度
  const Dtype* prob_data = prob_.cpu_data();
  //获得标签值
  const Dtype* label = bottom[1]-&gt;cpu_data();
  int dim = prob_.count() / outer_num_;
  int count = 0;
  Dtype loss = 0;
  for (int i = 0; i &lt; outer_num_; ++i) {
    for (int j = 0; j &lt; inner_num_; j++) {
      const int label_value = static_cast&lt;int&gt;(label[i * inner_num_ + j]);
      if (has_ignore_label_ &amp;&amp; label_value == ignore_label_) {
        continue;
      }
      DCHECK_GE(label_value, 0);
      DCHECK_LT(label_value, prob_.shape(softmax_axis_));
      //计算损失函数-log(prob[label])
      loss -= log(std::max(prob_data[i * dim + label_value * inner_num_ + j],
                           Dtype(FLT_MIN)));
      ++count;
    }
  }
  //设置输出Blob值
  top[0]-&gt;mutable_cpu_data()[0] = loss / get_normalizer(normalization_, count);
  if (top.size() == 2) {
    top[1]-&gt;ShareData(prob_);
  }
}


</code></pre>

<p>可见通过内部<code>SoftmaxLayer</code>对象非常简洁。我们再看一下 Backward计算:</p>

<pre><code class="language-c++">
template &lt;typename Dtype&gt;
void SoftmaxWithLossLayer&lt;Dtype&gt;::Backward_cpu(const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; top,
    const vector&lt;bool&gt;&amp; propagate_down, const vector&lt;Blob&lt;Dtype&gt;*&gt;&amp; bottom) {
  if (propagate_down[1]) {
   //label输入Blob不做反向传播
    LOG(FATAL) &lt;&lt; this-&gt;type()
               &lt;&lt; &quot; Layer cannot backpropagate to label inputs.&quot;;
  }
  if (propagate_down[0]) {
    Dtype* bottom_diff = bottom[0]-&gt;mutable_cpu_diff();
    const Dtype* prob_data = prob_.cpu_data();
    //将概率密度拷贝输入Blob的diff域
    caffe_copy(prob_.count(), prob_data, bottom_diff);
    const Dtype* label = bottom[1]-&gt;cpu_data();
    int dim = prob_.count() / outer_num_;
    int count = 0;
    for (int i = 0; i &lt; outer_num_; ++i) {
      for (int j = 0; j &lt; inner_num_; ++j) {
        const int label_value = static_cast&lt;int&gt;(label[i * inner_num_ + j]);
        if (has_ignore_label_ &amp;&amp; label_value == ignore_label_) {
          for (int c = 0; c &lt; bottom[0]-&gt;shape(softmax_axis_); ++c) {
            bottom_diff[i * dim + c * inner_num_ + j] = 0;
          }
        } else {
        //在输入Blob的diff域，计算当前槪率密度与理想概率密度(label 对应类别概率为1,其他类别 概肀为0)之差，实现误差反向传播
          bottom_diff[i * dim + label_value * inner_num_ + j] -= 1;
          ++count;
        }
      }
    }
    // Scale gradient(适当的缩放)
    Dtype loss_weight = top[0]-&gt;cpu_diff()[0] /
                        get_normalizer(normalization_, count);
    caffe_scal(prob_.count(), loss_weight, bottom_diff);
  }
}
</code></pre>

<p>通过对Caffe损失层的研究，我们了解到，前向传播阶段数据逐层传播，到损失层计算预测概率密度和损失函数；而反向传播阶段则从损失层开始，由预测概率密度与理想概率密度(这就是有监督学习的佐证)<strong>差值</strong>得到误差（diff),然后将由下一节内容逐层反向传播。我们已经知道一个Blob是由data和diff两部分构成的，如果说数据读取层是data之源，那么损失层就是diff之源。</p>

<h2 id="toc_0">反向传播的实现</h2>

<p>Caffe Net数据结构中的&#39;Backward函数具体的声明和实现文件为<code>net.hpp</code>和<code>net.cpp</code>:</p>

<pre><code class="language-c++">//从第start层反向传播到达第end层
template &lt;typename Dtype&gt;
void Net&lt;Dtype&gt;::BackwardFromTo(int start, int end) {
  CHECK_GE(end, 0);
  CHECK_LT(start, layers_.size());
  for (int i = start; i &gt;= end; --i) {
    for (int c = 0; c &lt; before_backward_.size(); ++c) {
      before_backward_[c]-&gt;run(i);
    }
    if (layer_need_backward_[i]) {
    //遍历每个居，调用相应的Backward函数
      layers_[i]-&gt;Backward(
          top_vecs_[i], bottom_need_backward_[i], bottom_vecs_[i]);
      if (debug_info_) { BackwardDebugInfo(i); }
    }
    for (int c = 0; c &lt; after_backward_.size(); ++c) {
      after_backward_[c]-&gt;run(i);
    }
  }
}

//从第start层幵始到第一层的反向传播过程
template &lt;typename Dtype&gt;
void Net&lt;Dtype&gt;::BackwardFrom(int start) {
  BackwardFromTo(start, 0);
}

//从最后一层开始到第end层的反向传播过程
template &lt;typename Dtype&gt;
void Net&lt;Dtype&gt;::BackwardTo(int end) {
  BackwardFromTo(layers_.size() - 1, end);
}

//整个网络的反向传播过程
template &lt;typename Dtype&gt;
void Net&lt;Dtype&gt;::Backward() {
  BackwardFromTo(layers_.size() - 1, 0);
  if (debug_info_) {
  //如果打幵了调试信息开关(在prototxt中设定），则计算所有权值的data/diff的L1、L2范数，监控其变化情况，避免发散
    Dtype asum_data = 0, asum_diff = 0, sumsq_data = 0, sumsq_diff = 0;
    for (int i = 0; i &lt; learnable_params_.size(); ++i) {
      asum_data += learnable_params_[i]-&gt;asum_data();
      asum_diff += learnable_params_[i]-&gt;asum_diff();
      sumsq_data += learnable_params_[i]-&gt;sumsq_data();
      sumsq_diff += learnable_params_[i]-&gt;sumsq_diff();
    }
    const Dtype l2norm_data = std::sqrt(sumsq_data);
    const Dtype l2norm_diff = std::sqrt(sumsq_diff);
    LOG(ERROR) &lt;&lt; &quot;    [Backward] All net params (data, diff): &quot;
               &lt;&lt; &quot;L1 norm = (&quot; &lt;&lt; asum_data &lt;&lt; &quot;, &quot; &lt;&lt; asum_diff &lt;&lt; &quot;); &quot;
               &lt;&lt; &quot;L2 norm = (&quot; &lt;&lt; l2norm_data &lt;&lt; &quot;, &quot; &lt;&lt; l2norm_diff &lt;&lt; &quot;)&quot;;
  }
}

//更新权值函数，在反向传播结束后调用
template &lt;typename Dtype&gt;
void Net&lt;Dtype&gt;::Update() {
  for (int i = 0; i &lt; learnable_params_.size(); ++i) {
  //调用内部Blob的Update()函数，具体计算为data = data - diff
    learnable_params_[i]-&gt;Update();
  }
}

//权值diff清零
template &lt;typename Dtype&gt;
void Net&lt;Dtype&gt;::ClearParamDiffs() {
  for (int i = 0; i &lt; learnable_params_.size(); ++i) {
    Blob&lt;Dtype&gt;* blob = learnable_params_[i];
    switch (Caffe::mode()) {
    case Caffe::CPU:
      caffe_set(blob-&gt;count(), static_cast&lt;Dtype&gt;(0),
                blob-&gt;mutable_cpu_diff());
      break;
    case Caffe::GPU:
#ifndef CPU_ONLY
      caffe_gpu_set(blob-&gt;count(), static_cast&lt;Dtype&gt;(0),
                    blob-&gt;mutable_gpu_diff());
#else
      NO_GPU;
#endif
      break;
    }
  }
}

</code></pre>

<p>到此,caffe基本的backward反向传播过程就清楚了,这样对于设计更复杂的有监督学习算法具有指导意义。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/7/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Caffe%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E8%AE%A1%E7%AE%97.html'>Caffe反向传播计算</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all_6.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_8.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <div class="site-a-logo"><img src="/asset/img/logn.png" /></div>
            
                <h1>LZH007</h1>
                <div class="site-des">LZH的技术杂事小博客~</div>
                <div class="social">









<a target="_blank" class="github" target="_blank" href="https://github.com/lockxmonk" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:lzhabc007@163.com" title="Email">Email</a>
  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="MAC%20OS.html"><strong>MAC OS</strong></a>
        
            <a href="Effective%20OC2.0.html"><strong>Effective OC2.0</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html"><strong>统计学习方法</strong></a>
        
            <a href="Python%E7%BB%83%E4%B9%A0.html"><strong>Python练习</strong></a>
        
            <a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html"><strong>图像去雾技术</strong></a>
        
            <a href="iOS.html"><strong>iOS</strong></a>
        
            <a href="English%20Study.html"><strong>English Study</strong></a>
        
            <a href="%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0.html"><strong>算法学习</strong></a>
        
            <a href="%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98.html"><strong>常见面试问题</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="15109904843500.html">AFNetworking的简单使用</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15109022752813.html">FMDB的使用方法</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15097619961308.html">贪心算法（构造霍夫曼树）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15096800741665.html">贪心算法（活动选择问题）</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="15090074391982.html">常见iOS面试题基础篇</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
          <script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1265629731'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1265629731%26online%3D1' type='text/javascript'%3E%3C/script%3E"));</script>    
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2017
Powered by <a target="_blank" href="https://lockxmonk.github.io/index.html">LZH</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
