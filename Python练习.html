<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  Python练习 - LZH007
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="LZH007" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:lockxmonk.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; LZH007</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="Effective%20OC2.0.html">Effective OC2.0</a></li>
        
            <li><a href="English%20Study.html">English Study</a></li>
        
            <li><a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html">机器学习</a></li>
        
            <li><a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html">统计学习方法</a></li>
        
            <li><a href="Python%E7%BB%83%E4%B9%A0.html">Python练习</a></li>
        
            <li><a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html">图像去雾技术</a></li>
        
            <li><a href="iOS.html">iOS</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14956760206333.html">
                
                  <h1>itertools</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">chain()</a>
</li>
<li>
<a href="#toc_1">groupby()</a>
</li>
<li>
<a href="#toc_2">imap()</a>
</li>
<li>
<a href="#toc_3">ifilter()</a>
</li>
</ul>
</li>
<li>
<a href="#toc_4">小结</a>


<p>Python的内建模块<code>itertools</code>提供了非常有用的用于操作迭代对象的函数。</p>

<p>首先，我们看看<code>itertools</code>提供的几个“无限”迭代器：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import itertools

natuals = itertools.count(1)
for n in natuals:
    print n
</code></pre>

<p><img src="media/14956760206333/14956780529492.jpg" alt=""/></p>

<p>因为<code>count()</code>会创建一个无限的迭代器，所以上述代码会打印出自然数序列，根本停不下来，只能按<code>Ctrl+C</code>退出。(有假死的风险)</p>

<p><code>cycle()</code>会把传入的一个序列无限重复下去：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import itertools

cs = itertools.cycle(&#39;ABC&#39;)
for n in cs:
    print n
</code></pre>

<p><img src="media/14956760206333/14956783779668.jpg" alt=""/><br/>
同样停不下来。(很容易程序假死....)</p>

<p><code>repeat()</code>负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import itertools

ns = itertools.repeat(&#39;A&#39;,10)
for n in ns:
    print n
</code></pre>

<p><img src="media/14956760206333/14956789222152.jpg" alt=""/></p>

<p><strong>无限序列只有在<code>for</code>迭代时才会无限地迭代下去，如果只是创建了一个迭代对象，它不会事先把无限个元素生成出来，事实上也不可能在内存中创建无限多个元素。</strong></p>

<p>无限序列虽然可以无限迭代下去，但是通常我们会通过<code>takewhile()</code>等函数根据条件判断来截取出一个有限的序列：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import itertools
natuals = itertools.count(1)
ns = itertools.takewhile(lambda x:x&lt;=10, natuals)
for n in ns:
    print n
</code></pre>

<p><img src="media/14956760206333/14956791893037.jpg" alt=""/></p>

<p><code>itertools</code>提供的几个迭代器操作函数更加有用：</p>

<h2 id="toc_0">chain()</h2>

<p><code>chain()</code>可以把一组迭代对象串联起来，形成一个更大的迭代器：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import itertools
for c in itertools.chain(&#39;ABC&#39;, &#39;XYZ&#39;):
    print c
</code></pre>

<p><img src="media/14956760206333/14956795463378.jpg" alt=""/></p>

<h2 id="toc_1">groupby()</h2>

<p><code>groupby()</code>把迭代器中相邻的重复元素挑出来放在一起：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import itertools
for key,group  in itertools.groupby(&#39;AAAABBBBBCCCAAA&#39;):
    print key ,list(group)
</code></pre>

<p><img src="media/14956760206333/14956799374968.jpg" alt=""/><br/>
<strong>这里注意到打印group的时候用的是list(group),这是因为gruupby返回仍然是一个迭代器!!,迭代器中的元素可以用list(迭代器)来将元素显示出来,但是要注意不要用list来显示那些无限循环的迭代器(会死机....).</strong></p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import itertools
cs = itertools.repeat(&#39;A&#39;, 10) # 注意字符串也是序列的一种
print list(cs)
</code></pre>

<p><img src="media/14956760206333/14956833066876.jpg" alt=""/></p>

<h2 id="toc_2">imap()</h2>

<p><code>imap()</code>和<code>map()</code>的区别在于，<code>imap()</code>可以作用于无穷序列，并且，如果两个序列的长度不一致，以短的那个为准。</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import itertools
for x in itertools.imap(lambda x, y: x * y, [10, 20, 30], itertools.count(1)):
         print x
</code></pre>

<p><img src="media/14956760206333/14956801958879.jpg" alt=""/></p>

<p>注意<code>imap()</code>返回一个迭代对象，而<code>map()</code>返回<code>list</code>。当你调用<code>map()</code>时，已经计算完毕,当你调用<code>imap()</code>时，并没有进行任何计算：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import itertools

r = map(lambda x: x*x, [1, 2, 3])
print r     # r已经计算出来了
n = itertools.imap(lambda x: x*x, [1, 2, 3])
print n     # n只是一个迭代对象

for x in n:
    print x
</code></pre>

<p><img src="media/14956760206333/14956804009136.jpg" alt=""/></p>

<p>必须用for循环对r进行迭代，才会在每次循环过程中计算出下一个元素.</p>

<p>这说明<code>imap()</code>实现了“惰性计算”，也就是在需要获得结果的时候才计算。类似<code>imap()</code>这样能够实现惰性计算的函数就可以处理无限序列：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import itertools

r = itertools.imap(lambda x: x*x, itertools.count(1)) 
for n in itertools.takewhile(lambda x: x&lt;100, r):
      print n
</code></pre>

<p><img src="media/14956760206333/14956809524908.jpg" alt=""/></p>

<p>如果把imap()换成map()去处理无限序列:</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import itertools

r = map(lambda x: x * x, itertools.count(1))
print r
# for n in itertools.takewhile(lambda x: x&lt;100, r):
# print n
</code></pre>

<p>会造成电脑死机,由于<code>map()</code>返回的是一个list，所以当用它去处理无限序列的时候，它会尝试计算完之后才返回，但是序列是无限的，所以它会一直计算下去，致使其占用的系统的内存越来越高。(很坑爹....)</p>

<h2 id="toc_3">ifilter()</h2>

<p>不用多说了，<code>ifilter()</code>就是<code>filter()</code>的惰性实现。</p>

<h1 id="toc_4">小结</h1>

<p><code>itertools</code>模块提供的全部是处理迭代功能的函数，它们的返回值不是<code>list</code>，而是迭代对象，只有用<code>for</code>循环迭代的时候才真正计算。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/25</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14956154840973.html">
                
                  <h1>hashlib</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">摘要算法简介</a>
</li>
</ul>
</li>
<li>
<a href="#toc_1">==MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</a>
<ul>
<li>
<a href="#toc_2">摘要算法应用</a>
<ul>
<li>
<a href="#toc_3">练习:根据用户输入的口令，计算出存储在数据库中的MD5口令：</a>
</li>
<li>
<a href="#toc_4">练习：设计一个验证用户登录的函数，根据用户输入的口令是否正确，返回True或False：</a>
</li>
<li>
<a href="#toc_5">练习：根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5：</a>
</li>
</ul>
</li>
<li>
<a href="#toc_6">小结</a>
</li>
</ul>


<h2 id="toc_0">摘要算法简介</h2>

<p>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</p>

<p>什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p>

<p>举个例子，你写了一篇文章，内容是一个字符串<code>&#39;how to use python hashlib - by Michael&#39;</code>，并附上这篇文章的摘要是<code>&#39;2d73d4f15c0db7f5ecb321b6a65e5d6d&#39;</code>。如果有人篡改了你的文章，并发表为<code>&#39;how to use python hashlib - by Bob&#39;</code>，你可以一下子指出Bob篡改了你的文章，因为根据<code>&#39;how to use python hashlib - by Bob&#39;</code>计算出的摘要不同于原始文章的摘要。</p>

<p>可见，摘要算法就是通过摘要函数<code>f()</code>对任意长度的数据<code>data</code>计算出固定长度的摘要<code>digest</code>，目的是为了发现原始数据是否被人篡改过。</p>

<p><font color=red><strong>摘要算法之所以能指出数据是否被篡改过，就是因为摘要函数是一个单向函数，计算f(data)很容易，但通过digest反推data却非常困难。而且，对原始数据做一个bit的修改，都会导致计算出的摘要完全不同。</strong></font></p>

<p>我们以常见的摘要算法MD5为例，计算出一个字符串的MD5值：</p>

<pre><code class="language-py">import hashlib

md5 = hashlib.md5()
md5.update(&#39;how to use md5 in python hashlib?&#39;)

print md5.hexdigest()
</code></pre>

<p>结果为:<br/>
<img src="media/14956154840973/14956157660396.jpg" alt=""/></p>

<p>如果数据量很大，可以分块多次调用<code>update()</code>，最后计算的结果是一样的：</p>

<pre><code class="language-py">import hashlib

md5 = hashlib.md5()
md5.update(&#39;how to use md5 in &#39;)
md5.update(&#39;python hashlib?&#39;)
print md5.hexdigest()

</code></pre>

<p>结果仍然为:<br/>
<img src="media/14956154840973/14956158401991.jpg" alt=""/></p>

<p>当改动一个字母之后,结果会完全不同.</p>

<h1 id="toc_1">==MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。</h1>

<p>另一种常见的摘要算法是<code>SHA1</code>，调用<code>SHA1</code>和调用<code>MD5</code>完全类似：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

import hashlib

sha1 = hashlib.sha1()
sha1.update(&#39;how to use md5 in &#39;)
sha1.update(&#39;python hashlib?&#39;)
print sha1.hexdigest()
</code></pre>

<p><img src="media/14956154840973/14956161682665.jpg" alt=""/></p>

<p>SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。</p>

<p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法越慢，而且摘要长度更长。</p>

<blockquote>
<p>有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能，因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞，比如Bob试图根据你的摘要反推出一篇文章&#39;how to learn hashlib in python - by Bob&#39;，并且这篇文章的摘要恰好和你的文章完全一致，这种情况也并非不可能出现，但是非常非常困难。</p>
</blockquote>

<h2 id="toc_2">摘要算法应用</h2>

<p>一个正确的应用是在存储的数据库表中,将用户登录用的密码进行转换,防止数据泄露导致黑客或者内部人员获取.</p>

<p>正确的保存口令的方式是不存储用户的明文口令，而是存储用户口令的摘要，比如MD5：</p>

<table>
<thead>
<tr>
<th>username</th>
<th>password</th>
</tr>
</thead>

<tbody>
<tr>
<td>michael</td>
<td>e10adc3949ba59abbe56e057f20f883e</td>
</tr>
<tr>
<td>bob</td>
<td>878ef96e86145580c38c87f0410ad153</td>
</tr>
<tr>
<td>alice</td>
<td>99b1c2188db85afee403b1536010c2c9</td>
</tr>
</tbody>
</table>

<p>当用户登录时，首先计算用户输入的明文口令的MD5，然后和数据库存储的MD5对比，如果一致，说明口令输入正确，如果不一致，口令肯定错误。</p>

<h3 id="toc_3">练习:根据用户输入的口令，计算出存储在数据库中的MD5口令：</h3>

<pre><code class="language-py"># -*- coding: utf-8 -*-

import hashlib

def calc_md5(password):
    md5 = hashlib.md5()
    md5.update(password)
    return md5.hexdigest()
password_text = raw_input(&#39;输入密码:&#39;)
print calc_md5(password_text)
</code></pre>

<p><img src="media/14956154840973/14956172486330.jpg" alt=""/></p>

<p>存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。</p>

<h3 id="toc_4">练习：设计一个验证用户登录的函数，根据用户输入的口令是否正确，返回True或False：</h3>

<pre><code class="language-py">db = {
    &#39;michael&#39;: &#39;e10adc3949ba59abbe56e057f20f883e&#39;,
    &#39;bob&#39;: &#39;878ef96e86145580c38c87f0410ad153&#39;,
    &#39;alice&#39;: &#39;99b1c2188db85afee403b1536010c2c9&#39;
}

def login(user, password):
    pass
</code></pre>

<p>实现代码为:</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

import hashlib
db = {
    &#39;michael&#39;: &#39;e10adc3949ba59abbe56e057f20f883e&#39;,
    &#39;bob&#39;: &#39;878ef96e86145580c38c87f0410ad153&#39;,
    &#39;hao&#39;: &#39;e10adc3949ba59abbe56e057f20f883e&#39;
}

def calc_md5(password):
    md5 = hashlib.md5()
    md5.update(password)
    return md5.hexdigest()
def login(user,password):
    md5 = hashlib.md5()
    md5.update(password)
    if user in db:
        if db[user]==md5.hexdigest():
            print &#39;登陆成功&#39;
        else :
            print &#39;失败&#39;
    else:
        print&#39;该用户不存在&#39;
user_text = raw_input(&#39;请输入用户名: &#39;)    
password_text = raw_input(&#39;输入密码: &#39;)

print calc_md5(password_text)
login(user_text, password_text)
</code></pre>

<p><img src="media/14956154840973/14956740702158.jpg" alt=""/></p>

<p>对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？</p>

<p>由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：</p>

<pre><code class="language-py">def calc_md5(password):
    return get_md5(password + &#39;the-Salt&#39;)
</code></pre>

<p>经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。</p>

<p><mark>但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？</mark></p>

<p><strong>如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。</strong></p>

<h3 id="toc_5">练习：根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5：</h3>

<pre><code class="language-py">db = {}

def register(username, password):
    db[username] = get_md5(password + username + &#39;the-Salt&#39;)
</code></pre>

<p>然后，根据修改后的MD5算法实现用户登录的验证：</p>

<pre><code class="language-py">def login(username, password):
    pass
</code></pre>

<p>实现代码:</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

import hashlib
db = {}
def register(username,password):
    if username in db:
        print &#39;用户已存在&#39;
    else:
        db[username] = get_md5(password + username + &#39;the-Slat&#39;) 
def get_md5(text):
    md5 = hashlib.md5()
    md5.update(text)
    return md5.hexdigest()
def login(user,password):
    md5 = hashlib.md5()
    md5.update(password + user + &#39;the-Slat&#39;)
    if user in db:
        if db[user]==md5.hexdigest():
            print &#39;登陆成功&#39;
        else :
            print &#39;失败&#39;
    else:
        print&#39;该用户不存在或者密码错误&#39;
register(&#39;hao&#39;, &#39;123456&#39;)
register(&#39;hao&#39;, &#39;12212&#39;)    #重复注册会显示失败
user_text = raw_input(&#39;请输入用户名: &#39;)    
password_text = raw_input(&#39;输入密码: &#39;)

login(user_text, password_text)
</code></pre>

<p><img src="media/14956154840973/14956751273389.jpg" alt=""/></p>

<h2 id="toc_6">小结</h2>

<p>摘要算法在很多地方都有广泛的应用。<strong>要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文）</strong>，只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/24</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14955029237844.html">
                
                  <h1>Struct</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>准确地讲，Python没有专门处理字节的数据类型。但由于<code>str</code>既是字符串，又可以表示字节，所以，字节数组＝str。而在C语言中，我们可以很方便地用struct、union来处理字节，以及字节和int，float的转换。</p>

<p>在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的str，你得配合位运算符来完成.非常麻烦不利于效率开发.</p>

<p>好在Python提供了一个<code>struct</code>模块来解决str和其他二进制数据类型的转换。</p>

<p><code>struct的pack</code>函数把任意数据类型变成字符串：</p>

<pre><code class="language-py">&gt;&gt;&gt; import struct
&gt;&gt;&gt; struct.pack(&#39;&gt;I&#39;,10240099)
&#39;\x00\x9c@c&#39;
&gt;&gt;&gt;
</code></pre>

<p><code>pack</code>的第一个参数是处理指令，<code>&#39;&gt;I&#39;</code>的意思是：</p>

<p><strong><code>&gt;</code>表示字节顺序是<code>big-endian</code>，也就是网络序，<code>I</code>表示4字节无符号整数。</strong></p>

<p>后面的参数个数要和处理指令一致。</p>

<p><code>unpack</code>把<code>str</code>变成相应的数据类型：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
import struct
print struct.unpack(&#39;&gt;IH&#39;,&#39;\xf0\xf0\xf0\xf0\x80\x80&#39;)
</code></pre>

<p><img src="media/14955029237844/14955050577583.jpg" alt=""/></p>

<p>根据&gt;IH的说明，后面的str依次变为I：4字节无符号整数和H：2字节无符号整数。</p>

<p>所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用<code>struct</code>就方便多了。</p>

<p><code>struct</code>模块定义的数据类型可以参考Python官方文档：<a href="https://docs.python.org/2/library/struct.html#format-characters">https://docs.python.org/2/library/struct.html#format-characters</a></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14955000885655.html">
                
                  <h1>Base64</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">练习:</a>
</li>
<li>
<a href="#toc_1">小结</a>
</li>
</ul>


<p>Base64是一种用64个字符来表示任意二进制数据的方法。</p>

<p>用记事本打开<code>exe、jpg、pdf</code>这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。</p>

<p>Base64的原理很简单，首先，准备一个包含64个字符的数组：</p>

<pre><code>[&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, ... &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, ... &#39;0&#39;, &#39;1&#39;, ... &#39;+&#39;, &#39;/&#39;]
</code></pre>

<p>然后，对二进制数据进行处理，每3个字节一组，一共是<code>3x8=24bit</code>，划为4组，每组正好6个bit：<img src="media/14955000885655/14955010424104.jpg" alt=""/></p>

<p>这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。</p>

<p>所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p>

<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用<code>\x00</code>字节在末尾补足后，再在编码的末尾加上1个或2个<code>=</code>号，表示补了多少字节，解码的时候，会自动去掉。</p>

<p>Python内置的<code>base64</code>可以直接进行base64的编解码：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
import base64
print base64.b64encode(&#39;binary\x00string&#39;)
print base64.b64decode(&#39;YmluYXJ5AHN0cmluZw==&#39;)
</code></pre>

<p><img src="media/14955000885655/14955014556004.jpg" alt=""/></p>

<p>由于标准的Base64编码后可能出现字符<code>+</code>和<code>/</code>，在URL中就不能直接作为参数，所以又有一种&quot;url safe&quot;的base64编码，其实就是把字符<code>+</code>和<code>/</code>分别变成<code>-</code>和<code>_</code>：<br/>
<img src="media/14955000885655/14955018446875.jpg" alt=""/><br/>
还可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。</p>

<p>Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。</p>

<p>Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。</p>

<p>由于<code>=</code>字符也可能出现在Base64编码中，但<code>=</code>用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把<code>=</code>去掉：</p>

<pre><code># 标准Base64:
&#39;abcd&#39; -&gt; &#39;YWJjZA==&#39;
# 自动去掉=:
&#39;abcd&#39; -&gt; &#39;YWJjZA&#39;
</code></pre>

<p>去掉=后怎么解码呢？因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了。</p>

<h2 id="toc_0">练习:</h2>

<p>请写一个能去掉<code>=</code>的base64解码函数:</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
import base64
def safe_b64decode(str):
    num = len(str)%4
    if num==0:
        return base64.b64decode(str)
    else :
        for x in range(num):
             str = str + &#39;=&#39;
        return str 
print base64.b64decode(&#39;YWJjZA==&#39;)
#print base64.b64decode(&#39;YWJjZA&#39;)
print safe_b64decode(&#39;YWJjZA&#39;)
</code></pre>

<p><img src="media/14955000885655/14955026953083.jpg" alt=""/></p>

<h2 id="toc_1">小结</h2>

<p>Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/23</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14945736764798.html">
                
                  <h1>常用内建模块</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>Python中有很多內建模块可以直接使用，无需额外安装。</p>

<h2 id="toc_0">collection</h2>

<p>collections是Python内建的一个集合模块，提供了许多有用的集合类。</p>

<h3 id="toc_1">namedtuple</h3>

<p>我们知道<code>tuple</code>可以表示不变集合，例如，一个点的二维坐标就可以表示成：</p>

<pre><code>p = (1,2)
</code></pre>

<p>但是，看到<code>(1, 2)</code>，很难看出这个<code>tuple</code>是用来表示一个坐标的。</p>

<p>定义一个<code>class</code>又小题大做了，这时，<code>namedtuple</code>就派上了用场：</p>

<pre><code class="language-py">from collections import namedtuple
Point = namedtuple(&#39;Point&#39;,[&#39;x&#39;,&#39;y&#39;])
p = Point(1,2)
print p.x , p.y
</code></pre>

<p><img src="media/14945736764798/14945744048083.jpg" alt=""/><br/>
<code>namedtuple</code>是一个函数，它用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p>

<p>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备<code>tuple</code>的不变性，又可以根据属性来引用，使用十分方便。</p>

<p>可以验证创建的<code>Point</code>对象是<code>tuple</code>的一种子类：</p>

<pre><code class="language-py">print p.x , p.y ,isinstance(p, tuple),isinstance(p, Point)
</code></pre>

<p><img src="media/14945736764798/14945746594923.jpg" alt=""/></p>

<p>类似的，如果要用坐标和半径表示一个圆，也可以用<code>namedtuple</code>定义：</p>

<pre><code class="language-py"># namedtuple(&#39;名称&#39;, [属性list]):
Circle = namedtuple(&#39;Circle&#39;, [&#39;x&#39;, &#39;y&#39;, &#39;r&#39;])
</code></pre>

<h3 id="toc_2">deque</h3>

<p>使用<code>list</code>存储数据时，按索引访问元素很快，但是插入和删除元素就很慢了，因为<code>list</code>是线性存储，数据量大的时候，插入和删除效率很低。</p>

<p><code>deque</code>是为了高效实现插入和删除操作的双向列表，适合用于队列和栈：</p>

<pre><code class="language-py">from collections import deque
q = deque([&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])
q.append(&#39;x&#39;)
q.appendleft(&#39;y&#39;)
print q
</code></pre>

<p><img src="media/14945736764798/14945755049453.jpg" alt=""/></p>

<p><code>deque</code>除了实现list的<code>append()</code>和<code>pop()</code>外，还支持<code>appendleft()</code>和<code>popleft()</code>，这样就可以非常高效地往头部添加或删除元素。</p>

<h3 id="toc_3">defaultdict</h3>

<p>使用<code>dict</code>时，如果引用的Key不存在，就会抛出<code>KeyError</code>。如果希望<code>key</code>不存在时，返回一个默认值，就可以用<code>defaultdict</code>：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

from collections import defaultdict
dd = defaultdict(lambda: &#39;N/A&#39;)
dd[&#39;key1&#39;] = &#39;abc&#39;
print dd[&#39;key1&#39;], dd[&#39;key2&#39;]    #key1存在，key2不存在

</code></pre>

<p><img src="media/14945736764798/14945759067274.jpg" alt=""/><br/>
注意默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。</p>

<p>除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>

<h3 id="toc_4">OrderedDict</h3>

<p>使用<code>dict</code>时，Key是无序的。在对<code>dict</code>做迭代时，我们无法确定<code>Key</code>的顺序。</p>

<p>如果要保持Key的顺序，可以用<code>OrderedDict</code>：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

from collections import OrderedDict
d = dict([(&#39;a&#39;,1),(&#39;b&#39;,2),(&#39;c&#39;,3)])
print d    # dict的Key是无序的
od = OrderedDict([(&#39;a&#39;,1),(&#39;b&#39;,2),(&#39;c&#39;,3)])
print od   #这个是有序的

</code></pre>

<p><img src="media/14945736764798/14945761816386.jpg" alt=""/></p>

<p><font color=red>注意，OrderedDict的Key会按照插入的顺序排列，不是Key本身排序：</font></p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

from collections import OrderedDict
od = OrderedDict()
od[&#39;z&#39;] = 1
od[&#39;y&#39;] = 2
od[&#39;x&#39;] = 3

print od
</code></pre>

<p><img src="media/14945736764798/14945763021698.jpg" alt=""/></p>

<p><code>OrderedDict</code>可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Key：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

from collections import OrderedDict

class LastUpdatedOrderedDict(OrderedDict):

    def __init__(self, capacity):
        super(LastUpdatedOrderedDict, self).__init__()
        self._capacity = capacity

    def __setitem__(self, key, value):
        containsKey = 1 if key in self else 0
        if len(self) - containsKey &gt;= self._capacity:
            last = self.popitem(last=False)
            print &#39;remove:&#39;, last
        if containsKey:
            del self[key]
            print &#39;set:&#39;, (key, value)
        else:
            print &#39;add:&#39;, (key, value)
        OrderedDict.__setitem__(self, key, value)
od = LastUpdatedOrderedDict(3)
od[&#39;z&#39;] = 1
od[&#39;w&#39;] = 2
od[&#39;a&#39;] = 3
od[&#39;q&#39;] = 4
print od  
</code></pre>

<p><img src="media/14945736764798/14945770697335.jpg" alt=""/></p>

<h3 id="toc_5">Counter</h3>

<p><code>Counter</code>是一个简单的计数器，例如，统计字符出现的个数：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
from collections import Counter

c = Counter()
for ch in &#39;Programming&#39;:
    c[ch] = c[ch] + 1

print c

</code></pre>

<p><img src="media/14945736764798/14945772600780.jpg" alt=""/></p>

<h1 id="toc_6">小结</h1>

<p><code>collections</code>模块提供了一些有用的集合类，可以根据需要选用。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/12</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14939712159345.html">
                
                  <h1>正则表达式</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>字符串是编程时涉及到的最多的一种数据结构，对字符串进行操作的需求几乎无处不在。比如判断一个字符串是否是合法的Email地址，虽然可以编程提取<code>@</code>前后的子串，再分别判断是否是单词和域名，但这样做不但麻烦，而且代码难以复用。</p>

<p>正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。</p>

<p>所以我们判断一个字符串是否是合法的Email的方法是：</p>

<ol>
<li><p>创建一个匹配Email的正则表达式；</p></li>
<li><p>用该正则表达式去匹配用户的输入来判断是否合法。</p></li>
</ol>

<p>因为正则表达式也是用字符串表示的，所以，我们要首先了解如何用字符来描述字符。</p>

<p>在正则表达式中，如果直接给出字符，就是精确匹配。用<code>\d</code>可以匹配一个数字，<code>\w</code>可以匹配一个字母或数字，所以：</p>

<ul>
<li><p><code>&#39;00\d&#39;</code>可以匹配<code>&#39;007&#39;</code>，但无法匹配<code>&#39;00A&#39;</code>；</p></li>
<li><p><code>&#39;\d\d\d&#39;</code>可以匹配<code>&#39;010&#39;</code>；</p></li>
<li><p><code>&#39;\w\w\d&#39;</code>可以匹配<code>&#39;py3&#39;</code>；</p></li>
</ul>

<p><code>.</code><strong>可以匹配任意字符</strong>，所以：</p>

<ul>
<li><code>&#39;py.&#39;</code>可以匹配<code>&#39;pyc&#39;</code>、<code>&#39;pyo&#39;</code>、<code>&#39;py!&#39;</code>等等。</li>
</ul>

<p>要匹配变长的字符，在正则表达式中，用<code>*</code>表示任意个字符（包括0个），用<code>+</code>表示至少一个字符，用<code>?</code>表示0个或1个字符，用<code>{n}</code>表示n个字符，用<code>{n,m}</code>表示n-m个字符：</p>

<p>来看一个复杂的例子：<code>\d{3}\s+\d{3,8}</code>。</p>

<p>我们来从左到右解读一下：</p>

<ol>
<li><p><code>\d{3}</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；</p></li>
<li><p><code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>&#39; &#39;，&#39; &#39;</code>等；</p></li>
<li><p><code>\d{3,8}</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。</p></li>
</ol>

<p>综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。</p>

<p>如果要匹配<code>&#39;010-12345&#39;</code>这样的号码呢？由于<code>&#39;-&#39;</code>是特殊字符，在正则表达式中，要用<code>&#39;\&#39;</code>转义，所以，上面的正则是<code>\d{3}\-\d{3,8}</code>。</p>

<p>但是，仍然无法匹配<code>&#39;010 - 12345&#39;</code>，因为带有空格。所以我们需要更复杂的匹配方式。</p>

<h2 id="toc_0">进阶</h2>

<p>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：</p>

<ul>
<li><p><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</p></li>
<li><p><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>&#39;a100&#39;，&#39;0_Z&#39;，&#39;Py3000&#39;</code>等等；</p></li>
<li><p><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</p></li>
<li><p><code>[a-zA-Z\_][0-9a-zA-Z\_]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</p></li>
</ul>

<p><code>A|B</code>可以匹配A或B，所以<code>(P|p)ython</code>可以匹配<code>&#39;Python&#39;</code>或者<code>&#39;python&#39;</code>。</p>

<p><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</p>

<p><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</p>

<p>你可能注意到了，<code>py</code>也可以匹配&#39;python&#39;，但是加上<code>^py$</code>就变成了整行匹配，就只能匹配<code>&#39;py&#39;</code>了。</p>

<h2 id="toc_1">re模块</h2>

<p>有了准备知识，我们就可以在Python中使用正则表达式了。Python提供<code>re</code>模块，包含所有正则表达式的功能。由于Python的字符串本身也用<code>\</code>转义，所以要特别注意：</p>

<pre><code class="language-py">s = &#39;ABC\\-001&#39; # Python的字符串
# 对应的正则表达式字符串变成：
# &#39;ABC\-001&#39;
</code></pre>

<p>因此我们强烈建议使用Python的<code>r</code>前缀，就不用考虑转义的问题了：</p>

<pre><code class="language-py">s = r&#39;ABC\-001&#39; # Python的字符串
# 对应的正则表达式字符串不变：
# &#39;ABC\-001&#39;
</code></pre>

<p>先看看如何判断正则表达式是否匹配：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*
import re

print re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;010-12345&#39;)
print re.match(r&#39;^\d{3}\-\d{3,8}$&#39;, &#39;010 12345&#39;)

</code></pre>

<p><code>match()</code>方法判断是否匹配，如果匹配成功，返回一个<code>Match</code>对象，否则返回<code>None</code>。<br/>
<img src="media/14939712159345/14939732218646.jpg" alt=""/></p>

<p>常见的判断方法就是：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*
import re

Spattern = r&#39;^\d{3}\-\d{3,8}$&#39;  #用户定义的正则表达式
test = &#39;010-12345&#39;  #用户输入的字符串
test2 = &#39;012 12345&#39;
if re.match(Spattern , test):
    print &#39;OK&#39;
else:
    print &#39;failed&#39;

if re.match(Spattern , test2):
    print &#39;OK&#39;
else:
    print &#39;failed&#39;
</code></pre>

<p><img src="media/14939712159345/14939734520573.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/5/5</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="Python练习_1.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>LZH007</h1>
                <div class="site-des">LZH的技术杂事小博客~</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Effective%20OC2.0.html"><strong>Effective OC2.0</strong></a>
        
            <a href="English%20Study.html"><strong>English Study</strong></a>
        
            <a href="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0.html"><strong>机器学习</strong></a>
        
            <a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html"><strong>统计学习方法</strong></a>
        
            <a href="Python%E7%BB%83%E4%B9%A0.html"><strong>Python练习</strong></a>
        
            <a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html"><strong>图像去雾技术</strong></a>
        
            <a href="iOS.html"><strong>iOS</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14956760206333.html">itertools</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14956154840973.html">hashlib</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14956131169957.html">在ios中判断一个viewcontroller是都已经正常present</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14955929300450.html">Caffe代码梳理</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14955245049549.html">运行caffe框架中的cifar10样例</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
