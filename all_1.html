<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  LZH007
  
  </title>
  
  
  <link href="atom.xml" rel="alternate" title="LZH007" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />
    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
  <script src="asset/highlightjs/highlight.pack.js"></script>
  <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script>hljs.initHighlightingOnLoad();</script>
<script type="text/javascript">
  function before_search(){
    var searchVal = 'site:lockxmonk.github.io ' + document.getElementById('search_input').value;
    document.getElementById('search_q').value = searchVal;
    return true;
  }
</script>
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>


  <section class="top-bar-section">
  <div class="row">
      <div style="position: relative;width:100%;"><div style="position: absolute; width:100%;">
        <ul id="main-menu" class="left">
        
        <li id=""><a target="self" href="index.html">Home</a></li>
        
        <li id=""><a target="_self" href="archives.html">Archives</a></li>
        
        </ul>

        <ul class="right" id="search-wrap">
          <li>
<form target="_blank" onsubmit="return before_search();" action="http://google.com/search" method="get">
    <input type="hidden" id="search_q" name="q" value="" />
    <input tabindex="1" type="search" id="search_input"  placeholder="Search"/>
</form>
</li>
          </ul>
      </div></div>
  </div>
  </section>

</nav>

        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; LZH007</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
       
       <li><a href="index.html">HOME</a></li>
    <li><a href="archives.html">Archives</a></li>
    <li><a href="about.html">ABOUT</a></li>

    <li><label>Categories</label></li>

        
            <li><a href="Effective%20OC2.0.html">Effective OC2.0</a></li>
        
            <li><a href="English%20Study.html">English Study</a></li>
        
            <li><a href="%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0.html">深度学习</a></li>
        
            <li><a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html">统计学习方法</a></li>
        
            <li><a href="Python%E7%BB%83%E4%B9%A0.html">Python练习</a></li>
        
            <li><a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html">图像去雾技术</a></li>
         

      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>


        <section id="main-content" role="main" class="scroll-container">
        
       

 <script type="text/javascript">
	$(function(){
		$('#menu_item_index').addClass('is_active');
	});
</script>
<div class="row">
	<div class="large-8 medium-8 columns">
		<div class="markdown-body home-categories">
		
			<div class="article">
                <a class="clearlink" href="14933396433742.html">
                
                  <h1>序列化</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">JSON</a>
</li>
<li>
<a href="#toc_1">JSON进阶</a>
</li>
<li>
<a href="#toc_2">小结</a>
</li>
</ul>


<p><strong>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。</strong></p>

<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>

<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。</p>

<p>Python提供两个模块来实现序列化：<code>cPickle</code>和<code>pickle</code>。这两个模块功能是一样的，区别在于<code>cPickle</code>是C语言写的，速度快，<code>pickle</code>是纯Python写的，速度慢，跟<code>cStringIO和StringIO</code>一个道理。用的时候，先尝试导入<code>cPickle</code>，如果失败，再导入<code>pickle</code>：</p>

<pre><code class="language-py">try:
    import cPickle as pickle
except ImportError:
    import pickle
</code></pre>

<p>我们尝试把一个对象序列化并写入文件：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

d = dict(name=&#39;LZH&#39;,age=20,score=88)
print pickle.dumps(d)
</code></pre>

<p><img src="media/14933396433742/14933403797179.jpg" alt=""/></p>

<p><code>pickle.dumps()</code>方法把任意对象序列化成一个<code>str</code>，然后，就可以把这个<code>str</code>写入文件。或者用另一个方法<code>pickle.dump()</code>直接把对象序列化后写入一个<code>file-like Object</code>：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

d = dict(name=&#39;梁中豪&#39;,age=20,score=88)
f = open(&#39;test.txt&#39;,&#39;wb&#39;)  
pickle.dump(d,f)
f.close

</code></pre>

<p><img src="media/14933396433742/14933405542811.jpg" alt=""/></p>

<p>我们可以读取文件中这些内容，并且将他们反序列化来显示原来的内容：</p>

<pre><code class="language-py">#-*- coding: utf-8 -*-
try:
    import cPickle as pickle
except ImportError: 
    import pickle

#d = dict(name=&#39;梁中豪&#39;,age=20,score=88)
f = open(&#39;test.txt&#39;,&#39;rb&#39;)  
print pickle.load(f)
f.close

</code></pre>

<p>可以先把内容读到一个<code>str</code>，然后用<code>pickle.loads()</code>方法反序列化出对象，也可以直接用<code>pickle.load()</code>方法从一个<code>file-like Object</code>中直接反序列化出对象</p>

<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>

<p>下面我们用JSON来进行网络间的数据传递。</p>

<h2 id="toc_0">JSON</h2>

<p>如果我们要在不同的编程语言之间传递对象，<strong>就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串</strong>，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>

<p><strong><code>JSON</code>表示的对象就是标准的<code>JavaScript</code>语言的对象，<code>JSON</code>和Python内置的数据类型对应如下：</strong></p>

<table>
<thead>
<tr>
<th>Json类型</th>
<th>Python类型</th>
</tr>
</thead>

<tbody>
<tr>
<td>{}</td>
<td>dict</td>
</tr>
<tr>
<td>[]</td>
<td>list</td>
</tr>
<tr>
<td>string</td>
<td>str或u&#39;unicode&#39;</td>
</tr>
<tr>
<td>12345.56</td>
<td>int或float</td>
</tr>
<tr>
<td>true/false</td>
<td>True/False</td>
</tr>
<tr>
<td>null</td>
<td>None</td>
</tr>
</tbody>
</table>

<p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换。我们先看看如何把Python对象变成一个JSON：</p>

<pre><code class="language-py">import json
d = dict(name=&#39;Lichao&#39;, age=20, score=88)
print json.dumps(d)

</code></pre>

<p><img src="media/14933396433742/14933496188910.jpg" alt=""/></p>

<p><code>dumps()</code>方法返回一个<code>str</code>，内容就是标准的JSON。类似的，<code>dump()</code>方法可以直接把JSON写入一个<code>file-like Object</code>。</p>

<p>要把JSON反序列化为Python对象，用<code>loads()</code>或者对应的<code>load()</code>方法，前者把JSON的字符串反序列化，后者从<code>file-like Object</code>中读取字符串并反序列化：</p>

<pre><code class="language-py">import json
json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Lichao&quot;}&#39;
print json.loads(json_str)
</code></pre>

<p><img src="media/14933396433742/14933497889867.jpg" alt=""/></p>

<p>有一点需要注意，就是反序列化得到的所有字符串对象默认都是<code>unicode</code>而不是<code>str</code>。由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的<code>str或unicode</code>与JSON的字符串之间转换。</p>

<h2 id="toc_1">JSON进阶</h2>

<p>Python的<code>dict</code>对象可以直接序列化为JSON的<code>{}</code>，不过，很多时候，我们更喜欢用<code>class</code>表示对象，比如定义<code>Student</code>类，然后序列化：</p>

<pre><code class="language-py">import json


class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;LiChao&#39;, 20, 88)
print(json.dumps(s))
</code></pre>

<p><img src="media/14933396433742/14933605238135.jpg" alt=""/><br/>
向上述那样调用，会报错，因为<code>Student</code>对象不是一个可序列化为JSON的对象。</p>

<p>我们仔细看看<code>dumps()</code>方法的参数列表，可以发现，除了第一个必须的<code>obj</code>参数外，<code>dumps()</code>方法还提供了一大堆的可选参数。</p>

<p>这些可选参数就是让我们来定制JSON序列化。前面的代码之所以无法把<code>Student</code>类实例序列化为JSON，是因为默认情况下，<code>dumps()</code>方法不知道如何将<code>Student</code>实例变为一个JSON的<code>{}</code>对象。</p>

<p>可选参数<code>default</code>就是把任意一个对象变成一个可序列为JSON的对象，我们只需要为<code>Student</code>专门写一个转换函数，再把函数传进去即可：</p>

<pre><code class="language-py">import json

def student2dict(std):
    return {
    &#39;name&#39;:std.name,
    &#39;age&#39;:std.age,
    &#39;score&#39;:std.score
    }

class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

s = Student(&#39;LiChao&#39;, 20, 88)
print(json.dumps(s,default=student2dict))
</code></pre>

<p><img src="media/14933396433742/14933609788679.jpg" alt=""/></p>

<p>这样，<code>Student</code>实例首先被<code>student2dict()</code>函数转换成<code>dict</code>，然后再被顺利序列化为<code>JSON</code>。</p>

<p><strong>不过，下次如果遇到一个<code>Teacher</code>类的实例，照样无法序列化为<code>JSON</code>。我们可以偷个懒，把任意<code>class</code>的实例变为<code>dict</code>：</strong></p>

<pre><code class="language-py">print(json.dumps(s, default=lambda obj: obj.__dict__))
</code></pre>

<p>因为通常<code>class</code>的实例都有一个<code>__dict__</code>属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p>

<p>同样的道理，如果我们要把JSON反序列化为一个<code>Student</code>对象实例，<code>loads()</code>方法首先转换出一个dict对象，然后，我们传入的<code>object_hook</code>函数负责把<code>dict</code>转换为<code>Student</code>实例：</p>

<pre><code class="language-py">import json

def dict2students(d):
    return Student(d[&#39;name&#39;],d[&#39;age&#39;],d[&#39;score&#39;])

class Student(object):

    def __init__(self, name, age, score):
        super(Student, self).__init__()
        self.name = name
        self.age = age
        self.score = score

json_str = &#39;{&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;}&#39;
print(json.loads(json_str,object_hook=dict2students))
</code></pre>

<p><img src="media/14933396433742/14933619206509.jpg" alt=""/></p>

<p>打印出的是反序列化的<code>Student</code>实例对象。</p>

<h2 id="toc_2">小结</h2>

<p>Python语言特定的序列化模块是<code>pickle</code>，但如果要把序列化搞得更通用、更符合Web标准，就可以使用<code>json</code>模块。</p>

<p><code>json</code>模块的<code>dumps()和loads()</code>函数是定义得非常好的接口的典范。当我们使用时，只需要传入一个必须的参数。但是，当默认的序列化或反序列机制不满足我们的要求时，我们又可以传入更多的参数来定制序列化或反序列化的规则，既做到了接口简单易用，又做到了充分的扩展性和灵活性。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/28</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14932778418691.html">
                
                  <h1>操作文件和目录</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">环境变量</a>
</li>
<li>
<a href="#toc_1">操作文件和目录</a>
</li>
<li>
<a href="#toc_2">小结</a>
</li>
<li>
<a href="#toc_3">练习：</a>
</li>
</ul>


<p>如果我们要操作文件、目录，可以在命令行下面输入操作系统提供的各种命令来完成。比如<code>dir</code>、<code>cp</code>等命令</p>

<p>Python内置的<code>os</code>模块也可以直接调用操作系统提供的接口函数。</p>

<p>打开Python交互式命令行，我们来看看如何使用<code>os</code>模块的基本功能：</p>

<p><img src="media/14932778418691/14932780434722.jpg" alt=""/></p>

<p>注意<code>uname()</code>函数在Windows上不提供，也就是说，os模块的某些函数是跟操作系统相关的。</p>

<h2 id="toc_0">环境变量</h2>

<p>在操作系统中定义的环境变量，全部保存在<code>os.environ</code>这个<code>dict</code>中，可以直接查看：<br/>
<img src="media/14932778418691/14932785335515.jpg" alt=""/></p>

<p>要获取某个环境变量的值，可以调用<code>os.getenv()</code>函数：</p>

<p><img src="media/14932778418691/14932786096064.jpg" alt=""/></p>

<h2 id="toc_1">操作文件和目录</h2>

<p>操作文件和目录的函数一部分放在os模块中，一部分放在<code>os.path</code>模块中，这一点要注意一下。查看、创建和删除目录可以这么调用：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print os.path.abspath(&#39;.&#39;)
print os.path.join(&#39;/Users/liangzhonghao/Desktop/&#39;,&#39;test&#39;)

#os.mkdir(&#39;/Users/liangzhonghao/Desktop/python&#39;)
os.rmdir(&#39;/Users/liangzhonghao/Desktop/python&#39;)
</code></pre>

<p><img src="media/14932778418691/14932791801381.jpg" alt=""/></p>

<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print os.path.splitext(&#39;/Users/liangzhonghao/Desktop/text.txt&#39;)
</code></pre>

<p><img src="media/14932778418691/14932792804815.jpg" alt=""/></p>

<p><strong>这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。</strong></p>

<p><code>os</code>模块有很多功能，例如重命名文件，删除文件。但是他没有复制文件的功能。因为复制文件并非是由操作系统提供的系统调用。</p>

<p>幸运的是<code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是<code>os</code>模块的补充。</p>

<p><strong>最后看看如何利用Python的特性来过滤文件</strong>。比如我们要列出当前目录下的所有目录，只需要一行代码：</p>

<pre><code class="language-py">&gt;&gt;&gt; [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]
</code></pre>

<p><img src="media/14932778418691/14932797710625.jpg" alt=""/></p>

<p>要列出所有的.py文件，也只需一行代码：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os
print [x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#39;.py&#39;]
</code></pre>

<p><img src="media/14932778418691/14932798281538.jpg" alt=""/></p>

<h2 id="toc_2">小结</h2>

<p>Python的os模块封装了操作系统的目录和文件操作，要注意这些函数有的在os模块中，有的在<code>os.path</code>模块中</p>

<h2 id="toc_3">练习：</h2>

<p>编写一个<code>search(s)</code>的函数，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出完整路径：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
import os

def search(s ,dir=os.path.abspath(&#39;.&#39;)):
    for x in os.listdir(dir):
        path = os.path.join(dir,x)
        if s in x:
            print path
        elif os.path.isdir(path):
            search(s,path)

search(&#39;pr&#39;)

</code></pre>

<p><img src="media/14932778418691/14932810251430.jpg" alt=""/></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14932734930436.html">
                
                  <h1>I/O编程</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">文件读写</a>
<ul>
<li>
<a href="#toc_1">读文件</a>
</li>
<li>
<a href="#toc_2">file-like Object</a>
</li>
<li>
<a href="#toc_3">二进制文件</a>
</li>
<li>
<a href="#toc_4">写文件</a>
</li>
</ul>
</li>
<li>
<a href="#toc_5">小结</a>
</li>
</ul>


<h2 id="toc_0">文件读写</h2>

<h3 id="toc_1">读文件</h3>

<p>要以读文件的模式来打开一个文件对象，使用Python内置的<code>open（）</code>函数，传入文件名和标识符：</p>

<pre><code class="language-py">&gt;&gt;&gt; f = open(&#39;/Users/michael/test.txt&#39;, &#39;r&#39;)
</code></pre>

<p>标示符&#39;r&#39;表示读，这样，我们就成功地打开了一个文件。</p>

<p>如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在：<br/>
<img src="media/14932734930436/14932737513488.jpg" alt=""/></p>

<p>如果文件打开成功，接下来，调用<code>read()</code>方法可以一次读取文件的全部内容，Python把内容读到内存，用一个<code>str</code>对象表示：<br/>
<img src="media/14932734930436/14932741526772.jpg" alt=""/></p>

<p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现。这种方法太麻烦。我们这里使用python所提供的方法：</p>

<p>Python引入了with语句来自动帮我们调用<code>close()</code>方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;r&#39;) as f:
    print f.read()
</code></pre>

<p><img src="media/14932734930436/14932743740546.jpg" alt=""/></p>

<p>这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p>

<p>调用<code>read()</code>会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取<code>size</code>个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code>。因此，要根据需要决定怎么调用。</p>

<p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;r&#39;) as f:
    for line in f.readlines():
        print(line.strip())  #把末尾的&#39;\n&#39;删掉
</code></pre>

<p><img src="media/14932734930436/14932746986776.jpg" alt=""/></p>

<h3 id="toc_2">file-like Object</h3>

<p>像<code>open()</code>函数返回的这种有个<code>read()</code>方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个<code>read()</code>方法就行。</p>

<p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p>

<h3 id="toc_3">二进制文件</h3>

<p>前面讲的默认都是读取文本文件，并且是ASCII编码的文本文件。要读取二进制文件，比如图片、视频等等，用<code>rb</code>模式打开文件即可：<br/>
<img src="media/14932734930436/14932760233490.jpg" alt=""/></p>

<h3 id="toc_4">写文件</h3>

<p>写文件和读文件是一样的，唯一区别是调用<code>open()</code>函数时，传入标识符<code>&#39;w&#39;</code>或者<code>&#39;wb&#39;</code>表示写文本文件或写二进制文件：</p>

<pre><code class="language-py">&gt;&gt;&gt; f = open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;, &#39;w&#39;)
&gt;&gt;&gt; f.write(&#39;Hello, world!Again！&#39;)
&gt;&gt;&gt; f.close()
</code></pre>

<p>这里推荐直接调用with方法：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-

with open(&#39;/Users/liangzhonghao/Desktop/python学习/test.txt&#39;,&#39;w&#39;) as f:
    f.write(&#39;Hello, world!Again!&#39;)
</code></pre>

<p><img src="media/14932734930436/14932763793296.jpg" alt=""/></p>

<p><font color=red><strong>要注意的是一旦写入文件，原来文件中的内容会被删除！</strong></font></p>

<h2 id="toc_5">小结</h2>

<p>在Python中，文件读写是通过<code>open()</code>函数打开的文件对象完成的。使用<code>with</code>语句操作文件IO是个好习惯。</p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14932622908500.html">
                
                  <h1>文档测试</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p><strong>在python中我们可以执行那些在注释中的代码，来进行测试。</strong></p>

<p>当我们编写注释时，如果写上这样的注释：</p>

<pre><code class="language-py">def abs(n):
    &#39;&#39;&#39;
    Function to get absolute value of number.

    Example:

    &gt;&gt;&gt; abs(1)
    1
    &gt;&gt;&gt; abs(-1)
    1
    &gt;&gt;&gt; abs(0)
    0
    &#39;&#39;&#39;
    return n if n &gt;= 0 else (-n)
</code></pre>

<p>无疑更明确地告诉函数的调用者该函数的期望输入和输出。</p>

<p><strong>并且，Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。</strong></p>

<p><font color=red>doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用...表示中间一大段烦人的输出。</font></p>

<p>让我们用doctest来测试上次编写的<code>Dict</code>类：</p>

<pre><code class="language-py"># -*- coding: utf-8 -*-
class Dict(dict):
    
    &quot;&quot;&quot;
    Simple dict but also support access as x.y style

    &gt;&gt;&gt; d1 = Dict()
    &gt;&gt;&gt; d1[&#39;x&#39;] = 100
    &gt;&gt;&gt; d1.x
    100
    &gt;&gt;&gt; d1.y = 200
    &gt;&gt;&gt; d1[&#39;y&#39;]
    200
    &gt;&gt;&gt; d2 = Dict(a=1, b=2, c=&#39;3&#39;)
    &gt;&gt;&gt; d2.c
    &#39;3&#39;
    &gt;&gt;&gt; d2[&#39;empty&#39;]
    Traceback (most recent call last):
        ...
    KeyError: &#39;empty&#39;
    &gt;&gt;&gt; d2.empty
    Traceback (most recent call last):
        ...
    AttributeError: &#39;Dict&#39; object has no attribute &#39;empty&#39;
    
    &quot;&quot;&quot;
    def __init__(self, **kw):
        super(Dict, self).__init__(**kw)
    def __getattr__(self,key):
        try:
            return self[key]
        except KeyError:
            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)
        else:
            pass
        finally:
            pass
    def __setattr__(self,key,value):
        self[key] = value
if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod()
</code></pre>

<p>如果什么输出都没有，说明我们编写的<code>doctest</code>运行都是正确的。<br/>
<img src="media/14932622908500/14932639594028.jpg" alt=""/><br/>
如果我们把</p>

<pre><code class="language-py">&gt;&gt;&gt; d2.c
    &#39;4&#39; #3改成4
</code></pre>

<p>运行后就会显示：</p>

<p><img src="media/14932622908500/14932640459265.jpg" alt=""/></p>

<p><strong>注意到最后两行代码。当模块正常导入时，doctest不会被执行。只有在命令行运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。</strong></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='Python%E7%BB%83%E4%B9%A0.html'>Python练习</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14932573311953.html">
                
                  <h1>图像去雾相关论文总结</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<ul>
<li>
<a href="#toc_0">1.特征学习的单幅图像去雾算法 2016年</a>
</li>
</ul>
</li>
<li>
<a href="#toc_1">2.尺度自适应暗通道先验去雾方法</a>


<h2 id="toc_0">1.特征学习的单幅图像去雾算法 2016年</h2>

<p><strong>目的：</strong>为提高图像去雾的普适性，提出一种特征学习的单幅图像去雾方法。</p>

<p><strong>方法：</strong>通过稀疏自动编码机对有雾图像进行<strong>多尺度的纹理结构特征提取</strong>，同时抽取各种与雾相关的颜色特征。然后采用多层神经网络进行样本训练，得到雾天条件下纹理结构特征及颜色特征与场景深度间的映射关系，并估算出有雾图像的场景深度图。最后结合大气散射模型，根据场景深度图复原无雾图像。</p>

<p><strong>结论：对实验结果的定性及定量分 析表明，本文算法能有效获取有雾图像的场景深度，复原出视觉效果理想的无雾图像，且具有很好的场景普适性。</strong></p>

<p><strong>理解</strong>：<font color=red>本文认为图像去雾的问题可进一步转化为场景深度d的求解问题。</font>本文通过自动编码机获取到图片中物体的纹理特征，然后用多尺度的方法分别提取<strong>颜色特征、暗原色特征、颜色衰减特征、纹理结构</strong>特征。<strong>四者结合对场景深度进行估计</strong>。</p>

<p><strong>可以改进的</strong>：</p>

<ol>
<li><p>算法实时性不够强，效率比较低，可以考虑缩小图片尺寸，降低数据量，从而运用到视频去雾。</p></li>
<li><p>对雾气分布不均匀的图像，效果不理想，需要结合不同的气象模型来建立更为鲁棒的物理模型。</p></li>
</ol>

<h1 id="toc_1">2.尺度自适应暗通道先验去雾方法</h1>

<p><strong>目的：</strong><br/>
针对暗通道先验去雾方法的尺度选择问题 提出了一种尺度自适应方法， 根据图像的颜色和边 缘特征将暗通道求解的尺度自适应地调整到一个合适的范围。</p>

<p><strong>方法：</strong></p>

<ol>
<li><p>由颜色特征求解初始尺度：<font color=red>对于图像的不同区域采用不同的尺度求解暗通道: 在亮度较低或饱和度较高的区域，采用较小尺度; 在亮度较高且饱和度较低的区域，采用较大尺度;在景深突变处，采用较小尺度;在平滑区域，采用较大尺度。</font></p></li>
<li><p>由边缘特征对尺度进行修正:由于“光晕”现象发生在景深突变处，如果在边缘附近采用较小的尺度，可使透射率的求解窗口\(Ω_r(x)\)尽量不跨越景深边界，从而减小“光晕”现象; 在非边缘处采用较大的尺度，可以增大 \(J_{dark}(x)→0\)的概率，使复原图像的背景更平滑，噪声和失真更小。 由边缘特征对初始尺度\(r_0(x)\)进行修正.</p></li>
</ol>

<p><strong>结论：</strong><br/>
整个去雾过程参数自动配置，无需人工干 预，兼顾不同尺度复原图像的优点，复原图像色彩自然，对比度提升显著，并有效抑制了“光晕”现象。对多种雾化场景图像的处理结果表明: <strong>文中方法对场景的适应性强， 在任何情况下的处理结果均能达到 DG 方法的最优结果，甚至更好。</strong></p>

<p><strong>理解：</strong><br/>
该论文主要是针对HE的去雾方法，对暗通道尺寸进行自适应确定，减少了人工干预的复杂度。</p>

<p><strong>可以改进：</strong><br/>
<font color=red>该算法在运行时间上可以改进，也可以利用机器学习的方法来提取图片特征，避免Canny算子的局限性造成的边缘提取误差。<br/>
可以与上篇论文进行结合来提高上文尺度特征提取的效率。</font></p>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/27</span>
                    <span>posted in&nbsp;</span> 
          				  
          					    <span class="posted-in"><a href='%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html'>图像去雾技术</a></span>
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
			<div class="article">
                <a class="clearlink" href="14928484245894.html">
                
                  <h1>文档测试</h1>
                  <div class="a-content">
                      
                      <div class="a-content-text">
                        
                        	<p>如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。比如<a href="https://docs.python.org/2/library/re.html">re</a>模块就带了很多示例代码：</p>

<pre><code>&gt;&gt;&gt; import re
&gt;&gt;&gt; m = re.search(&#39;(?&lt;=abc)def&#39;, &#39;abcdef&#39;)
&gt;&gt;&gt; m.group(0)
&#39;def&#39;
</code></pre>

<p>可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。</p>

<p>这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？</p>

<p>答案是肯定的。</p>

<p>当我们编写注释时，如果写上这样的注释：</p>

<pre><code class="language-py">
</code></pre>

                        
                      </div>
                  </div>
                </a>
                <div class="read-more clearfix">
                  <div class="more-left left">
                  
                    <span class="date">2017/4/22</span>
                    
          				   
                  </div>
                  <div class="more-right right">
                  <span class="comments">
                      

                       
                  </span>
                  </div>
                </div>
              </div><!-- article -->
        
              


			<div class="row">
			  <div class="large-6 columns">
			  <p class="text-left" style="padding-top:25px;">
			   <a href="all.html">&laquo; Prev Page</a>  
			  </p>
			  </div>
			  <div class="large-6 columns">
			<p class="text-right" style="padding-top:25px;">
			 <a href="all_2.html">&raquo; Next Page</a> 
			</p>
			  </div>
			</div>
		</div>
	</div><!-- large 8 -->

 <div class="large-4 medium-4 columns">
  <div class="hide-for-small">
    <div id="sidebar" class="sidebar">
          <div id="site-info" class="site-info">
            
                <h1>LZH007</h1>
                <div class="site-des">LZH的技术杂事小博客~</div>
                <div class="social">











  <a target="_blank" class="rss" href="atom.xml" title="RSS">RSS</a>
                
              	 </div>
          	</div>

             

              <div id="site-categories" class="side-item ">
                <div class="side-header">
                  <h2>Categories</h2>
                </div>
                <div class="side-content">

      	<p class="cat-list">
        
            <a href="Effective%20OC2.0.html"><strong>Effective OC2.0</strong></a>
        
            <a href="English%20Study.html"><strong>English Study</strong></a>
        
            <a href="%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0.html"><strong>深度学习</strong></a>
        
            <a href="%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95.html"><strong>统计学习方法</strong></a>
        
            <a href="Python%E7%BB%83%E4%B9%A0.html"><strong>Python练习</strong></a>
        
            <a href="%E5%9B%BE%E5%83%8F%E5%8E%BB%E9%9B%BE%E6%8A%80%E6%9C%AF.html"><strong>图像去雾技术</strong></a>
         
        </p>


                </div>
              </div>

              <div id="site-categories" class="side-item">
                <div class="side-header">
                  <h2>Recent Posts</h2>
                </div>
                <div class="side-content">
                <ul class="posts-list">
	      
		      
			      <li class="post">
			        <a href="14938936328646.html">图像去雾相关基础</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14938608177246.html">分布式进程</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14938589289379.html">进程与线程</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14937814533169.html">ThreadLocal</a>
			      </li>
		     
		  
		      
			      <li class="post">
			        <a href="14936919183368.html">多线程</a>
			      </li>
		     
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		  
		      
		   
		  		</ul>
                </div>
              </div>
        </div><!-- sidebar -->
      </div><!-- hide for small -->
</div><!-- large 4 -->

</div><!-- row -->

 <div class="page-bottom clearfix">
  <div class="row">
   <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
</div>

        </section>
      </div>
    </div>

  
    

    <script src="asset/js/foundation.min.js"></script>
    <script>
      $(document).foundation();
      function fixSidebarHeight(){
        var w1 = $('.markdown-body').height();
          var w2 = $('#sidebar').height();
          if (w1 > w2) { $('#sidebar').height(w1); };
      }
      $(function(){
        fixSidebarHeight();
      })
      $(window).load(function(){
          fixSidebarHeight();
      });
     
    </script>

    <script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>


  </body>
</html>
